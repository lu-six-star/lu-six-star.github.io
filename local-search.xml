<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>volatile关键字作用</title>
    <link href="/2025/02/11/embedded_volatile/"/>
    <url>/2025/02/11/embedded_volatile/</url>
    
    <content type="html"><![CDATA[<!-- embedded_volatile--><span id="more"></span><p><code>volatile</code> 关键字在 C&#x2F;C++ 中用于指示编译器 <strong>不对变量进行优化</strong>，确保每次访问都直接读写内存。</p><h3 id="一、核心作用"><a href="#一、核心作用" class="headerlink" title="一、核心作用"></a><strong>一、核心作用</strong></h3><ul><li><strong>禁用编译器优化</strong><br>  强制每次访问变量时从内存读取，而非使用寄存器中的缓存值。</li><li><strong>防止指令重排</strong><br>  阻止编译器或硬件对涉及 <code>volatile</code> 变量的操作进行重排序（需结合内存屏障）。</li></ul><hr><h3 id="二、典型应用场景"><a href="#二、典型应用场景" class="headerlink" title="二、典型应用场景"></a><strong>二、典型应用场景</strong></h3><h4 id="1-内存映射硬件寄存器"><a href="#1-内存映射硬件寄存器" class="headerlink" title="1. 内存映射硬件寄存器"></a><strong>1. 内存映射硬件寄存器</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 硬件寄存器地址声明为volatile</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>* <span class="hljs-type">const</span> UART_STATUS_REG = (<span class="hljs-type">uint32_t</span>*)<span class="hljs-number">0x4000F000</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_char</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">while</span> ((*UART_STATUS_REG &amp; <span class="hljs-number">0x80</span>) == <span class="hljs-number">0</span>); <span class="hljs-comment">// 等待发送缓冲区空</span><br>    *UART_DATA_REG = c;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：确保每次循环都真实读取硬件寄存器状态。</p><h4 id="2-中断服务程序共享变量"><a href="#2-中断服务程序共享变量" class="headerlink" title="2. 中断服务程序共享变量"></a><strong>2. 中断服务程序共享变量</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">bool</span> data_ready = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 中断处理函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ISR</span><span class="hljs-params">()</span> &#123;<br>    data_ready = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 主循环</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">if</span> (data_ready) &#123;<br>        process_data();<br>        data_ready = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>风险</strong>：若无 <code>volatile</code>，编译器可能将 <code>data_ready</code> 缓存在寄存器中，导致死循环。</p><h4 id="3-多线程共享变量（需配合原子操作）"><a href="#3-多线程共享变量（需配合原子操作）" class="headerlink" title="3. 多线程共享变量（需配合原子操作）"></a><strong>3. 多线程共享变量（需配合原子操作）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 线程A</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_A</span><span class="hljs-params">()</span> &#123;<br>    counter++; <span class="hljs-comment">// 非原子操作，需加锁或使用atomic</span><br>&#125;<br><br><span class="hljs-comment">// 线程B</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_B</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, counter);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>volatile</code> 仅保证可见性，不保证原子性，需结合锁或 <code>std::atomic</code>。</p><hr><h3 id="三、与-const-结合使用"><a href="#三、与-const-结合使用" class="headerlink" title="三、与 const 结合使用"></a><strong>三、与 <code>const</code> 结合使用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 只读硬件寄存器</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>* <span class="hljs-type">const</span> DEVICE_ID_REG = (<span class="hljs-type">uint32_t</span>*)<span class="hljs-number">0xFFFF0000</span>;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">get_device_id</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> *DEVICE_ID_REG; <span class="hljs-comment">// 每次读取真实硬件值</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>含义</strong>：</p><ul><li><code>const</code>：程序不应修改该地址的值</li><li><code>volatile</code>：值可能被外部修改，禁止优化</li></ul><hr><h3 id="四、volatile-与编译器优化对比"><a href="#四、volatile-与编译器优化对比" class="headerlink" title="四、volatile 与编译器优化对比"></a><strong>四、volatile 与编译器优化对比</strong></h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> normal_var = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> volatile_var = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    normal_var = <span class="hljs-number">1</span>;<br>    normal_var = <span class="hljs-number">2</span>; <span class="hljs-comment">// 编译器可能优化为直接写2</span><br><br>    volatile_var = <span class="hljs-number">3</span>;<br>    volatile_var = <span class="hljs-number">4</span>; <span class="hljs-comment">// 必须保留两次写操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生成汇编对比</strong>（x86）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">; 非<span class="hljs-keyword">volatile</span>变量<br>mov DWORD PTR [normal_var], <span class="hljs-number">2</span><br><br>; <span class="hljs-keyword">volatile</span>变量<br>mov DWORD PTR [volatile_var], <span class="hljs-number">3</span><br>mov DWORD PTR [volatile_var], <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><hr><h3 id="五、与多线程编程的关系"><a href="#五、与多线程编程的关系" class="headerlink" title="五、与多线程编程的关系"></a><strong>五、与多线程编程的关系</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><code>volatile</code></th><th><code>std::atomic</code></th></tr></thead><tbody><tr><td>可见性</td><td>✔️ 强制内存访问</td><td>✔️ 保证内存顺序一致性</td></tr><tr><td>原子性</td><td>❌ 不保证</td><td>✔️ 保证操作原子性</td></tr><tr><td>编译器优化屏障</td><td>✔️ 禁用局部优化</td><td>部分（依赖内存模型）</td></tr><tr><td>适用场景</td><td>硬件寄存器、中断</td><td>多线程数据竞争</td></tr></tbody></table><p><strong>正确做法</strong>：多线程共享变量应使用 <code>std::atomic</code> 或锁机制，而非仅依赖 <code>volatile</code>。</p><hr><h3 id="六、volatile-的局限性"><a href="#六、volatile-的局限性" class="headerlink" title="六、volatile 的局限性"></a><strong>六、volatile 的局限性</strong></h3><ol><li><strong>不保证原子性</strong><br>  即使 <code>volatile int x</code>，<code>x++</code> 仍是非原子操作（读取-修改-写入三步）。</li><li><strong>无法阻止CPU乱序执行</strong><br>  需配合内存屏障指令（如 <code>std::memory_order</code>）。</li><li><strong>不替代同步机制</strong><br>  不能用于实现互斥锁或条件变量。</li></ol><hr><h3 id="七、代码示例：正确使用姿势"><a href="#七、代码示例：正确使用姿势" class="headerlink" title="七、代码示例：正确使用姿势"></a><strong>七、代码示例：正确使用姿势</strong></h3><h4 id="嵌入式系统按键检测"><a href="#嵌入式系统按键检测" class="headerlink" title="嵌入式系统按键检测"></a><strong>嵌入式系统按键检测</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> button_pressed = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 外部中断处理按键按下</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_IRQHandler</span><span class="hljs-params">()</span> &#123;<br>    button_pressed = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (button_pressed) &#123;<br>            handle_button();<br>            button_pressed = <span class="hljs-number">0</span>; <span class="hljs-comment">// 需原子操作时可关闭中断</span><br>        &#125;<br>        sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内存映射IO操作"><a href="#内存映射IO操作" class="headerlink" title="内存映射IO操作"></a><strong>内存映射IO操作</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_BASE 0x40020000</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> MODER;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ODR;<br>&#125; GPIO_TypeDef;<br><br>GPIO_TypeDef* GPIOA = (GPIO_TypeDef*)GPIO_BASE;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">led_on</span><span class="hljs-params">()</span> &#123;<br>    GPIOA-&gt;MODER |= <span class="hljs-number">0x0400</span>;  <span class="hljs-comment">// 设置引脚为输出</span><br>    GPIOA-&gt;ODR |= <span class="hljs-number">0x0020</span>;    <span class="hljs-comment">// 拉高电平</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="八、常见误用案例"><a href="#八、常见误用案例" class="headerlink" title="八、常见误用案例"></a><strong>八、常见误用案例</strong></h3><h4 id="错误：用volatile实现自旋锁"><a href="#错误：用volatile实现自旋锁" class="headerlink" title="错误：用volatile实现自旋锁"></a><strong>错误：用volatile实现自旋锁</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lock = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (lock == <span class="hljs-number">1</span>); <span class="hljs-comment">// 忙等待</span><br>    lock = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 非原子操作，可能多个线程同时进入</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    lock = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题</strong>：</p><ul><li>无原子性保证，多个线程可能同时获取锁</li><li>正确做法应使用原子CAS操作或系统级锁</li></ul><hr><h3 id="总结表：volatile适用场景"><a href="#总结表：volatile适用场景" class="headerlink" title="总结表：volatile适用场景"></a><strong>总结表：volatile适用场景</strong></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>是否需要volatile</strong></th><th><strong>补充措施</strong></th></tr></thead><tbody><tr><td>硬件寄存器访问</td><td>✔️ 必须</td><td>结合const声明只读寄存器</td></tr><tr><td>中断服务程序共享变量</td><td>✔️ 必须</td><td>关键操作关闭中断</td></tr><tr><td>多线程共享变量</td><td>❌ 不推荐单独使用</td><td>使用atomic或锁</td></tr><tr><td>DMA传输缓冲区</td><td>✔️ 推荐</td><td>确保内存一致性</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OTA升级2</title>
    <link href="/2025/02/11/embedded_ota2/"/>
    <url>/2025/02/11/embedded_ota2/</url>
    
    <content type="html"><![CDATA[<!-- embedded_ota2--><span id="more"></span><p>OTA（Over-The-Air）升级是物联网设备实现远程固件更新的关键技术，需兼顾 <strong>安全性、可靠性和资源效率</strong>。</p><h3 id="一、OTA核心架构"><a href="#一、OTA核心架构" class="headerlink" title="一、OTA核心架构"></a><strong>一、OTA核心架构</strong></h3><h4 id="1-典型四阶段流程"><a href="#1-典型四阶段流程" class="headerlink" title="1. 典型四阶段流程"></a><strong>1. 典型四阶段流程</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">版本检测<br>固件下载<br>完整性验证<br>固件烧录<br>重启生效<br></code></pre></td></tr></table></figure><h4 id="2-双分区设计（A-B分区）"><a href="#2-双分区设计（A-B分区）" class="headerlink" title="2. 双分区设计（A&#x2F;B分区）"></a><strong>2. 双分区设计（A&#x2F;B分区）</strong></h4><ul><li><p>分区布局：</p><ul><li><strong>A区</strong>：运行当前固件（Active）</li><li><strong>B区</strong>：存储新固件（Update）</li><li><strong>Bootloader</strong>：决定启动分区</li></ul></li><li><p><strong>空间开销</strong>：需额外50-100%存储空间，但安全性高</p></li><li><p>示例布局（STM32F4 1MB Flash）：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> APP_A_START  0x08010000  <span class="hljs-comment">// 512KB</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> APP_B_START  0x08090000  <span class="hljs-comment">// 512KB</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOOTLOADER_SIZE 0x10000  <span class="hljs-comment">// 64KB</span></span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="二、安全升级机制"><a href="#二、安全升级机制" class="headerlink" title="二、安全升级机制"></a><strong>二、安全升级机制</strong></h3><h4 id="1-加密与签名"><a href="#1-加密与签名" class="headerlink" title="1. 加密与签名"></a><strong>1. 加密与签名</strong></h4><ul><li><p>非对称签名：使用ECDSA或RSA-2048验证固件来源</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"># 生成签名密钥对<br>openssl ecparam -genkey -name prime256v1 -out ec256.pem<br># 对固件签名<br>openssl dgst -sha256 -sign ec256.pem firmware.bin &gt; firmware.sig<br></code></pre></td></tr></table></figure></li><li><p>固件加密：AES-256-GCM加密传输，防窃听</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 解密固件（伪代码）</span><br>aes_gcm_decrypt(encrypted_bin, key, iv, tag, decrypted_bin);<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-安全启动链"><a href="#2-安全启动链" class="headerlink" title="2. 安全启动链"></a><strong>2. 安全启动链</strong></h4><ul><li><p>Bootloader验证流程：</p><ol><li>检查新固件签名</li><li>对比版本号（防回滚）</li><li>计算SHA-256哈希</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (verify_signature(fw_bin, fw_sig, pub_key) != SUCCESS) <span class="hljs-built_in">abort</span>();<br><span class="hljs-keyword">if</span> (fw_header.version &lt;= current_version) <span class="hljs-built_in">abort</span>();<br><span class="hljs-keyword">if</span> (sha256(fw_bin) != fw_header.hash) <span class="hljs-built_in">abort</span>();<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="三、资源受限优化方案"><a href="#三、资源受限优化方案" class="headerlink" title="三、资源受限优化方案"></a><strong>三、资源受限优化方案</strong></h3><h4 id="1-增量升级（Delta-Update）"><a href="#1-增量升级（Delta-Update）" class="headerlink" title="1. 增量升级（Delta Update）"></a><strong>1. 增量升级（Delta Update）</strong></h4><ul><li><p>bsdiff算法：生成新旧固件差异包（节省50-90%流量）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">bsdiff old_fw.bin new_fw.bin delta.patch<br># 设备端应用补丁<br>bspatch old_fw.bin new_fw.bin delta.patch<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-内存高效下载"><a href="#2-内存高效下载" class="headerlink" title="2. 内存高效下载"></a><strong>2. 内存高效下载</strong></h4><ul><li><p>流式处理：分块下载并实时写入Flash，避免大内存缓冲</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (http_read_chunk(&amp;chunk, size) == SUCCESS) &#123;<br>    flash_write(app_b_partition, chunk, size, offset);<br>    offset += size;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="四、通信协议选择"><a href="#四、通信协议选择" class="headerlink" title="四、通信协议选择"></a><strong>四、通信协议选择</strong></h3><table><thead><tr><th><strong>协议</strong></th><th><strong>适用场景</strong></th><th><strong>安全增强</strong></th></tr></thead><tbody><tr><td>HTTP&#x2F;HTTPS</td><td>广域网，高带宽设备</td><td>TLS 1.3 + 证书固定</td></tr><tr><td>MQTT</td><td>低功耗物联网设备</td><td>TLS-PSK 或 Client Certificates</td></tr><tr><td>CoAP</td><td>受限网络（如6LoWPAN）</td><td>DTLS + OSCORE安全对象</td></tr><tr><td>BLE OTA</td><td>蓝牙设备</td><td>AES-CCM加密 + 连接配对</td></tr></tbody></table><h4 id="MQTT升级示例（ESP32）"><a href="#MQTT升级示例（ESP32）" class="headerlink" title="MQTT升级示例（ESP32）"></a><strong>MQTT升级示例（ESP32）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">firmware_update_callback</span><span class="hljs-params">(<span class="hljs-type">char</span>* topic, byte* payload, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-keyword">if</span> (is_new_version(payload)) &#123;<br>        download_firmware(MQTT_BROKER_URL);<br>        <span class="hljs-keyword">if</span> (verify_firmware()) &#123;<br>            esp_ota_write(...);<br>            esp_restart();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="五、容错与恢复机制"><a href="#五、容错与恢复机制" class="headerlink" title="五、容错与恢复机制"></a><strong>五、容错与恢复机制</strong></h3><h4 id="1-断电保护"><a href="#1-断电保护" class="headerlink" title="1. 断电保护"></a><strong>1. 断电保护</strong></h4><ul><li><p>原子操作：使用Flash的原子写入标记位</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 升级开始前设置状态标记</span><br>flash_write(STATUS_SECTOR, <span class="hljs-string">&quot;UPDATING&quot;</span>, <span class="hljs-number">8</span>);<br><span class="hljs-comment">// 升级完成后标记为&quot;VALID&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-回滚策略"><a href="#2-回滚策略" class="headerlink" title="2. 回滚策略"></a><strong>2. 回滚策略</strong></h4><ul><li><p>看门狗触发：若新固件启动失败，Bootloader超时后切换回旧版</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bootloader_main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (new_fw_valid &amp;&amp; watch_counter &lt; MAX_BOOT_ATTEMPTS) &#123;<br>        boot_new_fw();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        flash_erase(new_fw_area);<br>        boot_old_fw();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-状态机设计"><a href="#3-状态机设计" class="headerlink" title="3. 状态机设计"></a><strong>3. 状态机设计</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    OTA_IDLE,<br>    OTA_DOWNLOADING,<br>    OTA_VALIDATING,<br>    OTA_FAILED<br>&#125; OtaState;<br><br>OtaState current_state = OTA_IDLE;<br></code></pre></td></tr></table></figure><hr><h3 id="六、性能数据对比"><a href="#六、性能数据对比" class="headerlink" title="六、性能数据对比"></a><strong>六、性能数据对比</strong></h3><table><thead><tr><th><strong>方案</strong></th><th>升级时间（1MB固件）</th><th>内存占用</th><th>安全性等级</th></tr></thead><tbody><tr><td>全量HTTPS</td><td>30s</td><td>1MB+</td><td>高</td></tr><tr><td>增量CoAP+DTLS</td><td>10s（300KB补丁）</td><td>50KB</td><td>中</td></tr><tr><td>双分区AES-GCM</td><td>25s</td><td>2MB Flash</td><td>高</td></tr></tbody></table><hr><h3 id="七、实战案例（智能电表OTA）"><a href="#七、实战案例（智能电表OTA）" class="headerlink" title="七、实战案例（智能电表OTA）"></a><strong>七、实战案例（智能电表OTA）</strong></h3><h4 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a><strong>1. 需求分析</strong></h4><ul><li>约束条件：<ul><li>2G网络，带宽受限</li><li>不允许设备变砖</li><li>防中间人攻击</li></ul></li></ul><h4 id="2-方案设计"><a href="#2-方案设计" class="headerlink" title="2. 方案设计"></a><strong>2. 方案设计</strong></h4><ul><li><strong>协议</strong>：CoAP over DTLS（PSK模式）</li><li><strong>差分升级</strong>：bsdiff生成补丁</li><li><strong>双备份分区</strong>：保留两个历史版本</li></ul><h4 id="3-核心代码片段"><a href="#3-核心代码片段" class="headerlink" title="3. 核心代码片段"></a><strong>3. 核心代码片段</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// DTLS预共享密钥配置</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PSK_ID <span class="hljs-string">&quot;smart-meter-01&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PSK_KEY <span class="hljs-string">&quot;a1b2c3d4e5f6&quot;</span></span><br><br><span class="hljs-comment">// CoAP资源定义</span><br>RESOURCE(ota_update, METHOD_POST, <span class="hljs-string">&quot;ota&quot;</span>, <span class="hljs-string">&quot;title=\&quot;OTA Update\&quot;&quot;</span>);<br><span class="hljs-type">void</span> <span class="hljs-title function_">ota_update_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>* request, <span class="hljs-type">void</span>* response)</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* payload = coap_get_payload(request);<br>    process_delta_patch(payload, coap_get_payload_len(request));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="八、调试与测试"><a href="#八、调试与测试" class="headerlink" title="八、调试与测试"></a><strong>八、调试与测试</strong></h3><h4 id="1-异常模拟测试"><a href="#1-异常模拟测试" class="headerlink" title="1. 异常模拟测试"></a><strong>1. 异常模拟测试</strong></h4><ul><li><strong>网络中断</strong>：随机断开WiFi&#x2F;蜂窝网络，验证断点续传</li><li><strong>注入攻击</strong>：发送伪造固件包，测试签名验证是否拦截</li></ul><h4 id="2-日志追踪"><a href="#2-日志追踪" class="headerlink" title="2. 日志追踪"></a><strong>2. 日志追踪</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 启用OTA调试日志</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OTA_DEBUG 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> OTA_DEBUG</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[OTA] Downloading block %d, size=%d\n&quot;</span>, block_num, block_size);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><hr><h3 id="九、合规与认证"><a href="#九、合规与认证" class="headerlink" title="九、合规与认证"></a><strong>九、合规与认证</strong></h3><ul><li>标准遵循：<ul><li>IEC 62443（工业控制系统安全）</li><li>UL 2900-2-2（物联网设备网络安全）</li></ul></li><li>认证流程：<ol><li>第三方安全审计</li><li>渗透测试（如使用Burp Suite）</li><li>获取FCC&#x2F;CE认证</li></ol></li></ul><hr><p>通过 <strong>分层验证、断电保护和资源优化</strong> 设计，OTA方案可在保障安全性的同时，适应从智能家居到工业控制的各种场景需求。关键是在设备资源、安全等级和用户体验之间找到最佳平衡点。</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ota</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式安全机制</title>
    <link href="/2025/02/11/embedded_security_mechanism/"/>
    <url>/2025/02/11/embedded_security_mechanism/</url>
    
    <content type="html"><![CDATA[<!-- embedded_security_mechanism--><span id="more"></span><h3 id="一、硬件级安全机制"><a href="#一、硬件级安全机制" class="headerlink" title="一、硬件级安全机制"></a><strong>一、硬件级安全机制</strong></h3><h4 id="1-安全存储与加密加速"><a href="#1-安全存储与加密加速" class="headerlink" title="1. 安全存储与加密加速"></a><strong>1. 安全存储与加密加速</strong></h4><ul><li><p><strong>eFuse技术</strong><br>   <strong>功能</strong>：熔断一次性可编程存储器，存储根密钥、设备指纹。<br>   <strong>应用</strong>：STM32MP1系列通过eFuse存储Secure Boot公钥哈希。<br>   <strong>代码示例</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 读取eFuse中的密钥（伪代码）</span><br><span class="hljs-type">uint8_t</span> root_key[<span class="hljs-number">32</span>];<br>HAL_EFUSE_Read(EFUSE_KEY_SLOT0, root_key, <span class="hljs-number">32</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>HSM（硬件安全模块）</strong><br>   <strong>芯片型号</strong>：ATECC608A（加密协处理器）<br>   <strong>功能</strong>：</p><ul><li>AES-128&#x2F;256加密</li><li>ECC P-256签名验证</li><li>防物理探测（Tamper-proof）</li></ul></li></ul><h4 id="2-隔离执行环境"><a href="#2-隔离执行环境" class="headerlink" title="2. 隔离执行环境"></a><strong>2. 隔离执行环境</strong></h4><ul><li><p><strong>ARM TrustZone</strong><br>   <strong>原理</strong>：将CPU划分为安全世界（Secure World）和普通世界（Normal World）。<br>   <strong>实现</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 安全世界服务调用（SMC指令）</span><br>__smc(<span class="hljs-number">0x81000000</span>);  <span class="hljs-comment">// 触发安全监控模式调用</span><br></code></pre></td></tr></table></figure><p>  <strong>应用场景</strong>：指纹识别、支付认证（如智能锁）。</p></li><li><p><strong>RISC-V PMP（物理内存保护）</strong><br>   <strong>配置</strong>：设置内存区域权限（RWX）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">csrw pmpaddr0, <span class="hljs-number">0x80000000</span>  # 设置地址范围<br>csrw pmpcfg0, <span class="hljs-number">0x0F</span>         # 权限：RWX + 锁定位<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="二、启动安全"><a href="#二、启动安全" class="headerlink" title="二、启动安全"></a><strong>二、启动安全</strong></h3><h4 id="1-Secure-Boot流程"><a href="#1-Secure-Boot流程" class="headerlink" title="1. Secure Boot流程"></a><strong>1. Secure Boot流程</strong></h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">上电 → <span class="hljs-keyword">BootROM验签一级引导程序 </span>→ 验签内核 → 验签应用 → 启动完成<br></code></pre></td></tr></table></figure><p><strong>实现要素</strong>：</p><ul><li>非对称签名（RSA-2048&#x2F;ECDSA）</li><li>链式验证（每个阶段验证下一级哈希）</li></ul><p><strong>代码示例（U-Boot签名验证）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"># 生成镜像签名<br>openssl dgst -sha256 -sign private.pem u-boot.bin &gt; u-boot.sig<br># 验签流程<br><span class="hljs-keyword">if</span> (rsa_verify(u_boot_bin, hash, signature, public_key) != SUCCESS)<br>    halt_cpu();<br></code></pre></td></tr></table></figure><h4 id="2-防回滚攻击"><a href="#2-防回滚攻击" class="headerlink" title="2. 防回滚攻击"></a><strong>2. 防回滚攻击</strong></h4><ul><li><p>版本计数器：存储于安全区域，固件版本号必须递增。</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">uint32_t current_ver <span class="hljs-operator">=</span> read_otp(VERSION_OTP_ADDR)<span class="hljs-comment">;</span><br>if (new_ver &lt;<span class="hljs-operator">=</span> current_ver) abort()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="三、数据安全"><a href="#三、数据安全" class="headerlink" title="三、数据安全"></a><strong>三、数据安全</strong></h3><h4 id="1-加密存储"><a href="#1-加密存储" class="headerlink" title="1. 加密存储"></a><strong>1. 加密存储</strong></h4><ul><li><strong>透明加密（Flash加密）</strong><br>   <strong>技术</strong>：AES-XTS模式（适合Flash块设备）<br>   <strong>实现</strong>：NXP LPC55S6x支持片上Flash加密引擎。</li><li><strong>密钥轮换</strong><br>   <strong>方案</strong>：定期更新加密密钥，旧数据异步解密后重新加密。</li></ul><h4 id="2-安全认证"><a href="#2-安全认证" class="headerlink" title="2. 安全认证"></a><strong>2. 安全认证</strong></h4><ul><li><p><strong>挑战-响应协议</strong><br>   <strong>流程</strong>：</p><ol><li>设备生成随机数Nonce发送至服务器</li><li>服务器用共享密钥计算HMAC(Nonce)并返回</li><li>设备验证HMAC合法性</li></ol><p>  <strong>代码片段</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> nonce[<span class="hljs-number">16</span>];<br>generate_secure_nonce(nonce);  <span class="hljs-comment">// 使用TRNG生成</span><br>send_to_server(nonce);<br>hmac_sha256(key, nonce, received_hmac);<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="四、通信安全"><a href="#四、通信安全" class="headerlink" title="四、通信安全"></a><strong>四、通信安全</strong></h3><h4 id="1-协议层加密"><a href="#1-协议层加密" class="headerlink" title="1. 协议层加密"></a><strong>1. 协议层加密</strong></h4><ul><li><p><strong>TLS&#x2F;DTLS</strong><br>   <strong>优化</strong>：mbedTLS + 预共享密钥（PSK）降低资源消耗。<br>   <strong>配置</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mbedtls_ssl_conf_psk(&amp;conf, psk, psk_len, identity, identity_len);<br></code></pre></td></tr></table></figure></li><li><p><strong>LoRaWAN安全</strong><br>   <strong>机制</strong>：</p><ul><li>入网时生成NwkSKey（网络会话密钥）和AppSKey（应用会话密钥）</li><li>每帧数据带MIC（消息完整性码）</li></ul></li></ul><h4 id="2-防重放攻击"><a href="#2-防重放攻击" class="headerlink" title="2. 防重放攻击"></a><strong>2. 防重放攻击</strong></h4><ul><li><p>序列号+时间戳</p><p>  实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> seq;     <span class="hljs-comment">// 单调递增序列号</span><br>    <span class="hljs-type">uint32_t</span> timestamp;<br>    <span class="hljs-type">uint8_t</span>  data[<span class="hljs-number">50</span>];<br>    <span class="hljs-type">uint8_t</span>  mac[<span class="hljs-number">32</span>]; <span class="hljs-comment">// HMAC-SHA256</span><br>&#125; SecurePacket;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="五、运行时防护"><a href="#五、运行时防护" class="headerlink" title="五、运行时防护"></a><strong>五、运行时防护</strong></h3><h4 id="1-内存保护"><a href="#1-内存保护" class="headerlink" title="1. 内存保护"></a><strong>1. 内存保护</strong></h4><ul><li><p><strong>MPU（内存保护单元）</strong><br>   <strong>配置</strong>：FreeRTOS-MPU划分任务内存区域，阻止越界访问。<br>   <strong>示例</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义任务内存区域</span><br><span class="hljs-type">static</span> StackType_t task_stack[<span class="hljs-number">1024</span>] __attribute__((aligned(<span class="hljs-number">32</span>)));<br>TaskParameters_t params = &#123;<br>    .pvTaskCode = task_func,<br>    .usStackDepth = <span class="hljs-number">1024</span>,<br>    .pvParameters = <span class="hljs-literal">NULL</span>,<br>    .uxPriority = <span class="hljs-number">1</span>,<br>    .puxStackBuffer = task_stack,<br>    .xRegions = &#123; &#123; (<span class="hljs-type">void</span>*)<span class="hljs-number">0x20000000</span>, <span class="hljs-number">32</span>, portMPU_REGION_READ_WRITE &#125;, &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>ASLR（地址空间随机化）</strong><br>   <strong>实现</strong>：启动时随机化代码&#x2F;数据基址（需MMU支持）。</p></li></ul><h4 id="2-异常监控"><a href="#2-异常监控" class="headerlink" title="2. 异常监控"></a><strong>2. 异常监控</strong></h4><ul><li><p><strong>看门狗（WDT）</strong><br>   <strong>级联看门狗</strong>：</p><ul><li>窗口看门狗（WWDG）：检测软件逻辑错误</li><li>独立看门狗（IWDG）：防硬件故障</li></ul><p>  <strong>配置</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">IWDG_HandleTypeDef hiwdg;<br>hiwdg.Instance = IWDG;<br>hiwdg.Init.Prescaler = IWDG_PRESCALER_256;<br>hiwdg.Init.Reload = <span class="hljs-number">4095</span>;  <span class="hljs-comment">// 超时约30s</span><br>HAL_IWDG_Init(&amp;hiwdg);<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="六、物理攻击防护"><a href="#六、物理攻击防护" class="headerlink" title="六、物理攻击防护"></a><strong>六、物理攻击防护</strong></h3><h4 id="1-防侧信道攻击"><a href="#1-防侧信道攻击" class="headerlink" title="1. 防侧信道攻击"></a><strong>1. 防侧信道攻击</strong></h4><ul><li><p>恒定时间算法</p><p>  示例：密码比较避免短路求值</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">secure_compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *b, <span class="hljs-type">size_t</span> len)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        result |= a[i] ^ b[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> (result == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-光传感器屏蔽"><a href="#2-光传感器屏蔽" class="headerlink" title="2. 光传感器屏蔽"></a><strong>2. 光传感器屏蔽</strong></h4><ul><li><strong>金属屏蔽层</strong>：覆盖关键芯片，防止激光注入攻击。</li></ul><hr><h3 id="七、安全开发实践"><a href="#七、安全开发实践" class="headerlink" title="七、安全开发实践"></a><strong>七、安全开发实践</strong></h3><h4 id="1-工具链加固"><a href="#1-工具链加固" class="headerlink" title="1. 工具链加固"></a><strong>1. 工具链加固</strong></h4><ul><li><p>编译器选项：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">CFLAGS += -fstack-protector-strong -Wformat-security -D_FORTIFY_SOURCE=<span class="hljs-number">2</span><br>LDFLAGS += -Wl,-z,now,-z,relro<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-漏洞扫描"><a href="#2-漏洞扫描" class="headerlink" title="2. 漏洞扫描"></a><strong>2. 漏洞扫描</strong></h4><ul><li><p>静态分析：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"># 使用Cppcheck检测漏洞<br>cppcheck --enable=all --suppress=missingIncludeSystem .<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-安全认证"><a href="#3-安全认证" class="headerlink" title="3. 安全认证"></a><strong>3. 安全认证</strong></h4><ul><li>标准合规：<ul><li>ISO&#x2F;SAE 21434（汽车网络安全）</li><li>UL 2900（物联网设备）</li></ul></li></ul><hr><h3 id="八、典型攻击与防御对照"><a href="#八、典型攻击与防御对照" class="headerlink" title="八、典型攻击与防御对照"></a><strong>八、典型攻击与防御对照</strong></h3><table><thead><tr><th><strong>攻击类型</strong></th><th><strong>防御机制</strong></th><th><strong>实现示例</strong></th></tr></thead><tbody><tr><td>固件提取</td><td>Flash加密 + 安全调试接口锁定</td><td>STM32 RDP级别2</td></tr><tr><td>中间人攻击</td><td>TLS 1.3 + 证书固定</td><td>MbedTLS证书指纹校验</td></tr><tr><td>缓冲区溢出</td><td>MPU分区 + Stack Canary</td><td>FreeRTOS-MPU配置</td></tr><tr><td>时序侧信道</td><td>恒定时间算法</td><td>OpenSSL BN_CTX结构</td></tr></tbody></table><hr><h3 id="九、资源受限设备优化"><a href="#九、资源受限设备优化" class="headerlink" title="九、资源受限设备优化"></a><strong>九、资源受限设备优化</strong></h3><ul><li><strong>轻量级加密</strong>：<ul><li>算法选择：ChaCha20-Poly1305（比AES-GCM省50%资源）</li><li>硬件加速：使用芯片内置AES引擎（如ESP32）</li></ul></li><li><strong>最小化可信计算基（TCB）</strong>：<br>   仅安全引导加载程序和关键服务运行在TrustZone。</li></ul><hr><p>通过硬件安全模块、加密协议、内存保护和持续监控的多层防御，可显著提升嵌入式设备对抗恶意攻击的能力，满足工业控制、医疗设备等高安全场景需求。</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断嵌套优先级配置</title>
    <link href="/2025/02/11/breaks_the_nested_priority_configuration/"/>
    <url>/2025/02/11/breaks_the_nested_priority_configuration/</url>
    
    <content type="html"><![CDATA[<!-- breaks_the_nested_priority_configuration--><span id="more"></span><p>中断嵌套与优先级配置是嵌入式系统实时响应的核心机制。</p><h3 id="一、中断嵌套原理"><a href="#一、中断嵌套原理" class="headerlink" title="一、中断嵌套原理"></a><strong>一、中断嵌套原理</strong></h3><h4 id="1-触发条件"><a href="#1-触发条件" class="headerlink" title="1. 触发条件"></a><strong>1. 触发条件</strong></h4><ul><li><strong>优先级规则</strong>：高优先级中断可抢占低优先级中断（数值越小优先级越高，如ARM Cortex-M）。</li><li><strong>状态允许</strong>：当前中断服务程序（ISR）中全局中断使能（如ARM的<code>PRIMASK</code>已清除）。</li></ul><h4 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2. 执行流程"></a><strong>2. 执行流程</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">低优先级ISR执行中...<br>↓<br>高优先级中断触发<br>↓<br>处理器自动保存当前上下文（压栈）<br>↓<br>跳转至高优先级ISR<br>↓<br>高优先级ISR执行完毕，恢复上下文<br>↓<br>返回低优先级ISR继续执行<br></code></pre></td></tr></table></figure><hr><h3 id="二、优先级配置方法（以ARM-Cortex-M4为例）"><a href="#二、优先级配置方法（以ARM-Cortex-M4为例）" class="headerlink" title="二、优先级配置方法（以ARM Cortex-M4为例）"></a><strong>二、优先级配置方法（以ARM Cortex-M4为例）</strong></h3><h4 id="1-优先级分组"><a href="#1-优先级分组" class="headerlink" title="1. 优先级分组"></a><strong>1. 优先级分组</strong></h4><ul><li><p><strong>寄存器</strong>：<code>SCB-&gt;AIRCR</code>（应用程序中断及复位控制寄存器）</p></li><li><p>分组模式：将8位优先级分为抢占优先级（Preemption）和子优先级（Subpriority）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例：选择优先级分组2（2位抢占，2位子优先级）</span><br>NVIC_SetPriorityGrouping(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><table><thead><tr><th>AIRCR分组值</th><th>抢占优先级位数</th><th>子优先级位数</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>4</td></tr><tr><td>3</td><td>3</td><td>1</td></tr></tbody></table></li></ul><h4 id="2-设置中断优先级"><a href="#2-设置中断优先级" class="headerlink" title="2. 设置中断优先级"></a><strong>2. 设置中断优先级</strong></h4><ul><li><p>函数：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">NVIC_SetPriority(IRQn, priority)<br></code></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置UART中断抢占优先级1，子优先级0 → 优先级值 = (1 &lt;&lt; (4 - 抢占位数)) | 子优先级</span><br>NVIC_SetPriority(UART0_IRQn, <span class="hljs-number">0x10</span> | <span class="hljs-number">0x0</span>);  <span class="hljs-comment">// 假设分组为2（抢占2位，子2位）</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-关键代码示例"><a href="#3-关键代码示例" class="headerlink" title="3. 关键代码示例"></a><strong>3. 关键代码示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">UART0_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 低优先级中断（抢占优先级2）</span><br>    <span class="hljs-comment">// 处理UART数据...</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Timer1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 高优先级中断（抢占优先级1）</span><br>    <span class="hljs-comment">// 紧急任务处理...</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    NVIC_SetPriorityGrouping(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 2位抢占，2位子优先级</span><br>    NVIC_SetPriority(UART0_IRQn, <span class="hljs-number">0x20</span>);  <span class="hljs-comment">// 抢占优先级2（二进制10），子优先级0</span><br>    NVIC_SetPriority(Timer1_IRQn, <span class="hljs-number">0x10</span>);  <span class="hljs-comment">// 抢占优先级1（二进制01），子优先级0</span><br>    NVIC_EnableIRQ(UART0_IRQn);<br>    NVIC_EnableIRQ(Timer1_IRQn);<br>    __enable_irq();  <span class="hljs-comment">// 使能全局中断</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="三、中断嵌套深度与性能影响"><a href="#三、中断嵌套深度与性能影响" class="headerlink" title="三、中断嵌套深度与性能影响"></a><strong>三、中断嵌套深度与性能影响</strong></h3><h4 id="1-最大嵌套深度"><a href="#1-最大嵌套深度" class="headerlink" title="1. 最大嵌套深度"></a><strong>1. 最大嵌套深度</strong></h4><ul><li><p><strong>硬件限制</strong>：Cortex-M默认支持无限嵌套（受栈空间限制）。</p></li><li><p>栈溢出风险：每次嵌套需保存上下文（如8个寄存器），深度嵌套可能导致栈溢出。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 计算最大安全嵌套深度</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE 1024  <span class="hljs-comment">// 假设栈大小1KB</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONTEXT_SIZE 32  <span class="hljs-comment">// 每个中断保存32字节上下文</span></span><br><span class="hljs-type">int</span> max_nesting = STACK_SIZE / CONTEXT_SIZE;  <span class="hljs-comment">// 32层</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-实时性优化"><a href="#2-实时性优化" class="headerlink" title="2. 实时性优化"></a><strong>2. 实时性优化</strong></h4><ul><li><strong>ISR短小化</strong>：高优先级ISR应少于10μs，避免阻塞低优先级任务。</li><li><strong>延迟处理</strong>：将耗时操作移至任务循环或低优先级中断。</li></ul><hr><h3 id="四、实际应用案例（STM32F4）"><a href="#四、实际应用案例（STM32F4）" class="headerlink" title="四、实际应用案例（STM32F4）"></a><strong>四、实际应用案例（STM32F4）</strong></h3><h4 id="1-场景需求"><a href="#1-场景需求" class="headerlink" title="1. 场景需求"></a><strong>1. 场景需求</strong></h4><ul><li><strong>外部中断（按键）</strong>：低优先级，响应用户输入。</li><li><strong>PWM捕获中断</strong>：高优先级，精确测量电机转速。</li></ul><h4 id="2-配置步骤"><a href="#2-配置步骤" class="headerlink" title="2. 配置步骤"></a><strong>2. 配置步骤</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置优先级分组为2位抢占，2位子优先级</span><br>NVIC_SetPriorityGrouping(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 配置EXTI0中断（按键）抢占优先级3</span><br>NVIC_SetPriority(EXTI0_IRQn, <span class="hljs-number">0x30</span>);  <span class="hljs-comment">// 二进制11 | 00</span><br><br><span class="hljs-comment">// 配置TIM1捕获中断抢占优先级1</span><br>NVIC_SetPriority(TIM1_CC_IRQn, <span class="hljs-number">0x10</span>);  <span class="hljs-comment">// 二进制01 | 00</span><br><br><span class="hljs-comment">// 使能中断</span><br>NVIC_EnableIRQ(EXTI0_IRQn);<br>NVIC_EnableIRQ(TIM1_CC_IRQn);<br></code></pre></td></tr></table></figure><h4 id="3-行为验证"><a href="#3-行为验证" class="headerlink" title="3. 行为验证"></a><strong>3. 行为验证</strong></h4><ul><li><p><strong>按键中断触发</strong>：进入<code>EXTI0_IRQHandler</code>。</p></li><li><p><strong>TIM1捕获中断触发</strong>：立即抢占，执行<code>TIM1_CC_IRQHandler</code>。</p></li><li><p>嵌套时序图：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">TIME    | EVENT<br>--------------------------<br><span class="hljs-number">0</span>ms     | EXTI0_IRQHandler开始<br><span class="hljs-number">0.5</span>ms   | TIM1_CC中断触发，抢占<br><span class="hljs-number">1</span>ms     | TIM1_CC_IRQHandler结束<br><span class="hljs-number">1.5</span>ms   | EXTI0_IRQHandler恢复并结束<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="五、常见问题与调试"><a href="#五、常见问题与调试" class="headerlink" title="五、常见问题与调试"></a><strong>五、常见问题与调试</strong></h3><h4 id="1-中断不嵌套"><a href="#1-中断不嵌套" class="headerlink" title="1. 中断不嵌套"></a><strong>1. 中断不嵌套</strong></h4><ul><li><strong>原因</strong>：未重新使能全局中断（如ARM中未清除<code>PRIMASK</code>）。</li><li><strong>解决</strong>：在低优先级ISR内调用<code>__enable_irq()</code>。</li></ul><h4 id="2-优先级反转"><a href="#2-优先级反转" class="headerlink" title="2. 优先级反转"></a><strong>2. 优先级反转</strong></h4><ul><li><strong>场景</strong>：低优先级ISR占用共享资源，阻塞高优先级ISR。</li><li><strong>方案</strong>：使用临界区保护或优先级继承（如FreeRTOS的互斥量）。</li></ul><h4 id="3-性能分析工具"><a href="#3-性能分析工具" class="headerlink" title="3. 性能分析工具"></a><strong>3. 性能分析工具</strong></h4><ul><li><strong>逻辑分析仪</strong>：抓取中断触发时序。</li><li><strong>RTOS Trace</strong>：记录中断执行时间和嵌套深度。</li></ul><hr><h3 id="六、对比总结"><a href="#六、对比总结" class="headerlink" title="六、对比总结"></a><strong>六、对比总结</strong></h3><table><thead><tr><th><strong>架构</strong></th><th><strong>优先级位数</strong></th><th><strong>自动嵌套</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td>ARM Cortex-M</td><td>4-8位可配置</td><td>支持</td><td>实时控制系统</td></tr><tr><td>AVR (Arduino)</td><td>2级固定</td><td>不支持</td><td>简单嵌入式设备</td></tr><tr><td>x86</td><td>APIC多级</td><td>支持</td><td>桌面&#x2F;服务器</td></tr></tbody></table><p>正确配置中断优先级和嵌套可提升系统实时性，但需权衡响应速度与资源消耗。</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/2025/02/11/memory_alignment/"/>
    <url>/2025/02/11/memory_alignment/</url>
    
    <content type="html"><![CDATA[<!-- memory_alignment--><span id="more"></span><h3 id="一、内存对齐原理"><a href="#一、内存对齐原理" class="headerlink" title="一、内存对齐原理"></a><strong>一、内存对齐原理</strong></h3><h4 id="1-硬件要求"><a href="#1-硬件要求" class="headerlink" title="1. 硬件要求"></a><strong>1. 硬件要求</strong></h4><ul><li><strong>访问粒度</strong>：CPU按字长（4&#x2F;8字节）读取内存，对齐数据可单周期完成，非对齐需多次访问。</li><li><strong>架构限制</strong>：RISC架构（如ARMv5、MIPS）严格禁止非对齐访问，触发总线错误；x86允许但性能下降。</li></ul><h4 id="2-对齐规则"><a href="#2-对齐规则" class="headerlink" title="2. 对齐规则"></a><strong>2. 对齐规则</strong></h4><ul><li><p><strong>数据类型对齐值</strong>：由类型大小决定（如<code>int32_t</code>对齐值&#x3D;4，<code>double</code>对齐值&#x3D;8）。</p></li><li><p><strong>结构体对齐</strong>：整体对齐值为成员最大对齐值，大小为其整数倍。</p></li><li><p>示例：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Unaligned</span> &#123;</span><br>    <span class="hljs-type">char</span> a;      <span class="hljs-comment">// 偏移0，大小1</span><br>    <span class="hljs-type">int</span> b;       <span class="hljs-comment">// 偏移4（需对齐4），大小4 → 总大小8（1+3填充+4）</span><br>    <span class="hljs-type">double</span> c;    <span class="hljs-comment">// 偏移8（已对齐8），大小8 → 总大小16</span><br>&#125;;               <span class="hljs-comment">// 结构体对齐值=max(1,4,8)=8 → 总大小16（满足8的倍数）</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="二、不对齐的后果"><a href="#二、不对齐的后果" class="headerlink" title="二、不对齐的后果"></a><strong>二、不对齐的后果</strong></h3><h4 id="1-性能损失"><a href="#1-性能损失" class="headerlink" title="1. 性能损失"></a><strong>1. 性能损失</strong></h4><ul><li><strong>x86</strong>：非对齐访问增加2-3个时钟周期开销。</li><li><strong>ARM Cortex-M</strong>：触发对齐异常，进入中断处理，消耗数百周期。</li></ul><h4 id="2-稳定性风险"><a href="#2-稳定性风险" class="headerlink" title="2. 稳定性风险"></a><strong>2. 稳定性风险</strong></h4><ul><li><strong>硬件异常</strong>：SPARC、早期ARM核直接抛出SIGBUS信号。</li><li><strong>数据错误</strong>：多字节类型（如浮点数）被拆分到不同内存块时读取错误。</li></ul><h4 id="3-空间浪费"><a href="#3-空间浪费" class="headerlink" title="3. 空间浪费"></a><strong>3. 空间浪费</strong></h4><ul><li><p>结构体填充：不合理成员顺序导致冗余填充。</p><p>  示例：调整顺序可节省33%空间：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 原顺序：1(char) +3填充 +4(int) +8(double) =16字节</span><br><span class="hljs-comment">// 优化后：8(double) +4(int) +1(char) +3填充=16字节 → 相同大小但更高效</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="三、实践优化策略"><a href="#三、实践优化策略" class="headerlink" title="三、实践优化策略"></a><strong>三、实践优化策略</strong></h3><h4 id="1-结构体布局优化"><a href="#1-结构体布局优化" class="headerlink" title="1. 结构体布局优化"></a><strong>1. 结构体布局优化</strong></h4><ul><li><p>降序排列：按成员对齐值从大到小排列，最小化填充。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 低效顺序</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bad</span> &#123;</span><br>    <span class="hljs-type">char</span> a;    <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">int</span> b;     <span class="hljs-comment">// 4 → +3填充</span><br>    <span class="hljs-type">double</span> c;  <span class="hljs-comment">// 8 → 总大小16</span><br>&#125;;<br><br><span class="hljs-comment">// 高效顺序</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Good</span> &#123;</span><br>    <span class="hljs-type">double</span> c;  <span class="hljs-comment">// 8</span><br>    <span class="hljs-type">int</span> b;     <span class="hljs-comment">// 4</span><br>    <span class="hljs-type">char</span> a;    <span class="hljs-comment">// 1 → +3填充 → 总大小16</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-手动对齐控制"><a href="#2-手动对齐控制" class="headerlink" title="2. 手动对齐控制"></a><strong>2. 手动对齐控制</strong></h4><ul><li><p><strong>编译器指令</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)    <span class="hljs-comment">// 取消填充，紧密排列（网络传输适用）</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NetworkPacket</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> seq;  <span class="hljs-comment">// 4</span><br>    <span class="hljs-type">char</span> data[<span class="hljs-number">50</span>]; <span class="hljs-comment">// 50 → 总大小54</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()     <span class="hljs-comment">// 恢复默认对齐</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>C11标准</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdalign.h&gt;</span></span><br><span class="hljs-keyword">alignas</span>(<span class="hljs-number">16</span>) <span class="hljs-type">float</span> matrix[<span class="hljs-number">4</span>];  <span class="hljs-comment">// 按16字节对齐（SIMD优化）</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-调试与检测"><a href="#3-调试与检测" class="headerlink" title="3. 调试与检测"></a><strong>3. 调试与检测</strong></h4><ul><li><p><strong>GCC诊断</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -Wpadded -c example.c  # 警告填充字节<br></code></pre></td></tr></table></figure></li><li><p><strong>内存布局分析</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Offset of b: %zu\n&quot;</span>, offsetof(<span class="hljs-keyword">struct</span> Unaligned, b));  <span class="hljs-comment">// 输出4</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-跨平台兼容"><a href="#4-跨平台兼容" class="headerlink" title="4. 跨平台兼容"></a><strong>4. 跨平台兼容</strong></h4><ul><li><p>序列化处理：网络协议避免直接传输结构体，改用逐字段读写：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">send_packet</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> Packet *p)</span> &#123;<br>    write(sock, &amp;p-&gt;seq, <span class="hljs-keyword">sizeof</span>(p-&gt;seq));  <span class="hljs-comment">// 显式处理每个字段</span><br>    write(sock, p-&gt;data, <span class="hljs-keyword">sizeof</span>(p-&gt;data));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="四、性能对比数据"><a href="#四、性能对比数据" class="headerlink" title="四、性能对比数据"></a><strong>四、性能对比数据</strong></h3><table><thead><tr><th><strong>场景</strong></th><th>对齐访问周期</th><th>非对齐访问周期</th></tr></thead><tbody><tr><td>x86-64 (Intel i7)</td><td>1</td><td>3</td></tr><tr><td>ARM Cortex-A53</td><td>1</td><td>异常触发</td></tr><tr><td>RISC-V RV64GC</td><td>1</td><td>异常触发</td></tr></tbody></table><hr><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><ul><li><strong>设计原则</strong>：优先保证正确性，其次优化空间与性能。</li><li>关键决策点：<ul><li>嵌入式系统：严格对齐，避免异常。</li><li>高性能计算：手动对齐至缓存行（通常64字节）提升向量化效率。</li><li>网络通信：使用<code>#pragma pack</code>确保跨平台一致性。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈溢出检测</title>
    <link href="/2025/02/11/stack_overflow_detection/"/>
    <url>/2025/02/11/stack_overflow_detection/</url>
    
    <content type="html"><![CDATA[<!-- stack_overflow_detection--><span id="more"></span><h3 id="1-栈溢出原理"><a href="#1-栈溢出原理" class="headerlink" title="1. 栈溢出原理"></a><strong>1. 栈溢出原理</strong></h3><p><strong>核心问题</strong>：<br> 当程序向栈内写入数据时，超出函数栈帧边界，覆盖返回地址或关键数据。<br> <strong>经典示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vulnerable</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>];<br>    gets(buf);  <span class="hljs-comment">// 无边界检查，输入超8字节会导致溢出</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-检测方法分类"><a href="#2-检测方法分类" class="headerlink" title="2. 检测方法分类"></a><strong>2. 检测方法分类</strong></h3><h4 id="1-编译时检测（静态防御）"><a href="#1-编译时检测（静态防御）" class="headerlink" title="(1) 编译时检测（静态防御）"></a><strong>(1) 编译时检测（静态防御）</strong></h4><ul><li><p><strong>Stack Canary（栈金丝雀）</strong><br>   <strong>原理</strong>：在栈帧返回地址前插入随机值（Canary），函数返回前验证该值是否被篡改。<br>   <strong>实现</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">; x86 GCC编译选项 -fstack-protector<br>mov    eax, gs:<span class="hljs-number">0x14</span>      ; 从线程安全存储区获取Canary值<br>mov    [ebp<span class="hljs-number">-0xC</span>], eax    ; 插入Canary到栈帧<br>... <br>; 函数返回前检查<br>mov    eax, [ebp<span class="hljs-number">-0xC</span>]<br>xor    eax, gs:<span class="hljs-number">0x14</span><br>jne    stack_check_fail  ; Canary值被篡改则终止<br></code></pre></td></tr></table></figure><p>  <strong>局限</strong>：无法防御非覆盖返回地址的攻击（如修改局部变量）。</p></li><li><p><strong>静态代码分析</strong><br>   <strong>工具</strong>：Coverity、Clang Static Analyzer<br>   <strong>检测点</strong>：</p><ul><li>使用危险函数（<code>strcpy</code>, <code>sprintf</code>）</li><li>数组访问未校验边界</li></ul></li></ul><h4 id="2-运行时检测（动态防御）"><a href="#2-运行时检测（动态防御）" class="headerlink" title="(2) 运行时检测（动态防御）"></a><strong>(2) 运行时检测（动态防御）</strong></h4><ul><li><strong>DEP&#x2F;NX（数据执行保护）</strong><br>   <strong>原理</strong>：将栈标记为不可执行（Non-eXecutable），阻止Shellcode运行。<br>   <strong>实现</strong>：通过CPU的NX位（AMD）或XD位（Intel）实现。<br>   <strong>绕过方式</strong>：ROP（Return-Oriented Programming）攻击。</li><li><strong>ASLR（地址空间随机化）</strong><br>   <strong>原理</strong>：随机化栈、堆、库的基址，增加预测返回地址的难度。<br>   <strong>限制</strong>：信息泄露漏洞可绕过（如通过格式化字符串泄露地址）。</li><li><strong>Shadow Stack（影子栈）</strong><br>   <strong>原理</strong>：单独维护返回地址副本，返回时对比主栈和影子栈的地址。<br>   <strong>硬件支持</strong>：Intel CET（Control-flow Enforcement Technology）。</li></ul><h4 id="3-硬件辅助检测"><a href="#3-硬件辅助检测" class="headerlink" title="(3) 硬件辅助检测"></a><strong>(3) 硬件辅助检测</strong></h4><ul><li><strong>Memory Protection Unit (MPU)</strong><br>   <strong>原理</strong>：为栈内存区域设置只读边界，越界写入触发硬件异常。<br>   <strong>应用场景</strong>：实时操作系统（FreeRTOS MPU支持）。</li><li><strong>ARM PAC（指针认证码）</strong><br>   <strong>原理</strong>：对指针附加加密签名，篡改后解密失败。<br>   <strong>指令</strong>：<code>paciasp</code>（签名）、<code>autiasp</code>（验证）。</li></ul><hr><h3 id="3-漏洞利用检测实践"><a href="#3-漏洞利用检测实践" class="headerlink" title="3. 漏洞利用检测实践"></a><strong>3. 漏洞利用检测实践</strong></h3><h4 id="1-动态检测工具"><a href="#1-动态检测工具" class="headerlink" title="(1) 动态检测工具"></a><strong>(1) 动态检测工具</strong></h4><ul><li><p><strong>Valgrind + Memcheck</strong></p>  <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">valgrind <span class="hljs-params">--tool=memcheck</span> <span class="hljs-string">./vulnerable_program</span><br></code></pre></td></tr></table></figure><p>  <strong>输出</strong>：检测未初始化内存、越界访问。</p></li><li><p><strong>AddressSanitizer (ASan)</strong><br>   <strong>编译选项</strong>：<code>-fsanitize=address</code><br>   <strong>原理</strong>：在变量周围插入红区（Red Zone），越界访问触发报告。</p></li></ul><h4 id="2-渗透测试技巧"><a href="#2-渗透测试技巧" class="headerlink" title="(2) 渗透测试技巧"></a><strong>(2) 渗透测试技巧</strong></h4><ul><li><strong>Fuzzing（模糊测试）</strong><br>   <strong>工具</strong>：AFL、libFuzzer<br>   <strong>方法</strong>：生成超长字符串输入，观察程序崩溃行为。</li><li><strong>ROP Chain检测</strong><br>   <strong>特征</strong>：栈中存在连续的小工具地址（如 <code>pop rdi; ret</code>）。</li></ul><hr><h3 id="4-面试回答示例"><a href="#4-面试回答示例" class="headerlink" title="4. 面试回答示例"></a><strong>4. 面试回答示例</strong></h3><p><strong>问：如何检测某C程序是否存在栈溢出漏洞？</strong><br> <strong>答</strong>：</p><ol><li><strong>静态分析</strong>：使用Clang静态分析器扫描代码，重点检查<code>strcpy</code>、<code>scanf</code>等危险函数的使用是否带有边界检查。</li><li><strong>编译加固</strong>：开启GCC的<code>-fstack-protector-strong</code>选项，注入Stack Canary防御机制。</li><li><strong>动态检测</strong>：在测试环境中使用AddressSanitizer（ASan），它能实时检测栈越界访问并生成报告。</li><li><strong>渗透验证</strong>：通过AFL进行模糊测试，输入超长数据观察是否触发<code>*** stack smashing detected ***</code>等Canary保护错误。</li></ol><p><strong>防御升级建议</strong>：</p><ul><li>启用DEP&#x2F;NX和ASLR增加利用难度</li><li>高风险场景使用Rust等内存安全语言替代</li></ul><hr><h3 id="5-对比总结"><a href="#5-对比总结" class="headerlink" title="5. 对比总结"></a><strong>5. 对比总结</strong></h3><table><thead><tr><th><strong>方法</strong></th><th><strong>检测阶段</strong></th><th><strong>开销</strong></th><th><strong>防御能力</strong></th></tr></thead><tbody><tr><td>Stack Canary</td><td>运行时</td><td>低</td><td>阻止返回地址覆盖</td></tr><tr><td>DEP&#x2F;NX</td><td>运行时</td><td>硬件实现</td><td>阻止代码执行</td></tr><tr><td>ASan</td><td>测试阶段</td><td>高</td><td>精准定位越界访问</td></tr><tr><td>静态分析</td><td>编译前</td><td>中</td><td>提前发现代码隐患</td></tr></tbody></table><hr><p>通过组合使用静态分析、编译加固和动态检测，可构建多层栈溢出防御体系，适用于安全关键系统（如物联网设备、金融终端）。</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态电压频率调节（DVFS）策略</title>
    <link href="/2025/02/11/dvfs_strategy/"/>
    <url>/2025/02/11/dvfs_strategy/</url>
    
    <content type="html"><![CDATA[<!-- dvfs_strategy--><span id="more"></span><p>动态电压频率调节（Dynamic Voltage and Frequency Scaling, DVFS）是一种通过 <strong>实时调整处理器电压和频率</strong> 以优化性能与功耗的关键技术。</p><h3 id="1-DVFS-基本原理"><a href="#1-DVFS-基本原理" class="headerlink" title="1. DVFS 基本原理"></a><strong>1. DVFS 基本原理</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>影响</strong></th><th><strong>关系</strong></th></tr></thead><tbody><tr><td><strong>频率 (f)</strong></td><td>计算速度</td><td>功耗 ∝ f × V²</td></tr><tr><td><strong>电压 (V)</strong></td><td>功耗与稳定性</td><td>最低电压由频率决定（V_min ∝ f）</td></tr></tbody></table><p><strong>目标</strong>：在满足性能需求的前提下，找到 <strong>最低可用电压-频率对（V-f Pair）</strong>。</p><hr><h3 id="2-常见DVFS策略"><a href="#2-常见DVFS策略" class="headerlink" title="2. 常见DVFS策略"></a><strong>2. 常见DVFS策略</strong></h3><h4 id="1-按需调节（On-Demand）"><a href="#1-按需调节（On-Demand）" class="headerlink" title="(1) 按需调节（On-Demand）"></a><strong>(1) 按需调节（On-Demand）</strong></h4><ul><li><strong>机制</strong>：监控CPU负载，超过阈值升频，低于阈值降频。</li><li><strong>优势</strong>：响应快，适合负载波动大的场景（如手机交互）。</li><li><strong>Linux实现</strong>：<code>cpufreq_ondemand</code> 调速器。</li></ul><h4 id="2-性能优先（Performance）"><a href="#2-性能优先（Performance）" class="headerlink" title="(2) 性能优先（Performance）"></a><strong>(2) 性能优先（Performance）</strong></h4><ul><li><strong>机制</strong>：始终锁定最高频率。</li><li><strong>应用场景</strong>：计算密集型任务（如游戏、视频渲染）。</li></ul><h4 id="3-节能优先（Powersave）"><a href="#3-节能优先（Powersave）" class="headerlink" title="(3) 节能优先（Powersave）"></a><strong>(3) 节能优先（Powersave）</strong></h4><ul><li><strong>机制</strong>：始终锁定最低频率。</li><li><strong>应用场景</strong>：后台任务或待机状态。</li></ul><h4 id="4-预测调节（Predictive）"><a href="#4-预测调节（Predictive）" class="headerlink" title="(4) 预测调节（Predictive）"></a><strong>(4) 预测调节（Predictive）</strong></h4><ul><li><strong>机制</strong>：基于历史负载预测未来需求，提前调整频率。</li><li><strong>算法示例</strong>：指数加权移动平均（EMA）。</li></ul><h4 id="5-固定步进（Interactive）"><a href="#5-固定步进（Interactive）" class="headerlink" title="(5) 固定步进（Interactive）"></a><strong>(5) 固定步进（Interactive）</strong></h4><ul><li><strong>机制</strong>：负载变化时快速升频，降频则延迟处理。</li><li><strong>适用场景</strong>：用户体验敏感的移动设备。</li></ul><hr><h3 id="3-DVFS-实现步骤"><a href="#3-DVFS-实现步骤" class="headerlink" title="3. DVFS 实现步骤"></a><strong>3. DVFS 实现步骤</strong></h3><h4 id="1-硬件支持"><a href="#1-硬件支持" class="headerlink" title="(1) 硬件支持"></a><strong>(1) 硬件支持</strong></h4><ul><li><strong>电压调节模块（VRM）</strong>：支持动态电压调整。</li><li><strong>时钟生成器（PLL）</strong>：支持频率快速切换。</li></ul><h4 id="2-软件架构"><a href="#2-软件架构" class="headerlink" title="(2) 软件架构"></a><strong>(2) 软件架构</strong></h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">应用层<br>  <span class="hljs-string">|</span><br>调度器（触发负载评估）<br>  <span class="hljs-string">|</span><br>DVFS控制器（决策V-f对）<br>  <span class="hljs-string">|</span><br>内核驱动（写寄存器调整V/f）<br>  <span class="hljs-string">|</span><br>硬件层（CPU/SoC）<br></code></pre></td></tr></table></figure><h4 id="3-代码示例（ARM-Cortex-A-系列）"><a href="#3-代码示例（ARM-Cortex-A-系列）" class="headerlink" title="(3) 代码示例（ARM Cortex-A 系列）"></a><strong>(3) 代码示例（ARM Cortex-A 系列）</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 设置频率和电压（伪代码）</span><br><span class="hljs-keyword">void</span> set_cpu_freq(uint32_t freq, uint32_t voltage) &#123;<br>    <span class="hljs-comment">// 1. 切换至中间频率（避免电压不足）</span><br>    write_clock_reg(INTERMEDIATE_FREQ);<br>    <br>    <span class="hljs-comment">// 2. 调整电压</span><br>    set_voltage_reg(voltage);<br>    <br>    <span class="hljs-comment">// 3. 设置目标频率</span><br>    write_clock_reg(freq);<br>&#125;<br><br><span class="hljs-comment">// Linux用户层触发频率调整</span><br>$ echo <span class="hljs-string">&quot;userspace&quot;</span> &gt; <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu0/</span>cpufreq/scaling_governor<br>$ echo <span class="hljs-number">1200000</span> &gt; <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu0/</span>cpufreq/scaling_setspeed<br></code></pre></td></tr></table></figure><hr><h3 id="4-关键优化技术"><a href="#4-关键优化技术" class="headerlink" title="4. 关键优化技术"></a><strong>4. 关键优化技术</strong></h3><h4 id="1-电压-频率表（V-f-Table）"><a href="#1-电压-频率表（V-f-Table）" class="headerlink" title="(1) 电压-频率表（V-f Table）"></a><strong>(1) 电压-频率表（V-f Table）</strong></h4><ul><li><p><strong>预校准表</strong>：芯片厂商提供，确保每个频率对应最低稳定电压。</p></li><li><p>示例：</p><table><thead><tr><th>频率 (MHz)</th><th>电压 (mV)</th></tr></thead><tbody><tr><td>2000</td><td>1100</td></tr><tr><td>1500</td><td>950</td></tr><tr><td>1000</td><td>850</td></tr></tbody></table></li></ul><h4 id="2-温度补偿"><a href="#2-温度补偿" class="headerlink" title="(2) 温度补偿"></a><strong>(2) 温度补偿</strong></h4><ul><li><strong>动态降频</strong>：温度超过阈值时强制降频（如Tjunc &gt; 85°C）。</li><li><strong>实现</strong>：读取温度传感器，调整V-f表。</li></ul><h4 id="3-多核协同"><a href="#3-多核协同" class="headerlink" title="(3) 多核协同"></a><strong>(3) 多核协同</strong></h4><ul><li><strong>集群调节</strong>：多核CPU分组管理，按负载启用&#x2F;关闭核心。</li><li><strong>负载均衡</strong>：迁移任务到低负载核心，关闭空闲核心。</li></ul><hr><h3 id="5-实际应用案例"><a href="#5-实际应用案例" class="headerlink" title="5. 实际应用案例"></a><strong>5. 实际应用案例</strong></h3><h4 id="1-智能手机（Android）"><a href="#1-智能手机（Android）" class="headerlink" title="(1) 智能手机（Android）"></a><strong>(1) 智能手机（Android）</strong></h4><ul><li><strong>场景</strong>：屏幕触摸时升频至1.5GHz，静止时降频至500MHz。</li><li><strong>策略</strong>：<code>interactive</code> 调速器 + 温度监控。</li></ul><h4 id="2-数据中心服务器"><a href="#2-数据中心服务器" class="headerlink" title="(2) 数据中心服务器"></a><strong>(2) 数据中心服务器</strong></h4><ul><li><strong>目标</strong>：在SLA（服务协议）内最大化能效比。</li><li><strong>方法</strong>：根据QPS（每秒请求数）动态调整CPU频率。</li></ul><h4 id="3-嵌入式设备（无人机）"><a href="#3-嵌入式设备（无人机）" class="headerlink" title="(3) 嵌入式设备（无人机）"></a><strong>(3) 嵌入式设备（无人机）</strong></h4><ul><li><strong>需求</strong>：突发计算（图像处理）时升频，巡航时降频。</li><li><strong>实现</strong>：基于RTOS的任务优先级触发DVFS。</li></ul><hr><h3 id="6-挑战与解决方案"><a href="#6-挑战与解决方案" class="headerlink" title="6. 挑战与解决方案"></a><strong>6. 挑战与解决方案</strong></h3><table><thead><tr><th><strong>挑战</strong></th><th><strong>解决方案</strong></th></tr></thead><tbody><tr><td>频率切换延迟（μs级）</td><td>预判负载变化，提前调整</td></tr><tr><td>电压瞬态导致的不稳定</td><td>加入稳压电容，分步切换电压</td></tr><tr><td>多核频率协同</td><td>使用CPPC（协作处理器性能控制）协议</td></tr><tr><td>非线性功耗模型</td><td>机器学习预测最佳V-f点（如强化学习）</td></tr></tbody></table><hr><h3 id="7-监控与调试工具"><a href="#7-监控与调试工具" class="headerlink" title="7. 监控与调试工具"></a><strong>7. 监控与调试工具</strong></h3><ul><li><p>Linux工具：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 查看当前频率策略</span><br>cat <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu0/</span>cpufreq/scaling_governor<br><br><span class="hljs-comment"># 实时监控频率</span><br>watch -n <span class="hljs-number">1</span> <span class="hljs-string">&quot;cat /proc/cpuinfo | grep &#x27;MHz&#x27;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>硬件探头</strong>：示波器测量Vcore引脚电压波动。</p></li></ul><hr><h3 id="8-能效评估指标"><a href="#8-能效评估指标" class="headerlink" title="8. 能效评估指标"></a><strong>8. 能效评估指标</strong></h3><ul><li><strong>MIPS&#x2F;Watt</strong>：每瓦特百万指令数。</li><li>**Energy-Delay Product (EDP)**：能量延迟积，综合评估指标。</li></ul><hr><p>通过合理设计DVFS策略，可在 <strong>性能损失 &lt;5%</strong> 的情况下，实现 <strong>20-40% 的功耗降低</strong>，广泛应用于从IoT设备到超算的各类场景。</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DVFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设备树（DTS）硬件描述与覆盖机制</title>
    <link href="/2025/02/11/dts_description_overlay/"/>
    <url>/2025/02/11/dts_description_overlay/</url>
    
    <content type="html"><![CDATA[<!-- pwm_waveform_generation--><span id="more"></span><p>设备树（Device Tree，DTS）及其覆盖机制（Overlay）是嵌入式Linux系统中管理硬件配置的核心技术。</p><h3 id="1-设备树基础"><a href="#1-设备树基础" class="headerlink" title="1. 设备树基础"></a><strong>1. 设备树基础</strong></h3><h4 id="1-设备树的作用"><a href="#1-设备树的作用" class="headerlink" title="(1) 设备树的作用"></a><strong>(1) 设备树的作用</strong></h4><ul><li><strong>硬件抽象</strong>：将硬件配置（地址、中断、外设连接）从内核代码中解耦，提高可移植性。</li><li><strong>动态适配</strong>：同一内核镜像支持不同硬件平台，通过加载不同的设备树二进制文件（DTB）实现。</li></ul><h4 id="2-设备树组成"><a href="#2-设备树组成" class="headerlink" title="(2) 设备树组成"></a><strong>(2) 设备树组成</strong></h4><ul><li><strong>节点（Node）</strong>：表示硬件设备或总线，以树形结构组织。</li><li><strong>属性（Property）</strong>：键值对，描述设备的寄存器地址、中断号、时钟频率等。</li><li><strong>兼容性（Compatible）</strong>：关键属性，用于驱动匹配（如 <code>compatible = &quot;ti,omap3-i2c&quot;</code>）。</li></ul><h4 id="3-设备树语法示例"><a href="#3-设备树语法示例" class="headerlink" title="(3) 设备树语法示例"></a><strong>(3) 设备树语法示例</strong></h4><DTS><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 根节点</span><br><span class="hljs-title class_">/</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;vendor,board&quot;</span><span class="hljs-punctuation">;</span>  <span class="hljs-comment">// 板级兼容性</span><br>    <span class="hljs-meta">#address-cells = &lt;1&gt;;         <span class="hljs-comment">// 子节点地址用1个cell表示</span></span><br>    <span class="hljs-meta">#size-cells = &lt;1&gt;;            <span class="hljs-comment">// 子节点大小用1个cell表示</span></span><br><br>    <span class="hljs-comment">// I2C控制器节点</span><br><span class="hljs-symbol">    i2c0:</span> <span class="hljs-title class_">i2c@ffec0000</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;snps,designware-i2c&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0xffec0000</span> <span class="hljs-number">0x1000</span>&gt;</span><span class="hljs-punctuation">;</span>        <span class="hljs-comment">// 寄存器地址和长度</span><br>        <span class="hljs-attr">interrupts</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">15</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 中断号及触发类型</span><br>        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>        <span class="hljs-meta">#size-cells = &lt;0&gt;;</span><br><br>        <span class="hljs-comment">// I2C设备子节点（如EEPROM）</span><br>        <span class="hljs-title class_">eeprom@50</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atmel,24c256&quot;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x50</span>&gt;</span><span class="hljs-punctuation">;</span>                 <span class="hljs-comment">// I2C从机地址</span><br>            <span class="hljs-attr">pagesize</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">64</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-punctuation">&#125;;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-关键机制解析"><a href="#2-关键机制解析" class="headerlink" title="2. 关键机制解析"></a><strong>2. 关键机制解析</strong></h3><h4 id="1-地址与大小表示"><a href="#1-地址与大小表示" class="headerlink" title="(1) 地址与大小表示"></a><strong>(1) 地址与大小表示</strong></h4><ul><li><strong>#address-cells</strong> 和 <strong>#size-cells</strong>：<br>  定义子节点 <code>reg</code> 属性中地址和长度的cell数量（1 cell &#x3D; 32位）。<br>  例如：<code>reg = &lt;0xffec0000 0x1000&gt;</code> 表示起始地址 <code>0xffec0000</code>，长度 <code>0x1000</code>。</li></ul><h4 id="2-中断处理"><a href="#2-中断处理" class="headerlink" title="(2) 中断处理"></a><strong>(2) 中断处理</strong></h4><ul><li><p><strong>interrupt-parent</strong>：指定中断控制器节点（通过 <code>phandle</code> 引用）。</p></li><li><p>interrupts：中断号和触发方式。</p>  <DTS>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">gpio_keys</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;gpio-keys&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-attr">interrupt-parent</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;gpio0</span>&gt;</span><span class="hljs-punctuation">;</span>  <span class="hljs-comment">// 引用gpio0节点的phandle</span><br>    <span class="hljs-attr">interrupts</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">5</span> IRQ_TYPE_EDGE_RISING&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// GPIO5，上升沿触发</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-引用与标签（Labels）"><a href="#3-引用与标签（Labels）" class="headerlink" title="(3) 引用与标签（Labels）"></a><strong>(3) 引用与标签（Labels）</strong></h4><ul><li><strong>&amp;label</strong>：引用其他节点（如 <code>&amp;gpio0</code> 指向标签为 <code>gpio0</code> 的节点）。</li><li><strong>phandle</strong>：节点唯一标识符，由编译器自动生成或手动指定。</li></ul><hr><h3 id="3-设备树覆盖（Overlay）"><a href="#3-设备树覆盖（Overlay）" class="headerlink" title="3. 设备树覆盖（Overlay）"></a><strong>3. 设备树覆盖（Overlay）</strong></h3><h4 id="1-覆盖的作用"><a href="#1-覆盖的作用" class="headerlink" title="(1) 覆盖的作用"></a><strong>(1) 覆盖的作用</strong></h4><ul><li><strong>动态修改设备树</strong>：在运行时添加、修改或删除节点，无需重新编译整个DTB。</li><li><strong>应用场景</strong>：模块化硬件扩展（如树莓派HAT）、热插拔设备配置。</li></ul><h4 id="2-覆盖文件示例"><a href="#2-覆盖文件示例" class="headerlink" title="(2) 覆盖文件示例"></a><strong>(2) 覆盖文件示例</strong></h4><DTS><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-keyword">/dts-v1/</span><span class="hljs-punctuation">;</span><br><span class="hljs-keyword">/plugin/</span><span class="hljs-punctuation">;</span>  <span class="hljs-comment">// 声明为覆盖文件</span><br><br><span class="hljs-comment">// 覆盖目标节点（基础设备树中的i2c1）</span><br><span class="hljs-variable">&amp;i2c1</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>    <span class="hljs-meta">#size-cells = &lt;0&gt;;</span><br>    <span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;okay&quot;</span><span class="hljs-punctuation">;</span>  <span class="hljs-comment">// 启用i2c1控制器</span><br><br>    <span class="hljs-comment">// 添加新的I2C设备</span><br>    <span class="hljs-title class_">touchscreen@38</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;edt,edt-ft5406&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x38</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">interrupt-parent</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;gpio</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">interrupts</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">17</span> IRQ_TYPE_EDGE_FALLING&gt;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><h4 id="3-覆盖应用流程"><a href="#3-覆盖应用流程" class="headerlink" title="(3) 覆盖应用流程"></a><strong>(3) 覆盖应用流程</strong></h4><ol><li><p><strong>编译覆盖文件</strong>：</p> <BASH> <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">dtc</span> <span class="hljs-operator">-@</span> <span class="hljs-operator">-</span><span class="hljs-built_in">I</span> <span class="hljs-variable">dts</span> <span class="hljs-operator">-</span><span class="hljs-built_in">O</span> <span class="hljs-variable">dtb</span> <span class="hljs-operator">-</span><span class="hljs-variable">o</span> <span class="hljs-variable">overlay</span><span class="hljs-operator">.</span><span class="hljs-variable">dtbo</span> <span class="hljs-variable">overlay</span><span class="hljs-operator">.</span><span class="hljs-variable">dts</span><br></code></pre></td></tr></table></figure><p> <code>-@</code> 选项生成符号表，支持标签引用。</p></li><li><p><strong>加载覆盖</strong>：</p><ul><li><p><strong>U-Boot</strong>：使用 <code>fdt apply</code> 命令。</p></li><li><p>Linux运行时：通过ConfigFS（需内核启用CONFIG_OF_OVERLAY）：</p>  <BASH>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/config/</span>device-tree<span class="hljs-regexp">/overlays/</span>custom<br>cat overlay.dtbo &gt; <span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/config/</span>device-tree<span class="hljs-regexp">/overlays/</span>custom/dtbo<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="4-覆盖冲突处理"><a href="#4-覆盖冲突处理" class="headerlink" title="(4) 覆盖冲突处理"></a><strong>(4) 覆盖冲突处理</strong></h4><ul><li><strong>节点冲突</strong>：同名节点会合并属性，若存在不可合并属性则覆盖。</li><li><strong>状态管理</strong>：通过 <code>status</code> 属性启用&#x2F;禁用设备（如 <code>status = &quot;disabled&quot;;</code>）。</li></ul><hr><h3 id="4-调试与分析工具"><a href="#4-调试与分析工具" class="headerlink" title="4. 调试与分析工具"></a><strong>4. 调试与分析工具</strong></h3><h4 id="1-反编译DTB"><a href="#1-反编译DTB" class="headerlink" title="(1) 反编译DTB"></a><strong>(1) 反编译DTB</strong></h4><BASH><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">dtc</span> <span class="hljs-operator">-</span><span class="hljs-built_in">I</span> <span class="hljs-variable">dtb</span> <span class="hljs-operator">-</span><span class="hljs-built_in">O</span> <span class="hljs-variable">dts</span> <span class="hljs-operator">-</span><span class="hljs-variable">o</span> <span class="hljs-variable">extracted</span><span class="hljs-operator">.</span><span class="hljs-variable">dts</span> <span class="hljs-variable">system</span><span class="hljs-operator">.</span><span class="hljs-variable">dtb</span><br></code></pre></td></tr></table></figure><h4 id="2-查看运行时设备树"><a href="#2-查看运行时设备树" class="headerlink" title="(2) 查看运行时设备树"></a><strong>(2) 查看运行时设备树</strong></h4><BASH><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 列出所有节点</span><br>ls <span class="hljs-regexp">/sys/</span>firmware<span class="hljs-regexp">/devicetree/</span>base/<br><br><span class="hljs-comment"># 查看节点属性（需转换为ASCII）</span><br>hexdump -C <span class="hljs-regexp">/sys/</span>firmware<span class="hljs-regexp">/devicetree/</span>base<span class="hljs-regexp">/i2c0/</span>reg<br></code></pre></td></tr></table></figure><h4 id="3-内核日志"><a href="#3-内核日志" class="headerlink" title="(3) 内核日志"></a><strong>(3) 内核日志</strong></h4><ul><li>启用 <code>CONFIG_DEBUG_DEVICE_TREE</code>，查看设备树解析日志。</li></ul><hr><h3 id="5-典型问题与解决"><a href="#5-典型问题与解决" class="headerlink" title="5. 典型问题与解决"></a><strong>5. 典型问题与解决</strong></h3><h4 id="Q1：驱动未正确匹配"><a href="#Q1：驱动未正确匹配" class="headerlink" title="Q1：驱动未正确匹配"></a><strong>Q1：驱动未正确匹配</strong></h4><ul><li>检查点：<ul><li><code>compatible</code> 属性是否与驱动中的of_match_table一致。</li><li>使用 <code>of_find_compatible_node()</code> 确认节点是否存在。</li></ul></li></ul><h4 id="Q2：地址映射错误"><a href="#Q2：地址映射错误" class="headerlink" title="Q2：地址映射错误"></a><strong>Q2：地址映射错误</strong></h4><ul><li><strong>验证方法</strong>：<br>  检查 <code>reg</code> 属性是否与硬件手册一致，确认父节点的 <code>ranges</code> 映射正确。</li></ul><h4 id="Q3：覆盖加载失败"><a href="#Q3：覆盖加载失败" class="headerlink" title="Q3：覆盖加载失败"></a><strong>Q3：覆盖加载失败</strong></h4><ul><li>调试步骤：<ol><li>检查覆盖文件语法：<code>dtc -I dtb -O dts -f overlay.dtbo</code>。</li><li>确认基础设备树中存在目标节点路径。</li><li>查看内核日志：<code>dmesg | grep of_overlay</code>。</li></ol></li></ul><hr><h3 id="6-总结对比"><a href="#6-总结对比" class="headerlink" title="6. 总结对比"></a><strong>6. 总结对比</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>基础设备树（DTS）</strong></th><th><strong>设备树覆盖（Overlay）</strong></th></tr></thead><tbody><tr><td><strong>修改方式</strong></td><td>静态编译，需重新生成DTB</td><td>动态加载，实时生效</td></tr><tr><td><strong>适用场景</strong></td><td>固定硬件配置</td><td>模块化扩展、后期硬件调整</td></tr><tr><td><strong>复杂度</strong></td><td>完整描述所有硬件</td><td>仅描述变更部分</td></tr><tr><td><strong>调试难度</strong></td><td>需重新烧录DTB</td><td>可快速迭代，通过日志排查</td></tr></tbody></table><p>通过合理使用设备树及其覆盖机制，开发者能够高效管理复杂硬件配置，适应嵌入式系统灵活多变的需求。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWM波形生成</title>
    <link href="/2025/02/11/pwm_waveform_generation/"/>
    <url>/2025/02/11/pwm_waveform_generation/</url>
    
    <content type="html"><![CDATA[<!-- pwm_waveform_generation--><span id="more"></span><p>PWM（脉冲宽度调制）是一种通过调节脉冲的<strong>占空比</strong>来控制模拟信号的技术，广泛应用于电机调速、LED调光、电源控制等领域。</p><h3 id="1-PWM核心参数"><a href="#1-PWM核心参数" class="headerlink" title="1. PWM核心参数"></a><strong>1. PWM核心参数</strong></h3><ul><li><strong>频率（Frequency）</strong>：<br>   每秒内脉冲重复的次数，单位Hz。<ul><li>电机控制：1kHz~20kHz（避免可闻噪声）。</li><li>LED调光：100Hz~1kHz（高于人眼闪烁感知频率）。</li><li>音频生成：20Hz~20kHz（需匹配音频范围）。</li></ul></li><li><strong>占空比（Duty Cycle）</strong>：<br>   高电平时间占整个周期的百分比，范围0%~100%。<ul><li>占空比 &#x3D; (高电平时间 &#x2F; 周期时间) × 100%</li></ul></li><li><strong>分辨率（Resolution）</strong>：<br>   占空比可调节的最小步长，由计数器位数决定。<ul><li>8位分辨率：256级（步长0.39%）。</li><li>16位分辨率：65536级（步长0.0015%）。</li></ul></li></ul><hr><h3 id="2-PWM生成原理"><a href="#2-PWM生成原理" class="headerlink" title="2. PWM生成原理"></a><strong>2. PWM生成原理</strong></h3><h4 id="1-硬件PWM（基于定时器）"><a href="#1-硬件PWM（基于定时器）" class="headerlink" title="(1) 硬件PWM（基于定时器）"></a><strong>(1) 硬件PWM（基于定时器）</strong></h4><ul><li><strong>核心组件</strong>：<ul><li><strong>计数器</strong>：递增或递减计数，产生周期性基准。</li><li><strong>比较寄存器（CCR）</strong>：设置占空比阈值。</li><li><strong>自动重载寄存器（ARR）</strong>：设置周期长度。</li></ul></li><li><strong>工作流程</strong>：<ol><li>计数器从0开始递增，达到CCR值时输出电平翻转。</li><li>计数器达到ARR值时复位，并触发更新事件，开始新周期。</li></ol></li><li><strong>频率计算</strong>：</li></ul><p>频率定时器时钟源频率预分频系数值</p><ul><li><strong>占空比计算</strong>：</li></ul><p>占空比值值</p><ul><li><p>配置示例（STM32定时器）：</p>  <C>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TIM_HandleTypeDef</span> htim;<br><span class="hljs-attribute">htim</span>.Instance = TIM1;<br><span class="hljs-attribute">htim</span>.Init.Prescaler = <span class="hljs-number">79</span>;           // 预分频系数<span class="hljs-number">80</span>（<span class="hljs-number">80</span>MHz/<span class="hljs-number">80</span>=<span class="hljs-number">1</span>MHz）<br><span class="hljs-attribute">htim</span>.Init.CounterMode = TIM_COUNTERMODE_UP;<br><span class="hljs-attribute">htim</span>.Init.Period = <span class="hljs-number">999</span>;             // ARR=<span class="hljs-number">999</span> → 频率=<span class="hljs-number">1</span>MHz/(<span class="hljs-number">999</span>+<span class="hljs-number">1</span>)=<span class="hljs-number">1</span>kHz<br><span class="hljs-attribute">htim</span>.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;<br><span class="hljs-attribute">HAL_TIM_PWM_Init</span>(&amp;htim);<br><br><span class="hljs-attribute">TIM_OC_InitTypeDef</span> sConfigOC;<br><span class="hljs-attribute">sConfigOC</span>.OCMode = TIM_OCMODE_PWM1;<br><span class="hljs-attribute">sConfigOC</span>.Pulse = <span class="hljs-number">500</span>;              // CCR=<span class="hljs-number">500</span> → 占空比<span class="hljs-number">50</span>%<br><span class="hljs-attribute">sConfigOC</span>.OCPolarity = TIM_OCPOLARITY_HIGH;<br><span class="hljs-attribute">HAL_TIM_PWM_ConfigChannel</span>(&amp;htim, &amp;sConfigOC, TIM_CHANNEL_1);<br><span class="hljs-attribute">HAL_TIM_PWM_Start</span>(&amp;htim, TIM_CHANNEL_1);<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-软件PWM（GPIO模拟）"><a href="#2-软件PWM（GPIO模拟）" class="headerlink" title="(2) 软件PWM（GPIO模拟）"></a><strong>(2) 软件PWM（GPIO模拟）</strong></h4><ul><li><p><strong>实现方式</strong>：<br>   使用定时器中断或延时函数，手动控制GPIO电平翻转。</p></li><li><p><strong>代码示例（Arduino）</strong>：</p>  <CPP>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">setup</span>() &#123;<br>  <span class="hljs-built_in">pinMode</span>(<span class="hljs-number">9</span>, OUTPUT);<br>&#125;<br><br>void <span class="hljs-built_in">loop</span>() &#123;<br>  <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">9</span>, HIGH);<br>  <span class="hljs-built_in">delayMicroseconds</span>(<span class="hljs-number">200</span>);  <span class="hljs-comment">// 高电平时间200μs</span><br>  <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">9</span>, LOW);<br>  <span class="hljs-built_in">delayMicroseconds</span>(<span class="hljs-number">800</span>);  <span class="hljs-comment">// 低电平时间800μs → 周期1ms，占空比20%</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>局限性</strong>：</p><ul><li>精度低（受中断延迟和代码执行时间影响）。</li><li>占用CPU资源，难以生成高频PWM（通常&lt;10kHz）。</li></ul></li></ul><hr><h3 id="3-PWM模式类型"><a href="#3-PWM模式类型" class="headerlink" title="3. PWM模式类型"></a><strong>3. PWM模式类型</strong></h3><table><thead><tr><th><strong>模式</strong></th><th><strong>描述</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>边沿对齐</strong></td><td>计数器单向递增或递减，脉冲边沿对齐周期边界</td><td>通用控制（如LED调光）</td></tr><tr><td><strong>中心对齐</strong></td><td>计数器先递增后递减，脉冲中心对齐周期边界</td><td>电机驱动（减少谐波噪声）</td></tr><tr><td><strong>互补输出</strong></td><td>主通道与互补通道输出反相PWM，插入死区时间防止短路</td><td>H桥电机驱动</td></tr><tr><td><strong>多通道同步</strong></td><td>多个PWM通道共享ARR，相位可调</td><td>RGB LED颜色混合</td></tr></tbody></table><hr><h3 id="4-关键电路设计"><a href="#4-关键电路设计" class="headerlink" title="4. 关键电路设计"></a><strong>4. 关键电路设计</strong></h3><h4 id="1-驱动能力增强"><a href="#1-驱动能力增强" class="headerlink" title="(1) 驱动能力增强"></a><strong>(1) 驱动能力增强</strong></h4><ul><li><strong>MOSFET&#x2F;晶体管驱动</strong>：<br>   PWM信号通过MOSFET（如IRF540N）或驱动芯片（如L298N）放大电流，驱动电机或大功率负载。</li><li><strong>RC滤波转换模拟信号</strong>：<br>   对PWM输出进行低通滤波，得到平滑的模拟电压：</li></ul><p>占空比</p><ul><li>滤波器截止频率：，需远低于PWM频率。</li></ul><h4 id="2-死区时间（Dead-Time）"><a href="#2-死区时间（Dead-Time）" class="headerlink" title="(2) 死区时间（Dead Time）"></a><strong>(2) 死区时间（Dead Time）</strong></h4><ul><li><p><strong>作用</strong>：防止H桥上下管同时导通造成短路。</p></li><li><p><strong>实现</strong>：在互补PWM的上升沿和下降沿之间插入延迟（通常50ns~1μs）。</p></li><li><p>STM32配置示例：</p>  <C>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts">TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeC<span class="hljs-attr">onfig</span><span class="hljs-punctuation">;</span><br>sBreakDeadTimeConfig.DeadT<span class="hljs-attr">ime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x80</span><span class="hljs-punctuation">;</span>  <span class="hljs-comment">// 死区时间=0x80*T_dts</span><br>HAL_TIMEx_ConfigBreakDeadTime(<span class="hljs-variable">&amp;htim</span>, <span class="hljs-variable">&amp;</span>sBreakDeadTimeConfig)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="5-高级应用技巧"><a href="#5-高级应用技巧" class="headerlink" title="5. 高级应用技巧"></a><strong>5. 高级应用技巧</strong></h3><h4 id="1-提高分辨率"><a href="#1-提高分辨率" class="headerlink" title="(1) 提高分辨率"></a><strong>(1) 提高分辨率</strong></h4><ul><li><strong>时钟预分频优化</strong>：<br>   降低定时器时钟频率（增大预分频系数），以增加ARR值，但会降低PWM频率。</li><li><strong>微步进PWM</strong>：<br>   结合多个PWM相位差，合成更高分辨率信号（如两路90°相位差PWM叠加）。</li></ul><h4 id="2-动态调整PWM"><a href="#2-动态调整PWM" class="headerlink" title="(2) 动态调整PWM"></a><strong>(2) 动态调整PWM</strong></h4><ul><li><p>呼吸灯效果：</p><p>  线性或非线性改变CCR值，实现亮度渐变。</p>  <C>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">for (int i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000</span>; i++) &#123;<br>  <span class="hljs-built_in">__HAL_TIM_SET_COMPARE</span>(&amp;htim, TIM_CHANNEL_1, i);<br>  <span class="hljs-built_in">HAL_Delay</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-多设备同步"><a href="#3-多设备同步" class="headerlink" title="(3) 多设备同步"></a><strong>(3) 多设备同步</strong></h4><ul><li>使用主从定时器模式，确保多个PWM信号相位一致。</li></ul><hr><h3 id="6-常见问题与解决"><a href="#6-常见问题与解决" class="headerlink" title="6. 常见问题与解决"></a><strong>6. 常见问题与解决</strong></h3><h4 id="Q1：PWM输出有毛刺？"><a href="#Q1：PWM输出有毛刺？" class="headerlink" title="Q1：PWM输出有毛刺？"></a><strong>Q1：PWM输出有毛刺？</strong></h4><ul><li><strong>原因</strong>：GPIO切换速度过快或负载电感产生尖峰。</li><li><strong>解决</strong>：增加RC滤波、使用肖特基二极管续流。</li></ul><h4 id="Q2：如何测量PWM参数？"><a href="#Q2：如何测量PWM参数？" class="headerlink" title="Q2：如何测量PWM参数？"></a><strong>Q2：如何测量PWM参数？</strong></h4><ul><li>使用示波器直接观测波形，或通过输入捕获模式测量频率&#x2F;占空比。</li></ul><h4 id="Q3：高精度PWM如何实现？"><a href="#Q3：高精度PWM如何实现？" class="headerlink" title="Q3：高精度PWM如何实现？"></a><strong>Q3：高精度PWM如何实现？</strong></h4><ul><li>选择高位定时器（如32位ARR）、降低时钟分频，或使用专用PWM芯片（如LT6992）。</li></ul><hr><p>通过合理配置定时器和外围电路，PWM可实现从简单控制到高精度驱动的广泛应用。硬件PWM效率高且稳定，而软件PWM适用于资源受限的场景。</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADC/DAC精度校准</title>
    <link href="/2025/02/11/adc/dac_accuracy_calibration/"/>
    <url>/2025/02/11/adc/dac_accuracy_calibration/</url>
    
    <content type="html"><![CDATA[<!-- gpio_configuration --><span id="more"></span><p>ADC（模数转换器）和DAC（数模转换器）的精度校准是确保信号转换准确性的关键步骤</p><h3 id="1-误差来源分析"><a href="#1-误差来源分析" class="headerlink" title="1. 误差来源分析"></a><strong>1. 误差来源分析</strong></h3><h4 id="1-ADC主要误差类型"><a href="#1-ADC主要误差类型" class="headerlink" title="(1) ADC主要误差类型"></a><strong>(1) ADC主要误差类型</strong></h4><ul><li><strong>偏移误差（Offset Error）</strong>：实际转换曲线与理想曲线的垂直偏移（零点偏差）。</li><li><strong>增益误差（Gain Error）</strong>：实际转换曲线斜率与理想值的偏差（满量程偏差）。</li><li><strong>积分非线性（INL）</strong>：实际转换点与理想直线的最大偏差（非线性误差）。</li><li><strong>微分非线性（DNL）</strong>：相邻码值之间的实际步长与理想步长的偏差。</li><li><strong>噪声与温漂</strong>：热噪声、电源波动、温度变化引起的误差。</li></ul><h4 id="2-DAC主要误差类型"><a href="#2-DAC主要误差类型" class="headerlink" title="(2) DAC主要误差类型"></a><strong>(2) DAC主要误差类型</strong></h4><ul><li>类似ADC，包括偏移、增益、非线性误差，但方向相反（数字到模拟）。</li></ul><hr><h3 id="2-ADC校准方法"><a href="#2-ADC校准方法" class="headerlink" title="2. ADC校准方法"></a><strong>2. ADC校准方法</strong></h3><h4 id="1-硬件校准（适用于12位-16位）"><a href="#1-硬件校准（适用于12位-16位）" class="headerlink" title="(1) 硬件校准（适用于12位&#x2F;16位）"></a><strong>(1) 硬件校准（适用于12位&#x2F;16位）</strong></h4><ul><li><p><strong>偏移校准</strong>：</p><ul><li><p>步骤：</p><ol><li>输入已知的零电平（如短接AIN到GND）。</li><li>读取ADC输出码值（应为0，实际可能为N_offset）。</li><li>软件补偿：后续采样值减去N_offset。</li></ol></li><li><p>实现：</p>  <C>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int16_t raw_value <span class="hljs-operator">=</span> ADC_Read()<span class="hljs-comment">;</span><br>int16_t calibrated_value <span class="hljs-operator">=</span> raw_value - offset<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>增益校准</strong>：</p><ul><li><p>步骤：</p><ol><li>输入满量程参考电压（如VREF）。</li><li>读取ADC输出码值（理想为最大值，如4095对应12位）。</li><li>计算增益误差系数：<br> <code>gain = (理论最大值) / (实际测量值)</code></li><li>软件补偿：采样值乘以增益系数。</li></ol></li><li><p>实现：</p>  <C>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">float gain <span class="hljs-operator">=</span> <span class="hljs-number">4095.0</span> / measured_max_value<span class="hljs-comment">;</span><br>int16_t calibrated_value <span class="hljs-operator">=</span> raw_value * gain<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>多点校准（提升INL精度）</strong>：</p><ul><li>步骤：<ol><li>使用精密电压源输入多个已知电压点（如10%VREF, 50%VREF, 90%VREF）。</li><li>记录实际ADC码值与理论值的偏差。</li><li>构建查找表（LUT）或拟合多项式曲线，实时补偿非线性误差。</li></ol></li><li><strong>适用场景</strong>：16位高精度系统，需补偿非线性误差。</li></ul></li></ul><h4 id="2-自动校准（芯片内置功能）"><a href="#2-自动校准（芯片内置功能）" class="headerlink" title="(2) 自动校准（芯片内置功能）"></a><strong>(2) 自动校准（芯片内置功能）</strong></h4><ul><li><p>示例</p><p>  ：STM32的ADC自校准模式</p><ul><li><p>触发内部校准流程，自动计算偏移校正值并存入寄存器。</p></li><li><p>代码示例：</p>  <C>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">HAL_ADCEx_Calibration_Start</span>(&amp;hadc); <span class="hljs-comment">// 启动自校准</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-外部参考源校准"><a href="#3-外部参考源校准" class="headerlink" title="(3) 外部参考源校准"></a><strong>(3) 外部参考源校准</strong></h4><ul><li>使用高精度外部电压基准（如ADR4550）替代内部VREF，减少基准源误差。</li></ul><hr><h3 id="3-DAC校准方法"><a href="#3-DAC校准方法" class="headerlink" title="3. DAC校准方法"></a><strong>3. DAC校准方法</strong></h3><h4 id="1-偏移校准"><a href="#1-偏移校准" class="headerlink" title="(1) 偏移校准"></a><strong>(1) 偏移校准</strong></h4><ul><li>步骤：<ol><li>设置DAC输出数字码为0，测量实际输出电压V_off。</li><li>软件补偿：输出码值动态调整为<code>DAC_code = target_code + (V_off / LSB)</code>。</li></ol></li></ul><h4 id="2-增益校准"><a href="#2-增益校准" class="headerlink" title="(2) 增益校准"></a><strong>(2) 增益校准</strong></h4><ul><li>步骤：<ol><li>设置DAC输出最大码值（如65535对应16位），测量实际电压V_full。</li><li>计算增益误差系数：<br> <code>gain = V_full / (理论满量程电压)</code></li><li>软件补偿：输出码值乘以增益系数。</li></ol></li></ul><h4 id="3-分段线性校准"><a href="#3-分段线性校准" class="headerlink" title="(3) 分段线性校准"></a><strong>(3) 分段线性校准</strong></h4><ul><li>对DAC输出范围分段，每段单独校准偏移和增益，适用于高分辨率（16位）系统。</li></ul><hr><h3 id="4-校准实现注意事项"><a href="#4-校准实现注意事项" class="headerlink" title="4. 校准实现注意事项"></a><strong>4. 校准实现注意事项</strong></h3><h4 id="1-12位-vs-16位系统差异"><a href="#1-12位-vs-16位系统差异" class="headerlink" title="(1) 12位 vs. 16位系统差异"></a><strong>(1) 12位 vs. 16位系统差异</strong></h4><table><thead><tr><th><strong>参数</strong></th><th><strong>12位 ADC&#x2F;DAC</strong></th><th><strong>16位 ADC&#x2F;DAC</strong></th></tr></thead><tbody><tr><td><strong>LSB精度</strong></td><td>1 LSB &#x3D; VREF&#x2F;4096</td><td>1 LSB &#x3D; VREF&#x2F;65536</td></tr><tr><td><strong>校准精度要求</strong></td><td>±2 LSB以内</td><td>±1 LSB以内</td></tr><tr><td><strong>校准点数量</strong></td><td>2点（偏移+增益）通常足够</td><td>需多点校准（如5-10点）</td></tr><tr><td><strong>噪声影响</strong></td><td>较小（LSB较大）</td><td>显著（需低噪声PCB布局和滤波）</td></tr></tbody></table><h4 id="2-校准设备要求"><a href="#2-校准设备要求" class="headerlink" title="(2) 校准设备要求"></a><strong>(2) 校准设备要求</strong></h4><ul><li><strong>电压源</strong>：精度至少比目标系统高4倍（如校准16位需20位精度的源表）。</li><li><strong>测量仪器</strong>：使用高精度万用表（如6½位）或校准ADC。</li></ul><h4 id="3-温度补偿"><a href="#3-温度补偿" class="headerlink" title="(3) 温度补偿"></a><strong>(3) 温度补偿</strong></h4><ul><li><p>在宽温范围内工作的系统需存储不同温度下的校准系数（EEPROM存储）。</p></li><li><p>公式示例：</p>  <C>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">calibrated_value</span> = raw_value * gain_table[temp] + <span class="hljs-literal">off</span>set_table[temp]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="5-校准流程示例（以16位ADC为例）"><a href="#5-校准流程示例（以16位ADC为例）" class="headerlink" title="5. 校准流程示例（以16位ADC为例）"></a><strong>5. 校准流程示例（以16位ADC为例）</strong></h3><ol><li><strong>预热系统</strong>：上电稳定30分钟，减少温漂影响。</li><li>偏移校准：<ul><li>输入0V，读取100次取平均，得到N_offset。</li></ul></li><li>增益校准：<ul><li>输入VREF-1LSB（避免饱和），读取N_full，计算增益系数。</li></ul></li><li>多点INL校准：<ul><li>输入10个均匀分布的电压点，构建LUT或二次多项式拟合。</li></ul></li><li><strong>存储系数</strong>：将offset、gain和LUT存入非易失存储器。</li></ol><hr><h3 id="6-代码实现片段（STM32-HAL库示例）"><a href="#6-代码实现片段（STM32-HAL库示例）" class="headerlink" title="6. 代码实现片段（STM32 HAL库示例）"></a><strong>6. 代码实现片段（STM32 HAL库示例）</strong></h3><C><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ADC偏移校准</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ADC_Calibrate</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">HAL_ADCEx_Calibration_Start</span>(&amp;hadc1); <span class="hljs-comment">// 内置校准</span><br>  <span class="hljs-type">uint32_t</span> offset = hadc1.Instance-&gt;CALFACT; <span class="hljs-comment">// 获取校准因子</span><br>&#125;<br><br><span class="hljs-comment">// DAC增益补偿</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DAC_SetVoltage</span><span class="hljs-params">(<span class="hljs-type">float</span> voltage)</span> </span>&#123;<br>  <span class="hljs-type">float</span> lsb = VREF / <span class="hljs-number">65536.0</span>;<br>  <span class="hljs-type">uint16_t</span> code = (voltage / lsb) * gain_factor + offset;<br>  <span class="hljs-built_in">HAL_DAC_SetValue</span>(&amp;hdac1, DAC_CHANNEL_1, DAC_ALIGN_12B_R, code);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="7-高精度设计技巧"><a href="#7-高精度设计技巧" class="headerlink" title="7. 高精度设计技巧"></a><strong>7. 高精度设计技巧</strong></h3><ul><li>PCB布局：<ul><li>分离模拟&#x2F;数字地，使用星型接地。</li><li>缩短模拟信号走线，避免平行数字信号线。</li></ul></li><li>参考源选择：<ul><li>使用低温漂参考电压（如MAX6126，温漂3ppm&#x2F;℃）。</li></ul></li><li>软件滤波：<ul><li>多次采样取平均（16位系统建议64次以上）。</li><li>中值滤波消除脉冲噪声。</li></ul></li></ul><hr><p>通过系统级校准（硬件+软件）和严格的环境控制，12位系统可达到±1 LSB精度，16位系统可控制在±2 LSB以内。</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ADC/DAC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPIO配置（推挽/开漏输出，上拉/下拉）</title>
    <link href="/2025/02/11/gpio_configuration/"/>
    <url>/2025/02/11/gpio_configuration/</url>
    
    <content type="html"><![CDATA[<!-- gpio_configuration --><span id="more"></span><h3 id="1-GPIO输出模式"><a href="#1-GPIO输出模式" class="headerlink" title="1. GPIO输出模式"></a><strong>1. GPIO输出模式</strong></h3><h4 id="1-推挽输出（Push-Pull）"><a href="#1-推挽输出（Push-Pull）" class="headerlink" title="(1) 推挽输出（Push-Pull）"></a><strong>(1) 推挽输出（Push-Pull）</strong></h4><ul><li><p><strong>工作原理</strong>：</p><ul><li>使用一对互补的MOS管（PMOS和NMOS）构成输出级。</li><li><strong>输出高电平</strong>：PMOS导通，NMOS截止，引脚直接连接到VCC。</li><li><strong>输出低电平</strong>：NMOS导通，PMOS截止，引脚连接到GND。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>驱动能力强</strong>：可主动输出高&#x2F;低电平，电流能力高（如20mA）。</li><li><strong>电平稳定</strong>：无外部电阻时也能保持明确的高&#x2F;低电平。</li><li><strong>无外部上拉</strong>：无需外接上拉电阻。</li></ul></li><li><p><strong>应用场景</strong>：</p><ul><li>LED控制、数字信号输出（如SPI时钟线）、高速信号传输。</li></ul></li><li><p><strong>示意图</strong>：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">VCC  <br> <span class="hljs-string">|  </span><br>PMOS  <br> <span class="hljs-string">|---- GPIO引脚  </span><br>NMOS  <br> <span class="hljs-string">|  </span><br>GND  <br></code></pre></td></tr></table></figure></li></ul><h4 id="2-开漏输出（Open-Drain，或开集输出Open-Collector）"><a href="#2-开漏输出（Open-Drain，或开集输出Open-Collector）" class="headerlink" title="(2) 开漏输出（Open-Drain，或开集输出Open-Collector）"></a><strong>(2) 开漏输出（Open-Drain，或开集输出Open-Collector）</strong></h4><ul><li><p><strong>工作原理</strong>：</p><ul><li>仅使用NMOS管（或NPN三极管），无PMOS。</li><li><strong>输出低电平</strong>：NMOS导通，引脚接地。</li><li><strong>输出高电平</strong>：NMOS截止，引脚处于高阻态（需外接上拉电阻拉高）。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>电平依赖外部</strong>：高电平由外部上拉电阻提供，电压可高于芯片电源（如5V上拉，芯片为3.3V）。</li><li><strong>支持总线共享</strong>：多个开漏设备可并联（如I2C总线），避免电平冲突。</li><li><strong>驱动能力弱</strong>：高电平驱动依赖外部电阻，电流能力低。</li></ul></li><li><p><strong>应用场景</strong>：</p><ul><li>I2C&#x2F;SMBus总线、电平转换、多设备总线通信。</li></ul></li><li><p><strong>示意图</strong>：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">VCC (外部电源)  <br> <span class="hljs-string">|  </span><br>Resistor (上拉)  <br> <span class="hljs-string">|  </span><br>GPIO引脚----NMOS  <br>           <span class="hljs-string">|  </span><br>          GND  <br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="2-上拉（Pull-Up）与下拉（Pull-Down）"><a href="#2-上拉（Pull-Up）与下拉（Pull-Down）" class="headerlink" title="2. 上拉（Pull-Up）与下拉（Pull-Down）"></a><strong>2. 上拉（Pull-Up）与下拉（Pull-Down）</strong></h3><h4 id="1-上拉电阻"><a href="#1-上拉电阻" class="headerlink" title="(1) 上拉电阻"></a><strong>(1) 上拉电阻</strong></h4><ul><li><strong>作用</strong>：<ul><li>在引脚悬空（高阻态）时，通过电阻连接到VCC，将电平拉高至稳定状态。</li><li>防止输入引脚因浮空产生随机电平（噪声干扰）。</li></ul></li><li><strong>配置场景</strong>：<ul><li><strong>输入模式</strong>：按键检测（按键接地，按下时拉低）。</li><li><strong>开漏输出</strong>：提供高电平驱动（如I2C的SDA&#x2F;SCL）。</li></ul></li><li><strong>典型阻值</strong>：<ul><li>1kΩ~10kΩ（阻值越小，抗干扰能力越强，但功耗越高）。</li></ul></li></ul><h4 id="2-下拉电阻"><a href="#2-下拉电阻" class="headerlink" title="(2) 下拉电阻"></a><strong>(2) 下拉电阻</strong></h4><ul><li><strong>作用</strong>：<ul><li>在引脚悬空时，通过电阻连接到GND，将电平拉低至稳定状态。</li></ul></li><li><strong>配置场景</strong>：<ul><li><strong>输入模式</strong>：防止未连接信号源时误触发高电平。</li></ul></li><li><strong>典型阻值</strong>：<ul><li>同上拉电阻（1kΩ~10kΩ）。</li></ul></li></ul><h4 id="3-上下拉配置方式"><a href="#3-上下拉配置方式" class="headerlink" title="(3) 上下拉配置方式"></a><strong>(3) 上下拉配置方式</strong></h4><ul><li><strong>内部上下拉</strong>：<ul><li>微控制器（如STM32）的GPIO模块内置可编程上拉&#x2F;下拉电阻，通过寄存器配置。</li><li>例：STM32的<code>GPIO_PULLUP</code>或<code>GPIO_PULLDOWN</code>模式。</li></ul></li><li><strong>外部上下拉</strong>：<ul><li>在PCB上添加物理电阻，适用于无内部上下拉或需要特定阻值的场景。</li></ul></li></ul><hr><h3 id="3-输入模式与上下拉"><a href="#3-输入模式与上下拉" class="headerlink" title="3. 输入模式与上下拉"></a><strong>3. 输入模式与上下拉</strong></h3><ul><li><strong>浮空输入（Floating）</strong>：<ul><li>无上下拉电阻，引脚电平由外部电路决定。</li><li>风险：悬空时易受噪声干扰，导致逻辑错误。</li></ul></li><li><strong>上拉&#x2F;下拉输入</strong>：<ul><li>启用内部或外部电阻，确保引脚在无外部驱动时有确定电平。</li><li>例：按键连接到GPIO，启用内部上拉，按键未按下时输入为高电平，按下时接地拉低。</li></ul></li></ul><hr><h3 id="4-配置选择指南"><a href="#4-配置选择指南" class="headerlink" title="4. 配置选择指南"></a><strong>4. 配置选择指南</strong></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>输出模式</strong></th><th><strong>上下拉</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>LED控制</td><td>推挽输出</td><td>无</td><td>直接驱动LED，无需外部电阻</td></tr><tr><td>I2C总线</td><td>开漏输出</td><td>外部上拉（4.7kΩ）</td><td>支持多设备共享总线</td></tr><tr><td>按键检测</td><td>输入模式</td><td>内部上拉</td><td>按键按下时拉低引脚电平</td></tr><tr><td>电平转换（3.3V↔5V）</td><td>开漏输出</td><td>外部上拉到目标电压</td><td>允许高压侧设备读取低压侧信号</td></tr><tr><td>高速信号（如SPI）</td><td>推挽输出</td><td>无</td><td>确保快速上升&#x2F;下降沿，减少信号延迟</td></tr></tbody></table><hr><h3 id="5-常见问题"><a href="#5-常见问题" class="headerlink" title="5. 常见问题"></a><strong>5. 常见问题</strong></h3><h4 id="Q1：推挽输出能否直接连接两个设备？"><a href="#Q1：推挽输出能否直接连接两个设备？" class="headerlink" title="Q1：推挽输出能否直接连接两个设备？"></a><strong>Q1：推挽输出能否直接连接两个设备？</strong></h4><ul><li>不推荐。推挽输出可能因设备同时驱动导致短路，应使用开漏输出配合上拉电阻。</li></ul><h4 id="Q2：开漏输出为何需要上拉电阻？"><a href="#Q2：开漏输出为何需要上拉电阻？" class="headerlink" title="Q2：开漏输出为何需要上拉电阻？"></a><strong>Q2：开漏输出为何需要上拉电阻？</strong></h4><ul><li>开漏输出只能主动拉低电平，高电平需依赖外部上拉电阻提供电流路径。</li></ul><h4 id="Q3：上下拉电阻阻值如何选择？"><a href="#Q3：上下拉电阻阻值如何选择？" class="headerlink" title="Q3：上下拉电阻阻值如何选择？"></a><strong>Q3：上下拉电阻阻值如何选择？</strong></h4><ul><li>阻值越小，驱动能力越强，但功耗越高；阻值过大可能导致上升沿变缓。通常根据总线电容和速度需求计算（如I2C常用4.7kΩ）。</li></ul><hr><p>通过合理配置GPIO模式和上下拉，可优化电路性能、降低功耗并提高可靠性。</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈佛架构与冯诺依曼架构差异</title>
    <link href="/2025/02/11/differences_between_architecture/"/>
    <url>/2025/02/11/differences_between_architecture/</url>
    
    <content type="html"><![CDATA[<!-- differences_between_architecture --><span id="more"></span><p>哈佛架构与冯诺依曼架构是计算机体系结构的两种经典设计模式，其核心差异在于 <strong>存储器组织方式</strong> 和 <strong>数据&#x2F;指令访问机制</strong>。</p><h3 id="1-冯诺依曼架构（Von-Neumann-Architecture）"><a href="#1-冯诺依曼架构（Von-Neumann-Architecture）" class="headerlink" title="1. 冯诺依曼架构（Von Neumann Architecture）"></a><strong>1. 冯诺依曼架构（Von Neumann Architecture）</strong></h3><ul><li><strong>核心特征</strong>：<ul><li><strong>统一存储器</strong>：程序指令（代码）和数据存储在同一个物理内存空间中，共享同一总线。</li><li><strong>顺序执行</strong>：CPU 按顺序从内存中逐条读取指令并执行，通过同一总线传输指令和数据。</li></ul></li><li><strong>优点</strong>：<ul><li>硬件设计简单，成本较低。</li><li>灵活性高，程序可动态修改（如自修改代码）。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>冯诺依曼瓶颈</strong>：指令和数据共享总线，导致无法同时读写指令和数据，可能限制性能。</li><li>安全性风险：代码和数据未隔离，易受恶意代码篡改。</li></ul></li><li><strong>典型应用</strong>：<br>   通用计算机（如个人电脑、服务器）和早期处理器。</li></ul><hr><h3 id="2-哈佛架构（Harvard-Architecture）"><a href="#2-哈佛架构（Harvard-Architecture）" class="headerlink" title="2. 哈佛架构（Harvard Architecture）"></a><strong>2. 哈佛架构（Harvard Architecture）</strong></h3><ul><li><strong>核心特征</strong>：<ul><li><strong>分离存储器</strong>：程序指令和数据存储在不同的物理内存中，通过独立总线访问。</li><li><strong>并行访问</strong>：CPU 可同时读取指令和读写数据，减少总线竞争。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>高性能</strong>：指令和数据并行传输，提升执行效率。</li><li><strong>安全性高</strong>：指令存储器只读或受保护，防止代码被意外修改。</li><li>适合实时处理：满足确定性时序要求（如信号处理）。</li></ul></li><li><strong>缺点</strong>：<ul><li>硬件复杂度高，成本更高。</li><li>程序无法动态修改自身代码（指令存储器通常只读）。</li></ul></li><li><strong>典型应用</strong>：<br>   嵌入式系统（如单片机）、DSP（数字信号处理器）、FPGA 设计。</li></ul><hr><h3 id="3-关键差异对比"><a href="#3-关键差异对比" class="headerlink" title="3. 关键差异对比"></a><strong>3. 关键差异对比</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>冯诺依曼架构</strong></th><th><strong>哈佛架构</strong></th></tr></thead><tbody><tr><td><strong>存储器结构</strong></td><td>统一存储指令和数据</td><td>指令和数据分离存储</td></tr><tr><td><strong>总线数量</strong></td><td>单总线（共享）</td><td>双总线（指令和数据独立）</td></tr><tr><td><strong>并行访问能力</strong></td><td>无法同时读写指令和数据</td><td>可同时访问指令和数据</td></tr><tr><td><strong>硬件复杂度</strong></td><td>简单</td><td>复杂</td></tr><tr><td><strong>典型场景</strong></td><td>通用计算</td><td>实时系统、嵌入式设备</td></tr><tr><td><strong>自修改代码支持</strong></td><td>支持</td><td>通常不支持</td></tr></tbody></table><hr><h3 id="4-现代架构的融合"><a href="#4-现代架构的融合" class="headerlink" title="4. 现代架构的融合"></a><strong>4. 现代架构的融合</strong></h3><ul><li><strong>改进型哈佛架构</strong>：<br>   大多数现代处理器（如 x86、ARM）在底层采用冯诺依曼的统一内存，但通过 <strong>缓存分层</strong>（指令缓存 L1-I 和数据缓存 L1-D 分离）实现类似哈佛架构的并行访问，称为“改进型哈佛架构”。<ul><li><strong>外部表现</strong>：程序和数据共享主存（冯诺依曼特性）。</li><li><strong>内部优化</strong>：CPU 缓存区分指令和数据（哈佛特性），提升性能。</li></ul></li><li><strong>嵌入式系统的严格哈佛架构</strong>：<br>   某些单片机（如 8051、PIC）仍严格分离指令 Flash 和数据 RAM，以确保实时性和安全性。</li></ul><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><ul><li>选择依据：<ul><li>冯诺依曼：适合通用计算，强调灵活性和低成本。</li><li>哈佛架构：适合实时性、安全性要求高的场景（如物联网设备、汽车电子）。</li></ul></li><li><strong>趋势</strong>：现代处理器通过混合设计兼顾两者优势，但底层原理仍是理解计算机体系结构的基础。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_复习</title>
    <link href="/2025/02/09/embedded_2/"/>
    <url>/2025/02/09/embedded_2/</url>
    
    <content type="html"><![CDATA[<!-- embedded_2--><span id="more"></span><h3 id="函数指针与指针函数"><a href="#函数指针与指针函数" class="headerlink" title="函数指针与指针函数"></a>函数指针与指针函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span>* <span class="hljs-title function_">aaaaa</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">// 返回指针的函数就是指针函数</span><br>&#123;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> (*ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = &amp;add; <span class="hljs-comment">// 取函数的指针就是函数指针</span><br><br>    <span class="hljs-type">int</span> c = ptr(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="指针大小"><a href="#指针大小" class="headerlink" title="指针大小"></a>指针大小</h4><p>指针大小与操作系统的位数有关，32位指针大小是4个字节，64位指针大小是8个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span>* a;<br>    <span class="hljs-type">int</span>* b;<br>    <span class="hljs-type">float</span>* c;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %d, %d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(a), <span class="hljs-keyword">sizeof</span>(b), <span class="hljs-keyword">sizeof</span>(c)); <span class="hljs-comment">// 8, 8, 8</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sizeof与strlen的区别"><a href="#sizeof与strlen的区别" class="headerlink" title="sizeof与strlen的区别"></a>sizeof与strlen的区别</h3><ul><li>sizeof是一个运算符，strlen是一个函数，需要包含string.h头文件</li><li>sizeof计算的是所占内存的大小，strlen计算的是字符串的长度。字符串以\0结尾，\0是不需要计算长度的</li><li>sizeof可以计算其他类型int,float等，strlen一般用于字符串的长度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;\0&quot;</span>), <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;\0&quot;</span>)); <span class="hljs-comment">// 2, 0 因为sizeof里面的是字符串以\0结尾,所以有2个0，2个字符，所有是2个字节</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C语言内存分配方式"><a href="#C语言内存分配方式" class="headerlink" title="C语言内存分配方式"></a>C语言内存分配方式</h3><ul><li>静态存储器分配，例如全局变量，静态变量。</li><li>栈上分配，函数中定义的局部变量</li><li>堆上分配，malloc, new</li></ul><h3 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h3><ul><li>数组指针指的是指向数组的指针，本质是一个指针</li><li>指针数组本质是一个数组，里面的每个元素都是指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span>(*p)[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 数组指针的申明</span><br><br>    <span class="hljs-type">int</span> *a, a1, a2;<br>    <span class="hljs-type">int</span>* p1[<span class="hljs-number">10</span>] = &#123; a, a1, a2 &#125;; <span class="hljs-comment">// 指针数组</span><br><br>    <span class="hljs-comment">// printf(&quot;%d, %d, %d\n&quot;, sizeof(a), sizeof(b), sizeof(c));</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="struct结构体和union联合体"><a href="#struct结构体和union联合体" class="headerlink" title="struct结构体和union联合体"></a>struct结构体和union联合体</h3><ul><li>union共享一块内存地址，大小 &#x3D; 成员中占内存最大的成员的大小</li><li>结构体不同成员放在不同的内存地址。大小 &#x3D; 所有成员大小之和（字节对齐）</li></ul><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>​野指针是指向不可用内存的指针</p><p>​当指针被创建的时候，没有赋值这个时候指针就成为了野指针</p><p>​当指针被free或者delete后如果没有把指针赋值为NULL，这个时候也是野指针</p><p>​当指针越界的时候也是野指针</p><h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><ul><li>数组的地址空间是连续的</li><li>链表的地址空间是不连续的</li><li>数组的访问速度比较快，数组直接通过下标就能访问，链表需要遍历</li><li>链表增删改的速度比较快</li></ul><h3 id="define与typedef的区别"><a href="#define与typedef的区别" class="headerlink" title="define与typedef的区别"></a>define与typedef的区别</h3><p>​define是一个预处理指令，typedef是关键字</p><p>​define不会做正确性检查，直接进行替换，typedef会做正确性检查</p><p>​define没有作用域的限制，typedef有作用域的限制</p><h3 id="Static的作用"><a href="#Static的作用" class="headerlink" title="Static的作用"></a>Static的作用</h3><p>​定义一个静态变量或者静态函数</p><p>​在函数中定义变量，变量只会初始化一次</p><p>​定义的静态变量或者函数只能在当前文件中使用，作用域的限制</p><p>​在函数内部定义的静态变量无法被其他函数使用</p><p>​</p><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>​内存泄露指的是在程序运行的时候,动态分配的空间没有被回收或者正常释放，导致这个内存空间还占据着系统资源</p><h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>​内存对齐是在储存数据时，将数据按照一定的规则放置在内存中的过程</p><h3 id="数组名和指针的区别"><a href="#数组名和指针的区别" class="headerlink" title="数组名和指针的区别"></a>数组名和指针的区别</h3><p>​数组名就是数组首元素的地址，也可以看做一个常量指针，这个是不能修改指向的</p><p>​使用指针访问数组的时候需要使用到解引用*，使用指针访问数组是间接访问，使用数组名访问数组是直接访问</p><p>​使用sizeof对指针和数组名进行计算的时候是不同的，指针的大小和编译器的位数有关，sizeof数组名是整个数组的大小</p><h3 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h3><p>​常量指针是指向一个常量的指针，这个指针无法修改所指向的数据，但是可以修改指向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;a;<br>    p = &amp;b; <span class="hljs-comment">// 可以修改指向</span><br>    <span class="hljs-comment">// *p = 6; // 常量指针无法修改指向的数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​指针常量是指针是一个常量，指针所指向的地址是固定的 ，但是可以修改地址中的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p1 = &amp;a;<br>    *p1 = <span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p>​创建方式不同，栈是系统自动创建（栈主要用于保存局部变量）,当函数执行完成，栈被销毁</p><p>​堆是程序员手动创建和释放的，malloc创建free释放</p><p>​空间大小的区别，栈的空间是比较小的，堆的空间是比较大的</p><p>​访问速度，栈的访问速度是比堆要快的</p><p>​生命周期，栈自动销毁，堆手动销毁</p><h3 id="Malloc和new的区别"><a href="#Malloc和new的区别" class="headerlink" title="Malloc和new的区别"></a>Malloc和new的区别</h3><p>​malloc是c语言中的标准库函数，new是c++中的操作符</p><p>​malloc分配内存后返回的是void*类型的指针，new分配内存后返回的是对应对象类型的指针</p><p>​使用malloc分配内存的时候需要进行指定分配内存的大小，使用new进行内存分配时不需要制定</p><p>​使用malloc分配内存的时候不会调用构造函数，使用new分配内存时会调用到构造函数</p><h3 id="struct和class在c-中的区别"><a href="#struct和class在c-中的区别" class="headerlink" title="struct和class在c++中的区别"></a>struct和class在c++中的区别</h3><p>​struct成员默认是公有的，class默认的是私有的</p><p>​继承方面，struct默认的是公有继承，class默认的是私有继承</p><p>​struct一般使用与简单的数据结构，class一般用于封装和继承</p><h3 id="c-中的类有几个访问权限"><a href="#c-中的类有几个访问权限" class="headerlink" title="c++中的类有几个访问权限"></a>c++中的类有几个访问权限</h3><p>​公有的，私有的，受保护的</p><h3 id="程序分为几个段"><a href="#程序分为几个段" class="headerlink" title="程序分为几个段"></a>程序分为几个段</h3><p>​代码段，用于储存程序的可执行指令，一般是只读的，防止被修改</p><p>​数据段，用于储存已经初始化的全局变量和静态变量</p><p>​bss段，储存没有初始化的全局变量和静态变量</p><p>​堆，malloc和free进行管理</p><p>​栈，储存局部变量，系统申请和释放</p><h3 id="队列和栈的区别"><a href="#队列和栈的区别" class="headerlink" title="队列和栈的区别"></a>队列和栈的区别</h3><p>​访问的方式，栈是先进后出，队列先进先出</p><p>​栈，只能在栈顶进行操作，队列，在队尾进行插入，在对头进行删除</p><p>​栈主要用于函数调用，表达式求值，队列，任务调度，广度优先搜索</p><h3 id="c文件执行流程"><a href="#c文件执行流程" class="headerlink" title="c文件执行流程"></a>c文件执行流程</h3><p>​预处理，将头文件宏定义进行展开，生成没有注释的源代码，.i文件</p><p>​编译，将预处理得到的源代码转为汇编代码 .s文件</p><p>​汇编，将汇编代码转为机器码 生成 .o文件</p><p>​链接 ，将全部的.o文件链接为可执行程序</p><h3 id="SPI和IIC的寻址区别"><a href="#SPI和IIC的寻址区别" class="headerlink" title="SPI和IIC的寻址区别"></a>SPI和IIC的寻址区别</h3><p>​SPI MISO MOSI SCLK CS 通过cs线片选引脚，选择对应的设备进行通信</p><p>​IIC SDA SCL 通过从机地址进行寻址7位和10位方式</p><h3 id="进程间通信有几种方式，哪几种需要借助内核"><a href="#进程间通信有几种方式，哪几种需要借助内核" class="headerlink" title="进程间通信有几种方式，哪几种需要借助内核"></a>进程间通信有几种方式，哪几种需要借助内核</h3><p>​管道,命名管道，共享内存，信号量，消息队列，套接字，信号</p><h3 id="什么是DMA"><a href="#什么是DMA" class="headerlink" title="什么是DMA"></a>什么是DMA</h3><p>​DMA是一种无需cpu参与就可以让外设和系统之间的数据进行双向数据传递，可以提高效率</p><h3 id="进程有几个状态"><a href="#进程有几个状态" class="headerlink" title="进程有几个状态"></a>进程有几个状态</h3><p>​创建状态 当调用fork进入创建状态</p><p>​就绪状态</p><p>​运行状态</p><p>​阻塞状态</p><p>​终止状态</p><h3 id="僵尸进程，孤儿进程，守护进程"><a href="#僵尸进程，孤儿进程，守护进程" class="headerlink" title="僵尸进程，孤儿进程，守护进程"></a>僵尸进程，孤儿进程，守护进程</h3><p>​僵尸进程，使用fork子进程后，如果子进程退出，父进程并没有调用wait或者waitpid函数获取子进程的退出状态，那个子进程的信息还保存在系统中，这个时候子进程就叫做僵尸进程</p><p>​父进程异常结束，子进程就会变成孤儿进程，会被init1号进程收养</p><p>​在父进程创建出子进程后故意把父进程结束，那个这个子进程就是守护进程</p><h3 id="FreeRTOS的调度算法"><a href="#FreeRTOS的调度算法" class="headerlink" title="FreeRTOS的调度算法"></a>FreeRTOS的调度算法</h3><p>​抢占式调度，高优先级的任务可以打断低优先级任务的执行，适用于优先级不同的任务</p><p>​时间片轮转，相同优先级的任务具有相同大小的时间片</p><p>​协作式调度，让出cpu，通过信号量等切换任务</p><h3 id="RTOS中任务同步的方式"><a href="#RTOS中任务同步的方式" class="headerlink" title="RTOS中任务同步的方式"></a>RTOS中任务同步的方式</h3><p>​队列，信号量，互斥量，事件组，任务通知</p><h3 id="FreeRTOS任务的状态"><a href="#FreeRTOS任务的状态" class="headerlink" title="FreeRTOS任务的状态"></a>FreeRTOS任务的状态</h3><p>​就绪态，运行态，阻塞态，挂起态</p><h3 id="RS232和RS485的区别"><a href="#RS232和RS485的区别" class="headerlink" title="RS232和RS485的区别"></a>RS232和RS485的区别</h3><p>​RS232是全双工通信，tx,rx,gnd </p><p>​rs485是半双工通信 只有两根信号线。差分传输</p><p>​抗干扰能力，rs485抗干扰能力比rs232更强，使用双绞线将2根信号线缠绕在一起</p><p>​rs232一般用于点对点通信，rs485多对多，一对多，工业控制</p><p>​485传输距离1.5km 232只有15m</p><p>​232传输速率比较低，485传输速率比较高</p><h3 id="析构函数与构造函数"><a href="#析构函数与构造函数" class="headerlink" title="析构函数与构造函数"></a>析构函数与构造函数</h3><p>​构造函数，初始化对象，设定初始值, 没有返回值，多个重载版本</p><p>​析构函数 释放资源，清理操作，没有参数也没有返回值，不能重载</p><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>​多字节的数据在内存中的存储顺序方式,在不同的计算机中使用不同的字节序来表示数据</p><p>​大端储存，高字节在低地址，低字节在高地址</p><p>​小端存储，低字节在低地址，高字节在高地址</p><p>​0x12345678，    假设第一个字节是0x78，那么为小端存储，第一个字节为0x12，是大端存储</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>​用户和内核之间的接口，通过接口可以使用用户空间访问到内核空间，直接访问内核空间是非常不安全的，导致内核崩溃</p><h3 id="软件IIC和硬件IIC的区别"><a href="#软件IIC和硬件IIC的区别" class="headerlink" title="软件IIC和硬件IIC的区别"></a>软件IIC和硬件IIC的区别</h3><p>​软件，通过控制gpio来模拟scl和sda信号来产生iic的时序</p><p>​硬件，mcu内部的专用硬件模块来产生时序，软件只负责发出命令</p><h3 id="Linux驱动分类"><a href="#Linux驱动分类" class="headerlink" title="Linux驱动分类"></a>Linux驱动分类</h3><p>​字符设备驱动，用于处理顺序数据的读写操作，适用于终端，串口，led，蜂鸣器</p><p>​块设备驱动，主要用于处理以块为单位的数据读写操作，硬盘。ssd</p><p>​网络设备驱动，网卡设备</p><h3 id="Linux与RTOS的区别"><a href="#Linux与RTOS的区别" class="headerlink" title="Linux与RTOS的区别"></a>Linux与RTOS的区别</h3><p>​应用场景，linux桌面计算机，服务器，嵌入式系统， rtos嵌入式系统</p><p>​linux不保证实时性，rtos提供严格的实时性保证，任务的调度和执行时间非常可预测，任务的响应都非常快</p><p>​linux占用资源多，rtos轻量级操作系统</p><p>​linux有虚拟内存，内核空间和用户空间，rtos没有虚拟内存，也没有用户空间和内核空间</p><p>​linux的扩展非常高</p><h3 id="fork和vfork的区别"><a href="#fork和vfork的区别" class="headerlink" title="fork和vfork的区别"></a>fork和vfork的区别</h3>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习</title>
    <link href="/2024/12/23/typescript_learn/"/>
    <url>/2024/12/23/typescript_learn/</url>
    
    <content type="html"><![CDATA[<!-- typescript_learn--><span id="more"></span><h3 id="什么是TypeScript"><a href="#什么是TypeScript" class="headerlink" title="什么是TypeScript"></a>什么是TypeScript</h3><p>融合了后端面向对象思想的超级版的javaScript 语言。</p><p><strong>环境搭建</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">npm init -y<br>yarn add typescript -D<br>tsc --init<br></code></pre></td></tr></table></figure><p><strong>优势</strong></p><ul><li>优势1:编译时静态类型检测:函数或方法传参或变量赋值不匹配时，会出现编译错误提示 ，规避了开发期间的大量低级错误，省时，省力。</li><li>优势2:自动提示更清晰明确。</li><li>优势3:引入了泛型和一系列的 TS 特有的类型。</li><li>优势4:强大的 d.ts 声明文件:声明文件像一个书的目录一样，清晰直观展示了依赖库文件的接口，type类型，类，函数，变量等声明</li><li>优势5:轻松编译成 JS 文件:即使 TS 文件有错误，绝大多数情况也能编译出 JS 文件。</li><li>优势6:灵活性高: 尽管 TS 是一门 强类型检査语言，但也提供了 any 类型 和 as any 断言，这提供了 TS 的灵活度。</li></ul><h3 id="类型注解与推导"><a href="#类型注解与推导" class="headerlink" title="类型注解与推导"></a>类型注解与推导</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类型注解</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">data</span>: number = <span class="hljs-number">3</span><br><br><br><span class="hljs-comment">// 类型推导</span><br><span class="hljs-keyword">let</span> money = <span class="hljs-number">30</span><br><br><br>interface <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-attr">name</span>: string,<br>    <span class="hljs-attr">age</span>: number<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">stu</span>: <span class="hljs-title class_">Student</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;&#125; <span class="hljs-comment">// 这句话的作用是 当前变量的作用于属于这个ts文件</span><br></code></pre></td></tr></table></figure><h3 id="编译与优化"><a href="#编译与优化" class="headerlink" title="编译与优化"></a>编译与优化</h3><p>tsconfig.json文件里 修改 “rootDir”: “.&#x2F;src” 与 “outDir”: “.&#x2F;dist” 源文件与编译后文件</p><p><img src="/imgs/TypeScript%E5%AD%A6%E4%B9%A0/image-20241223111745357.png"></p><p>然后在项目根目录 输入 tsc  执行编译,  src里面的文件都会按照commonjs规范编译出dist里的文件</p><p><img src="/imgs/TypeScript%E5%AD%A6%E4%B9%A0/image-20241223111844864.png"></p><h3 id="常用的24种TS类型"><a href="#常用的24种TS类型" class="headerlink" title="常用的24种TS类型"></a>常用的24种TS类型</h3><p><strong>基本类型:</strong></p><p>number, string ,boolean, symbol, null, undefined</p><p><strong>根类型:  所有其他数据类型的父类</strong></p><p>Object, {} &#x2F;&#x2F; 大括号是Object的简写</p><p><strong>对象类型:</strong></p><p>Array, object, function</p><p><strong>枚举:</strong></p><p>enum</p><p><strong>其他特殊类型:</strong></p><p>any，unknown，never，void，元组(tuple)，可变元组</p><p><strong>合成类型:</strong></p><p>联合类型，交叉类型</p><p><strong>字面量数据类型:</strong></p><p><img src="/imgs/TypeScript%E5%AD%A6%E4%B9%A0/image-20241223113702183.png"></p><h3 id="枚举的定义，分类，取值方式"><a href="#枚举的定义，分类，取值方式" class="headerlink" title="枚举的定义，分类，取值方式"></a>枚举的定义，分类，取值方式</h3><p>用来存放一组固定的常量的序列  包括字符串枚举和数字枚举</p><p><img src="/imgs/TypeScript%E5%AD%A6%E4%B9%A0/image-20241223114828628.png"></p><h3 id="any与unknown"><a href="#any与unknown" class="headerlink" title="any与unknown"></a>any与unknown</h3><p>相同点: any 和 unknown 可以是任何类的父类，所以任何类型的变量都可以赋值给 any 类型或 unknown类型的变量。</p><p>不同点1:any 也可以是任何类的子类，但 unknown 不可以，所以 any 类型的变量都可以赋值给 其他类型的变量。</p><p>不同点2:不能拿 unknown 类型的变量来获取任何属性和方法，但 any 类型的变量可以获取任意名称的属性和任意名称的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// any与unknown 是子类</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>:string = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">data</span>: any = str<br><span class="hljs-keyword">let</span> <span class="hljs-attr">data2</span>: unknown = str<br><span class="hljs-keyword">let</span> <span class="hljs-attr">data3</span>: any = <span class="hljs-literal">undefined</span><br><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">array</span>:any = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br><span class="hljs-keyword">let</span> <span class="hljs-attr">array2</span>:<span class="hljs-title class_">Array</span>&lt;string&gt; = array<br><br><span class="hljs-comment">// let array3:unknown = [&quot;a&quot;, &quot;b&quot;]  </span><br><span class="hljs-comment">// let array4:Array&lt;string&gt; = array3  //错误</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">data:any</span>):any&#123;<br>    <span class="hljs-keyword">return</span> data.<span class="hljs-property">name</span><br>&#125;<br><br><span class="hljs-comment">// function getData2(data:unknown):string&#123;</span><br><span class="hljs-comment">//     return data.name   // 错误 无法获取属性</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>另一种定义对象类型的类型</p><p>可以为多个同类别的类提供统一的方法和属性申明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">interface <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-attr">name</span>: string<br>    <span class="hljs-attr">price</span>: number<br>    <span class="hljs-attr">account</span>: number<br>    <span class="hljs-title function_">buy</span>(): <span class="hljs-keyword">void</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Product</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">price</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">account</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">buy</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>): <span class="hljs-keyword">void</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Function not implemented.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 接口继承 继承了Product的所有属性</span><br>interface <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-attr">id</span>: number<br>&#125;<br></code></pre></td></tr></table></figure><p>可索引签名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">interface <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-attr">name</span>: string<br>    <span class="hljs-attr">price</span>: number<br>    <span class="hljs-attr">account</span>: number<br>    [<span class="hljs-attr">x</span>: string]: any <span class="hljs-comment">// 索引签名的值需要兼容其他属性</span><br>    <span class="hljs-comment">// [y: string]: number</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Product</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">price</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">account</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">info</span>: <span class="hljs-string">&quot;hello&quot;</span>,  <span class="hljs-comment">// 索引签名 可以是任意类型</span><br>    <span class="hljs-number">100</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>    <span class="hljs-attr">buy</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>): <span class="hljs-keyword">void</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Function not implemented.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: string = <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-property">length</span>)<br><br><span class="hljs-comment">// let str1: string </span><br><span class="hljs-comment">// console.log(str1) // 无法打印</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str2</span>: string | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2)<br><br><span class="hljs-comment">// let str3: string  = undefined // 无法赋值</span><br><span class="hljs-comment">// console.log(str3)</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">data?: string</span>) &#123; <span class="hljs-comment">// data类型为string | undefined</span><br>    <span class="hljs-comment">// 把data解析为string | undefined类型</span><br>&#125;<br><span class="hljs-title function_">fn</span>()<br><br><span class="hljs-comment">// any, unkonwn, undefined 可以接受undefined</span><br><span class="hljs-comment">// any, unkonwn, null 可以接受null</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">data</span>: any = <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h3 id="函数和函数类型-rest参数"><a href="#函数和函数类型-rest参数" class="headerlink" title="函数和函数类型 rest参数"></a>函数和函数类型 rest参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">name: string, age: number</span>): number &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3</span>)<br><br><br><span class="hljs-keyword">let</span> info2 = <span class="hljs-keyword">function</span> (<span class="hljs-params">name: string, age: number</span>): number &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-title function_">info2</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3</span>)<br><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">info3</span>: <span class="hljs-function">(<span class="hljs-params">name: string, age: number</span>) =&gt;</span> number =<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age</span>): number &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125;<br><span class="hljs-title function_">info3</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3</span>)<br><br><br>type <span class="hljs-title class_">InfoFunType</span> = <span class="hljs-function">(<span class="hljs-params">name: string, age: number</span>) =&gt;</span> number<br><span class="hljs-keyword">let</span> <span class="hljs-attr">info4</span>: <span class="hljs-title class_">InfoFunType</span> =<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age</span>): number &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125;<br><span class="hljs-title function_">info4</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">info5</span>(<span class="hljs-params">name: string, age: number, ...rest: any</span>): number &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age, rest)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-title function_">info5</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>)<br></code></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>满足以下3点的数组就是元组</p><p>(1)在定义时每个元素的类型都确定</p><p>(2)元素值的数据类型必须是当前元素定义的类型</p><p>(3)元素值的个数必须和定义时个数相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">salary</span>: [string, number] = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">100</span>]<br><br><br><span class="hljs-comment">// 数组与数组元素同时为只读</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br><span class="hljs-comment">// arr[0] = 100 // 不能修改</span><br><br><br><br><span class="hljs-comment">// 可变元组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: [number, ...string[]] = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>]<br><br><span class="hljs-comment">// 可变元组结构</span><br><span class="hljs-keyword">let</span> [age, ...rest]: [number, ...string[]] = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age, rest)<br><span class="hljs-keyword">let</span> [age1, name, ...rest1]: [<span class="hljs-attr">age1_</span>: number, <span class="hljs-attr">name_</span>: string, ...<span class="hljs-attr">rest_</span>: string[]] = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age, rest)<br></code></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-attr">name</span>: string<br>    <span class="hljs-attr">age</span>: number;<br>    <span class="hljs-attr">addr</span>: string;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: string, age: number, addr: string</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">addr</span> = addr;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// let p = new People(&quot;张三&quot;, 18, &quot;北京&quot;)</span><br><span class="hljs-comment">// console.log(p)</span><br><br><br><span class="hljs-comment">// 类单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People2</span> &#123;<br>    <span class="hljs-attr">name</span>: string<br>    <span class="hljs-attr">age</span>: number;<br>    <span class="hljs-attr">addr</span>: string;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-attr">people</span>: <span class="hljs-title class_">People2</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(): <span class="hljs-title class_">People2</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">People2</span>.<span class="hljs-property">people</span>) &#123;<br>            <span class="hljs-title class_">People2</span>.<span class="hljs-property">people</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People2</span>(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;上海&quot;</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">People2</span>.<span class="hljs-property">people</span><br>    &#125;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: string, age: number, addr: string</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">addr</span> = addr;<br>    &#125;<br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">People2</span>.<span class="hljs-title function_">getInstance</span>()<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">People2</span>.<span class="hljs-title function_">getInstance</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 === p3)<br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>具有以下特点的数据类型叫泛型</p><p>特点一:定义时不明确使用时必须明确成某种具体数据类型的数据类型。【泛型的宽泛】</p><p>特点二:编译期间进行数据类型检查的数据类型。【泛型的严谨】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>interface <span class="hljs-title class_">Ref</span>&lt;V&gt; &#123;<br>    <span class="hljs-attr">value</span>: V<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">ref</span>: <span class="hljs-title class_">Ref</span>&lt;string&gt; = &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;23&quot;</span> &#125;<br><br>type <span class="hljs-title class_">Student</span> = &#123; <span class="hljs-attr">name</span>: string, <span class="hljs-attr">age</span>: number &#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">ref2</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-title class_">Student</span>&gt; = &#123;<br>    <span class="hljs-attr">value</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;wangwu&quot;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">23</span><br>    &#125;<br>&#125;<br><br>ref.<span class="hljs-property">value</span><br>ref2.<span class="hljs-property">value</span>.<span class="hljs-property">name</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;T&gt; &#123;<br>    <span class="hljs-attr">arr</span>: <span class="hljs-title class_">Array</span>&lt;T&gt;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span> = []<br>    &#125;<br><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">ele: T</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>.<span class="hljs-title function_">push</span>(ele)<br>    &#125;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-attr">index</span>: number): T &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>[index]<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;T = any&gt; &#123; <span class="hljs-comment">// 泛型默认值</span><br>    <span class="hljs-attr">arr</span>: <span class="hljs-title class_">Array</span>&lt;T&gt;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span> = []<br>    &#125;<br><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">ele: T</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>.<span class="hljs-title function_">push</span>(ele)<br>    &#125;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-attr">index</span>: number): T &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>[index]<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;string&gt;()<br><br><span class="hljs-keyword">function</span> quickSort&lt;E&gt; (<span class="hljs-attr">arr</span>: E[]) : <span class="hljs-title class_">Array</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Electron开发教程</title>
    <link href="/2024/12/21/electron_learn/"/>
    <url>/2024/12/21/electron_learn/</url>
    
    <content type="html"><![CDATA[<!-- electron_learn--><span id="more"></span><h3 id="什么是Electron"><a href="#什么是Electron" class="headerlink" title="什么是Electron"></a>什么是Electron</h3><p><img src="/imgs/Electron%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20241221155100183.png"></p><h3 id="Electron流程模型"><a href="#Electron流程模型" class="headerlink" title="Electron流程模型"></a>Electron流程模型</h3><p><img src="/imgs/Electron%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20241221155741381.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域问题</title>
    <link href="/2024/12/21/cross_domain/"/>
    <url>/2024/12/21/cross_domain/</url>
    
    <content type="html"><![CDATA[<!-- cross_domain--><span id="more"></span><h3 id="什么是源"><a href="#什么是源" class="headerlink" title="什么是源"></a>什么是源</h3><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221093805910.png"></p><h3 id="同源与非同源"><a href="#同源与非同源" class="headerlink" title="同源与非同源"></a>同源与非同源</h3><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221093923427.png"></p><h3 id="同源请求与非同源请求"><a href="#同源请求与非同源请求" class="headerlink" title="同源请求与非同源请求"></a>同源请求与非同源请求</h3><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221094227024.png"></p><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221094256501.png"></p><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221094356500.png"></p><h3 id="浏览器会对跨域做出哪些限制？"><a href="#浏览器会对跨域做出哪些限制？" class="headerlink" title="浏览器会对跨域做出哪些限制？"></a>浏览器会对跨域做出哪些限制？</h3><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221095401744.png"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>跨域限制仅存在浏览器端，服务端不存在跨域限制</li><li>即使跨域了，Ajax请求也可以正常发出，但响应数据不会交给开发者</li></ul><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221100122676.png"></p><h3 id="CORS解决Ajax跨域问题"><a href="#CORS解决Ajax跨域问题" class="headerlink" title="CORS解决Ajax跨域问题"></a>CORS解决Ajax跨域问题</h3><h5 id="CORS概述"><a href="#CORS概述" class="headerlink" title="CORS概述"></a>CORS概述</h5><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221100531628.png"></p><h5 id="CORS解决简单请求的跨域问题"><a href="#CORS解决简单请求的跨域问题" class="headerlink" title="CORS解决简单请求的跨域问题"></a>CORS解决简单请求的跨域问题</h5><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221101331939.png"></p><h5 id="简单请求与复杂请求"><a href="#简单请求与复杂请求" class="headerlink" title="简单请求与复杂请求"></a>简单请求与复杂请求</h5><p>CORS把请求分为简单请求和复杂请求</p><h6 id="CORS解决简单请求的跨域问题-1"><a href="#CORS解决简单请求的跨域问题-1" class="headerlink" title="CORS解决简单请求的跨域问题"></a>CORS解决简单请求的跨域问题</h6><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221101759160.png"></p><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221102215925.png"></p><h6 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h6><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221104413416.png"></p><h6 id="CORS解决预检请求的跨域问题"><a href="#CORS解决预检请求的跨域问题" class="headerlink" title="CORS解决预检请求的跨域问题"></a>CORS解决预检请求的跨域问题</h6><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221104239131.png"></p><h6 id="CORS解决复杂请求的跨域问题"><a href="#CORS解决复杂请求的跨域问题" class="headerlink" title="CORS解决复杂请求的跨域问题"></a>CORS解决复杂请求的跨域问题</h6><p>服务器先通过浏览器的预检请求，服务器需要返回如下请求头</p><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221104544508.png"></p><p>然后处理实际的跨域请求，与处理简单请求跨域的方式相同</p><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221104911655.png"></p><p>CORS库快速完成配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm i cors<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>())<br></code></pre></td></tr></table></figure><p>完整配置</p><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221110309255.png"></p><h3 id="JSONP解决跨域-了解"><a href="#JSONP解决跨域-了解" class="headerlink" title="JSONP解决跨域(了解)"></a>JSONP解决跨域(了解)</h3><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221110637219.png"></p><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221110714815.png"></p><p>使用标签的写法请求数据，绕过跨域限制，服务器返回js语法内容，然后执行</p><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221111436042.png"></p><p><img src="/imgs/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20241221111621016.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cross</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>u8g2学习</title>
    <link href="/2024/11/28/embedded_u8g2/"/>
    <url>/2024/11/28/embedded_u8g2/</url>
    
    <content type="html"><![CDATA[<!-- embedded_u8g2--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/dpjcn1990/article/details/92831760">https://blog.csdn.net/dpjcn1990/article/details/92831760</a></p><h3 id="u8g2学习"><a href="#u8g2学习" class="headerlink" title="u8g2学习"></a>u8g2学习</h3><p>Arduino平台上使用最广泛的OLED库</p><p><strong>像素点点阵</strong></p><p>OLED其实就是一个M x n 的像素点阵，想显示什么就得把具体位置的像素点亮起来。对于每一个像素点，有可能是1点亮，也有可能是0点亮； </p><p><strong>坐标系</strong></p><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128095755886.png"></p><p>在坐标系中，左上角是原点，向右是X轴，向下是Y轴。</p><h3 id="U8g2是什么"><a href="#U8g2是什么" class="headerlink" title="U8g2是什么"></a>U8g2是什么</h3><p>U8g2是嵌入式设备的单色图形库，一句话简单明了。主要应用于嵌入式设备，包括我们常见的单片机；</p><h3 id="U8g2支持的显示控制器"><a href="#U8g2支持的显示控制器" class="headerlink" title="U8g2支持的显示控制器"></a>U8g2支持的显示控制器</h3><p>    U8g2支持单色OLED和LCD，包括以下控制器：SSD1305，SSD1306，SSD1309，SSD1322，SSD1325，SSD1327，SSD1329，SSD1606，SSD1607，SH1106，SH1107，SH1108，SH1122，T6963，RA8835，LC7981，PCD8544，PCF8812，HX1230 ，UC1601，UC1604，UC1608，UC1610，UC1611，UC1701，ST7565，ST7567，ST7588，ST75256，NT7534，IST3020，ST7920，LD7032，KS0108，SED1520，SBN1661，IL3820，MAX7219等</p><p>可以说，基本上主流的显示控制器都支持，比如我们常见的SSD1306 12864</p><h3 id="U8g2支持的Arduino主板"><a href="#U8g2支持的Arduino主板" class="headerlink" title="U8g2支持的Arduino主板"></a>U8g2支持的Arduino主板</h3><p>可以说基本上所有Arduino API的主板都得到U8g2的支持</p><ul><li>Aruino Zero，Uno，Mega，Due，101，MKR Zero以及所有其他Arduino官方主板</li><li>基于Arduino平台的STM32</li><li>基于Arduino平台的ESP8266和ESP32</li><li>甚至其他不知名的基于Arduino平台的开发板</li></ul><h3 id="U8g2的优势"><a href="#U8g2的优势" class="headerlink" title="U8g2的优势"></a>U8g2的优势</h3><p>为什么要运用U8g2库？也就是说U8g2库能带给我们什么样的开发便利</p><ul><li>U8g2库平台支持性好，基本上支持绝大部分Arduino开发板；</li><li>U8g2库显示控制器支持性好，基本上市面上的OLED都完美支持；</li><li>U8g2库 API众多，特别支持了中文，支持了不同字体，这是一个对于开发者俩说不小的福利。</li></ul><h3 id="U8g2库函数详解"><a href="#U8g2库函数详解" class="headerlink" title="U8g2库函数详解"></a>U8g2库函数详解</h3><p><strong>基本函数</strong></p><p><strong>u8g2.begin() —— 构造U8G2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化U8g2库</span><br><span class="hljs-comment"> * @Note 关联方法 initDisplay clearDisplay setPowerSave</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">U8G2::begin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* note: call to u8x8_utf8_init is not required here, this is done in the setup procedures before */</span><br>   initDisplay(); <span class="hljs-comment">//初始化显示器</span><br>   clearDisplay();  <span class="hljs-comment">// 重置清屏</span><br>   setPowerSave(<span class="hljs-number">0</span>); <span class="hljs-comment">//唤醒屏幕</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>u8g2.beginSimple() —— 构造U8G2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 简单初始化U8g2库</span><br><span class="hljs-comment"> * @Note 关联方法 beginSimple</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::beginSimple</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">beginSimple</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* does not clear the display and does not wake up the display */</span><br><span class="hljs-comment">/* user is responsible for calling clearDisplay() and setPowerSave(0) */</span><br>   initDisplay();<span class="hljs-comment">//初始化显示器</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>u8g2.initDisplay() —— 初始化显示控制器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化显示控制器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::initDisplay</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>这个方法不需要我们单独调用，会在begin函数主动调用一次</li></ul><p><strong>u8g2.clearDisplay() —— 清除屏幕内容</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清除屏幕</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::clearDisplay</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>这个方法不需要我们单独调用，会在begin函数主动调用一次，我们主要理解即可；</li><li>不要在 firstPage 和 nextPage 函数之间调用该方法；</li></ul><p><strong>u8g2.setPowerSave() —— 是否开启省电模式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清除显示缓冲区</span><br><span class="hljs-comment"> * @param is_enable</span><br><span class="hljs-comment"> *        1 表示启用显示器的省电模式，屏幕上看不到任何东西</span><br><span class="hljs-comment"> *        0 表示禁用省电模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setPowerSave</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> is_enable)</span><br></code></pre></td></tr></table></figure><ul><li>不管是启用还是禁用，显示器需要的内存消耗是不会变的，说到底就是为了关闭屏幕，做到省电；</li><li>所以这里就可以理解为什么初始化需要 setPowerSave(0);</li></ul><p><strong>u8g2.clear() —— 清除操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清除屏幕显示，清除缓冲区，光标回到左上角原点位置（0，0）</span><br><span class="hljs-comment"> * @Note 关联方法 home clearDisplay clearBuffer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::clear</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123; <br>   home(); <span class="hljs-comment">//回到原点</span><br>   clearDisplay(); <span class="hljs-comment">//清除屏幕上的显示</span><br>   clearBuffer();  <span class="hljs-comment">//清除缓冲区</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>u8g2.clearBuffer() —— 清除缓冲区</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清除内存中数据缓冲区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::clearBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>一般这个函数是与sendBuffer函数配对使用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  u8g2.clearBuffer();<br>  <span class="hljs-comment">// ... write something to the buffer </span><br>  u8g2.sendBuffer();<br>  delay(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>u8g2.disableUTF8Print() —— 禁用 UTF8打印</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 禁用Arduino平台下支持输出UTF8字符集，默认是开启</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::disableUTF8Print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>我们的中文字符就是UTF8；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  u8g2.begin();<br>  u8g2.enableUTF8Print();<span class="hljs-comment">// enable UTF8 support for the Arduino print() function</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  u8g2.setFont(u8g2_font_unifont_t_chinese2);  <span class="hljs-comment">// use chinese2 for all the glyphs of &quot;你好世界&quot;</span><br>  u8g2.firstPage();<br>  <span class="hljs-keyword">do</span> &#123;<br>    u8g2.setCursor(<span class="hljs-number">0</span>, <span class="hljs-number">40</span>);<br>    u8g2.print(<span class="hljs-string">&quot;你好世界&quot;</span>);<span class="hljs-comment">// Chinese &quot;Hello World&quot; </span><br>  &#125; <span class="hljs-keyword">while</span> ( u8g2.nextPage() );<br>  delay(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>u8g2.home() —— 重置显示光标的位置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重置显示光标的位置，回到原点（0，0）</span><br><span class="hljs-comment"> * @Note 关联方法 print clear</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::home</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><hr><p><strong>绘制相关函数</strong></p><p> <strong>u8g2.drawBox() —— 画实心方形</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画实心方形，左上角坐标为(x,y),宽度为w，高度为h</span><br><span class="hljs-comment"> * @param x 左上角的x坐标</span><br><span class="hljs-comment"> * @param y 左上角的y坐标</span><br><span class="hljs-comment"> * @param w 方形的宽度</span><br><span class="hljs-comment"> * @param h 方形的高度</span><br><span class="hljs-comment"> * @Note 关联方法 drawFrame setDrawColor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawBox</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">u8g2_uint_t</span> w, <span class="hljs-type">u8g2_uint_t</span> h)</span><br></code></pre></td></tr></table></figure><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.drawBox(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">25</span>,<span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128101242216.png"></p><p><strong>u8g2.drawCircle() —— 画空心圆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画空心圆，圆心坐标为(x0,y0),半径为rad</span><br><span class="hljs-comment"> * @param x0 圆点的x坐标</span><br><span class="hljs-comment"> * @param y0 圆点的y坐标</span><br><span class="hljs-comment"> * @param rad 圆形的半径</span><br><span class="hljs-comment"> * @param opt 圆形选项</span><br><span class="hljs-comment"> *        U8G_DRAW_ALL 整个圆</span><br><span class="hljs-comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span><br><span class="hljs-comment"> *        选项可以通过 | 操作符来组合</span><br><span class="hljs-comment"> * @Note 关联方法 drawDisc setDrawColor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawCircle</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x0, <span class="hljs-type">u8g2_uint_t</span> y0, <span class="hljs-type">u8g2_uint_t</span> rad, <span class="hljs-type">uint8_t</span> opt = U8G2_DRAW_ALL)</span><br></code></pre></td></tr></table></figure><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>直径等于2rad + 1；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.drawCircle(<span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">10</span>, U8G2_DRAW_ALL);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128101335532.png"></p><p><strong>u8g2.drawDisc() —— 画实心圆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画实心圆，圆心坐标为(x0,y0),半径为rad</span><br><span class="hljs-comment"> * @param x0 圆点的x坐标</span><br><span class="hljs-comment"> * @param y0 圆点的y坐标</span><br><span class="hljs-comment"> * @param rad 圆形的半径</span><br><span class="hljs-comment"> * @param opt 圆形选项</span><br><span class="hljs-comment"> *        U8G_DRAW_ALL 整个圆</span><br><span class="hljs-comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span><br><span class="hljs-comment"> *       选项可以通过 | 操作符来组合</span><br><span class="hljs-comment"> * @Note 关联方法 drawCircle setDrawColor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawDisc</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x0, <span class="hljs-type">u8g2_uint_t</span> y0, <span class="hljs-type">u8g2_uint_t</span> rad, <span class="hljs-type">uint8_t</span> opt = U8G_DRAW_ALL)</span><br></code></pre></td></tr></table></figure><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>直径等于2rad + 1；</li></ul><p><strong>u8g2.drawEllipse() —— 画空心椭圆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画空心椭圆，圆心坐标为(x0,y0),半径为rad</span><br><span class="hljs-comment"> * @param x0 圆点的x坐标</span><br><span class="hljs-comment"> * @param y0 圆点的y坐标</span><br><span class="hljs-comment"> * @param rx 椭圆形水平x方向的半径</span><br><span class="hljs-comment"> * @param ry 椭圆形竖直y方向的半径</span><br><span class="hljs-comment"> * @param opt 圆形选项</span><br><span class="hljs-comment"> *        U8G_DRAW_ALL 整个椭圆</span><br><span class="hljs-comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span><br><span class="hljs-comment"> *        选项可以通过 | 操作符来组合</span><br><span class="hljs-comment"> * @Note 关联方法 drawCircle</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawEllipse</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x0, <span class="hljs-type">u8g2_uint_t</span> y0, <span class="hljs-type">u8g2_uint_t</span> rx, <span class="hljs-type">u8g2_uint_t</span> ry, <span class="hljs-type">uint8_t</span> opt)</span><br></code></pre></td></tr></table></figure><ul><li>rx*ry 在8位模式的u8g2必须小于512</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.drawEllipse(<span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, U8G2_DRAW_ALL);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128101514170.png"></p><p><strong>u8g2.drawFilledEllipse() —— 画实心椭圆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画实心椭圆，圆心坐标为(x0,y0),半径为rad</span><br><span class="hljs-comment"> * @param x0 圆点的x坐标</span><br><span class="hljs-comment"> * @param y0 圆点的y坐标</span><br><span class="hljs-comment"> * @param rx 椭圆形水平x方向的半径</span><br><span class="hljs-comment"> * @param ry 椭圆形竖直y方向的半径</span><br><span class="hljs-comment"> * @param opt 圆形选项</span><br><span class="hljs-comment"> *        U8G_DRAW_ALL 整个椭圆</span><br><span class="hljs-comment"> *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧</span><br><span class="hljs-comment"> *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧</span><br><span class="hljs-comment"> *        选项可以通过 | 操作符来组合</span><br><span class="hljs-comment"> * @Note 关联方法 drawCircle</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawFilledEllipse</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x0, <span class="hljs-type">u8g2_uint_t</span> y0, <span class="hljs-type">u8g2_uint_t</span> rx, <span class="hljs-type">u8g2_uint_t</span> ry, <span class="hljs-type">uint8_t</span> opt)</span><br></code></pre></td></tr></table></figure><ul><li>rx*ry 在8位模式的u8g2必须小于512</li></ul><p><strong>u8g2.drawFrame() —— 画空心方形</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画空心方形，左上角坐标为(x,y),宽度为w，高度为h</span><br><span class="hljs-comment"> * @param x 左上角的x坐标</span><br><span class="hljs-comment"> * @param y 左上角的y坐标</span><br><span class="hljs-comment"> * @param w 方形的宽度</span><br><span class="hljs-comment"> * @param h 方形的高度</span><br><span class="hljs-comment"> * @Note 关联方法 setDrawColor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawFrame</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">u8g2_uint_t</span> w, <span class="hljs-type">u8g2_uint_t</span> h)</span><br></code></pre></td></tr></table></figure><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.drawFrame(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">25</span>,<span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128101653379.png"></p><p><strong>u8g2.drawGlyph() —— 绘制字体字集的符号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制字体字集里面定义的符号</span><br><span class="hljs-comment"> * @param x 左上角的x坐标</span><br><span class="hljs-comment"> * @param y 左上角的y坐标</span><br><span class="hljs-comment"> * @param encoding 字符的unicode值</span><br><span class="hljs-comment"> * @Note 关联方法 setFont</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawGlyph</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">uint16_t</span> encoding)</span><br></code></pre></td></tr></table></figure><ul><li>U8g2支持16位以内的unicode字符集，也就是说encoding的范围为0-65535，drawGlyph方法只能绘制存在于所使用的字体字集中的unicode值；</li><li>这个绘制方法依赖于当前的字体模式和绘制颜色</li></ul><p> <strong>u8g2.drawHLine() —— 绘制水平线</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制水平线</span><br><span class="hljs-comment"> * @param x 左上角的x坐标</span><br><span class="hljs-comment"> * @param y 左上角的y坐标</span><br><span class="hljs-comment"> * @param w 水平线的长度</span><br><span class="hljs-comment"> * @Note 关联方法 setDrawColor</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawHLine</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">u8g2_uint_t</span> w)</span><br></code></pre></td></tr></table></figure><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置</li></ul><p><strong>u8g2.drawLine() —— 两点之间绘制线</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制线，从坐标(x0,y0) 到(x1,y1)</span><br><span class="hljs-comment"> * @param x0 端点0的x坐标</span><br><span class="hljs-comment"> * @param y0 端点0的y坐标</span><br><span class="hljs-comment"> * @param x1 端点1的x坐标</span><br><span class="hljs-comment"> * @param y1 端点1的y坐标</span><br><span class="hljs-comment"> * @Note 关联方法 setDrawColor</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawLine</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x0, <span class="hljs-type">u8g2_uint_t</span> y0, <span class="hljs-type">u8g2_uint_t</span> x1, <span class="hljs-type">u8g2_uint_t</span> y1)</span><br></code></pre></td></tr></table></figure><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.drawLine(<span class="hljs-number">20</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">32</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128101856376.png"></p><p><strong>u8g2.drawPixel() —— 绘制像素点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制像素点，坐标(x,y)</span><br><span class="hljs-comment"> * @param x 像素点的x坐标</span><br><span class="hljs-comment"> * @param y 像素点的y坐标</span><br><span class="hljs-comment"> * @Note 关联方法 setDrawColor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawPixel</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y)</span><br></code></pre></td></tr></table></figure><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>你会发现很多绘制方法的底层都是调用drawPixel，毕竟像素属于最小颗粒度；</li><li>我们可以利用这个绘制方法自定义自己的图形显示；</li></ul><p><strong>u8g2.drawRBox() —— 绘制圆角实心方形</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制圆角实心方形，左上角坐标为(x,y),宽度为w，高度为h，圆角半径为r</span><br><span class="hljs-comment"> * @param x 左上角的x坐标</span><br><span class="hljs-comment"> * @param y 左上角的y坐标</span><br><span class="hljs-comment"> * @param w 方形的宽度</span><br><span class="hljs-comment"> * @param h 方形的高度</span><br><span class="hljs-comment"> * @param r 圆角半径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawRBox</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">u8g2_uint_t</span> w, <span class="hljs-type">u8g2_uint_t</span> h, <span class="hljs-type">u8g2_uint_t</span> r)</span><br></code></pre></td></tr></table></figure><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>要求，w &gt;&#x3D; 2*(r+1) 并且 h &gt;&#x3D; 2*(r+1)，这是显而易见的限制；</li></ul><p><strong>u8g2.drawRFrame() —— 绘制圆角空心方形</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制圆角空心方形，左上角坐标为(x,y),宽度为w，高度为h，圆角半径为r</span><br><span class="hljs-comment"> * @param x 左上角的x坐标</span><br><span class="hljs-comment"> * @param y 左上角的y坐标</span><br><span class="hljs-comment"> * @param w 方形的宽度</span><br><span class="hljs-comment"> * @param h 方形的高度</span><br><span class="hljs-comment"> * @param r 圆角半径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawRFrame</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">u8g2_uint_t</span> w, <span class="hljs-type">u8g2_uint_t</span> h, <span class="hljs-type">u8g2_uint_t</span> r)</span><br></code></pre></td></tr></table></figure><ul><li>如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；</li><li>要求，w &gt;&#x3D; 2*(r+1) 并且 h &gt;&#x3D; 2*(r+1)，这是显而易见的限制</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.drawRFrame(<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">30</span>,<span class="hljs-number">22</span>,<span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128102053087.png"></p><p><strong>u8g2.drawStr() —— 绘制字符串</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制字符串</span><br><span class="hljs-comment"> * @param x 左上角的x坐标</span><br><span class="hljs-comment"> * @param y 左上角的y坐标</span><br><span class="hljs-comment"> * @param s 绘制字符串内容</span><br><span class="hljs-comment"> * @return 字符串的长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u8g2_uint_t</span> <span class="hljs-title function_">U8g2::drawStr</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> <br></code></pre></td></tr></table></figure><ul><li>需要先设置字体，调用setFont方法；</li><li>这个方法不能绘制encoding超过256的，超过256需要用drawUTF8或者drawGlyph；说白了就是一般用来显示英文字符；</li><li>x，y属于字符串左下角的坐标；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.setFont(u8g2_font_ncenB14_tr);<br>u8g2.drawStr(<span class="hljs-number">0</span>,<span class="hljs-number">15</span>,<span class="hljs-string">&quot;Hello World!&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128102210927.png"></p><p> <strong>u8g2.drawTriangle() —— 绘制实心三角形</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制实心三角形，定点坐标分别为(x0,y0),(x1,y1),(x2,y2)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawTriangle</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> x0, <span class="hljs-type">int16_t</span> y0, <span class="hljs-type">int16_t</span> x1, <span class="hljs-type">int16_t</span> y1, <span class="hljs-type">int16_t</span> x2, <span class="hljs-type">int16_t</span> y2)</span> <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.drawTriangle(<span class="hljs-number">20</span>,<span class="hljs-number">5</span>, <span class="hljs-number">27</span>,<span class="hljs-number">50</span>, <span class="hljs-number">5</span>,<span class="hljs-number">32</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128102312040.png"></p><p><strong>u8g2.drawUTF8() —— 绘制UTF8编码的字符</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制UTF8编码的字符串</span><br><span class="hljs-comment"> * @param x 字符串在屏幕上的左下角x坐标</span><br><span class="hljs-comment"> * @param y 字符串在屏幕上的左下角y坐标</span><br><span class="hljs-comment"> * @param s 需要绘制的UTF-8编码字符串</span><br><span class="hljs-comment"> * @return 返回字符串的长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u8g2_uint_t</span> <span class="hljs-title function_">U8g2::drawUTF8</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span><br></code></pre></td></tr></table></figure><ul><li>使用该方法，有两个前提。首先是你的编译器需要支持UTF-8编码，对于绝大部分Arduino板子已经支持；其次，显示的字符串需要存为“UTF-8”编码，Arduino IDE上默认支持；</li><li>该方法需要依赖于fontMode（setFont）以及drawing Color，也就是说如果你传进来的字符串编码必须在font定义里面；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.setFont(u8g2_font_unifont_t_symbols);<br>u8g2.drawUTF8(<span class="hljs-number">5</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Snowman: ☃&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128102428232.png"></p><p><strong>u8g2.drawVLine() —— 绘制竖直线</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制竖直线</span><br><span class="hljs-comment"> * @param x 左上角坐标x</span><br><span class="hljs-comment"> * @param y 左上角坐标y</span><br><span class="hljs-comment"> * @param h 高度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawVLine</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">u8g2_uint_t</span> h)</span> <br></code></pre></td></tr></table></figure><p><strong>u8g2.drawXBM()&#x2F;drawXBMP() —— 绘制图像</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制图像</span><br><span class="hljs-comment"> * @param x 左上角坐标x</span><br><span class="hljs-comment"> * @param y 左上角坐标y</span><br><span class="hljs-comment"> * @param w 图形宽度</span><br><span class="hljs-comment"> * @param h 图形高度</span><br><span class="hljs-comment"> * @param bitmap 图形内容</span><br><span class="hljs-comment"> * @Note 关联方法 setBitmapMode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawXBM</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">u8g2_uint_t</span> w, <span class="hljs-type">u8g2_uint_t</span> h, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *bitmap)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::drawXBMP</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y, <span class="hljs-type">u8g2_uint_t</span> w, <span class="hljs-type">u8g2_uint_t</span> h, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *bitmap)</span> <br></code></pre></td></tr></table></figure><ul><li>drawXBM和drawXBMP区别在于 XBMP支持PROGMEM</li></ul><p><strong>u8g2.firstPage()&#x2F;nextPage() —— 绘制命令</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制图像</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::firstPage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">U8G2::nextPage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li><p>firstPage方法会把当前页码位置变成0；</p></li><li><p>修改内容处于firstPage和nextPage之间，每次都是重新渲染所有内容；</p></li><li><p>该方法消耗的ram空间，比sendBuffer消耗的ram空间要少；</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.firstPage();<br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-comment">/* all graphics commands have to appear within the loop body. */</span>    <br>  u8g2.setFont(u8g2_font_ncenB14_tr);<br>  u8g2.drawStr(<span class="hljs-number">0</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125; <span class="hljs-keyword">while</span> ( u8g2.nextPage() );<br></code></pre></td></tr></table></figure><p><strong>u8g2.print() —— 绘制内容</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制内容</span><br><span class="hljs-comment"> * @Note 关联方法  setFont setCursor enableUTF8Print</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::print</span><span class="hljs-params">(...)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.setFont(u8g2_font_ncenB14_tr);<br>u8g2.setCursor(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>);<br>u8g2.print(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128102714955.png"></p><p><strong>u8g2.sendBuffer() —— 绘制缓冲区的内容</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 绘制缓冲区的内容</span><br><span class="hljs-comment"> * @Note 关联方法  clearBuffer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::sendBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>sendBuffer的RAM占用空间大，需要结合构造器的buffer选项使用；</li><li>不管是fistPage、nextPage还是sendBuffer，都涉及到一个叫做 current page position的概念；</li></ul><hr><p><strong>显示配置相关函数</strong></p><p> <strong>u8g2.getAscent() —— 获取基准线以上的高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取基准线以上的高度</span><br><span class="hljs-comment"> * @return 返回高度值</span><br><span class="hljs-comment"> * @Note 关联方法  setFont getDescent setFontRefHeightAll</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int8_t</span> <span class="hljs-title function_">U8G2::getAscent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>跟字体有关（setFont）</li></ul><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128102918760.png"></p><p> <strong>u8g2.getDescent() —— 获取基准线以下的高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取基准线以下的高度</span><br><span class="hljs-comment"> * @return 返回高度值</span><br><span class="hljs-comment"> * @Note 关联方法  setFont setFontRefHeightAll</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int8_t</span> <span class="hljs-title function_">U8G2::getDescent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>跟字体有关（setFont）；</li></ul><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128103042786.png"></p><p><strong>u8g2.getDisplayHeight() —— 获取显示器的高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取显示器的高度</span><br><span class="hljs-comment"> * @return 返回高度值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u8g2_uint_t</span> <span class="hljs-title function_">getDisplayHeight</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p><strong>u8g2.getDisplayWidth() —— 获取显示器的宽度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取显示器的宽度</span><br><span class="hljs-comment"> * @return 返回宽度值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u8g2_uint_t</span> <span class="hljs-title function_">getDisplayWidth</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p><strong>u8g2.getMaxCharHeight() —— 获取当前字体里的最大字符的高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取当前字体里的最大字符的高度</span><br><span class="hljs-comment"> * @return 返回高度值</span><br><span class="hljs-comment"> * @Note 关联方法 setFont</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u8g2_uint_t</span> <span class="hljs-title function_">getMaxCharHeight</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>每一个字符在font字集中都是一个位图，位图有高度和宽度；</li></ul><p><strong>u8g2.getMaxCharWidth() —— 获取当前字体里的最大字符的宽度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取当前字体里的最大字符的宽度</span><br><span class="hljs-comment"> * @return 返回宽度值</span><br><span class="hljs-comment"> * @Note 关联方法 setFont</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u8g2_uint_t</span> <span class="hljs-title function_">getMaxCharWidth</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p><strong>u8g2.getStrWidth() —— 获取字符串的像素宽度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取字符串的像素宽度</span><br><span class="hljs-comment"> * @param s 绘制字符串</span><br><span class="hljs-comment"> * @return 返回字符串的像素宽度值</span><br><span class="hljs-comment"> * @Note 关联方法 setFont drawStr</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u8g2_uint_t</span> <span class="hljs-title function_">U8G2::getStrWidth</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span><br></code></pre></td></tr></table></figure><ul><li>像素宽度和当前font字体有关；</li></ul><p><strong>u8g2.getUTF8Width() —— 获取UTF-8字符串的像素宽度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取UTF-8字符串的像素宽度</span><br><span class="hljs-comment"> * @param s 绘制字符串</span><br><span class="hljs-comment"> * @return 返回字符串的像素宽度值</span><br><span class="hljs-comment"> * @Note 关联方法 setFont drawStr</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u8g2_uint_t</span> <span class="hljs-title function_">U8G2::getUTF8Width</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span><br></code></pre></td></tr></table></figure><p><strong>u8g2.setAutoPageClear() —— 设置自动清除缓冲区</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 是否自动清除缓冲区</span><br><span class="hljs-comment"> * @param mode 0 表示关闭</span><br><span class="hljs-comment"> *             1 表示开启，默认是开启</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setAutoPageClear</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> mode)</span><br></code></pre></td></tr></table></figure><ul><li>该方法用于 firstPage 和 nextPage；</li><li>建议该方法保持默认就好，如果用户禁止了，那么需要自己维护缓冲区的状态或者手动调用clearBuffer；</li></ul><p><strong>u8g2.setBitmapMode() —— 设置位图模式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置位图模式（定义drawXBM方法是否绘制背景颜色）</span><br><span class="hljs-comment"> * @param is_transparent</span><br><span class="hljs-comment"> *         0 绘制背景颜色，不透明，默认是该值</span><br><span class="hljs-comment"> *         1 不绘制背景颜色，透明</span><br><span class="hljs-comment"> * @Note 关联方法 drawXBM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setBitmapMode</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> is_transparent)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.setDrawColor(<span class="hljs-number">1</span>);<br>u8g2.setBitmapMode(<span class="hljs-number">0</span>);<br>u8g2.drawXBM(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>, u8g2_logo_97x51_width, u8g2_logo_97x51_height,  u8g2_logo_97x51_bits);<br>u8g2.drawXBM(<span class="hljs-number">12</span>,<span class="hljs-number">11</span>, u8g2_logo_97x51_width, u8g2_logo_97x51_height,  u8g2_logo_97x51_bits);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128155738230.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.setDrawColor(<span class="hljs-number">1</span>);<br>u8g2.setBitmapMode(<span class="hljs-number">1</span>);<br>u8g2.drawXBM(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>, u8g2_logo_97x51_width, u8g2_logo_97x51_height,  u8g2_logo_97x51_bits);<br>u8g2.drawXBM(<span class="hljs-number">12</span>,<span class="hljs-number">11</span>, u8g2_logo_97x51_width, u8g2_logo_97x51_height,  u8g2_logo_97x51_bits);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128155823179.png"></p><p><strong>u8g2.setBusClock() —— 设置总线时钟</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置总线时钟(I2C SPI)</span><br><span class="hljs-comment"> * @param mode clock_speed 总线时钟频率(Hz)</span><br><span class="hljs-comment"> * @Note 关联方法 begin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setBusClock</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> clock_speed)</span>;<br></code></pre></td></tr></table></figure><ul><li>仅仅Arduino平台支持；</li><li>必须在u8g2.begin() 或者 u8g2.initDisplay()之前调用；</li></ul><p><strong>u8g2.setClipWindow() —— 设置采集窗口大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置采集窗口，窗口范围从左上角(x0,y0)到右下角(x1,y1)</span><br><span class="hljs-comment"> * 也就是我们绘制的内容只能在规范范围内显示</span><br><span class="hljs-comment"> * @param x0 左上角x坐标</span><br><span class="hljs-comment"> * @param y0 左上角y坐标</span><br><span class="hljs-comment"> * @param x1 右上角x坐标</span><br><span class="hljs-comment"> * @param y1 右上角y坐标</span><br><span class="hljs-comment"> * @Note 关联方法 begin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setClipWindow</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x0, <span class="hljs-type">u8g2_uint_t</span> y0, <span class="hljs-type">u8g2_uint_t</span> x1, <span class="hljs-type">u8g2_uint_t</span> y1 )</span>;<br></code></pre></td></tr></table></figure><ul><li>可以通过 setMaxClipWindow 去掉该限制</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setMaxClipWindow</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.setClipWindow(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">85</span>, <span class="hljs-number">30</span>);<br>u8g2.setDrawColor(<span class="hljs-number">1</span>);<br>u8g2.drawStr(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&quot;U8g2&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128160031656.png"></p><p><strong>u8g2.setCursor() —— 设置绘制光标位置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置绘制光标位置(x,y)</span><br><span class="hljs-comment"> * @Note 关联方法 print</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setCursor</span><span class="hljs-params">(<span class="hljs-type">u8g2_uint_t</span> x, <span class="hljs-type">u8g2_uint_t</span> y)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.setFont(u8g2_font_ncenB14_tr);<br>u8g2.setCursor(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>);<br>u8g2.print(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128160123258.png"></p><p><strong>u8g2.setDisplayRotation() —— 设置显示器的旋转角度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置显示器的旋转角度</span><br><span class="hljs-comment"> * @param u8g2_cb 旋转选项</span><br><span class="hljs-comment"> *        U8G2_R0 不做旋转 水平</span><br><span class="hljs-comment"> *        U8G2_R1 旋转90度</span><br><span class="hljs-comment"> *        U8G2_R2 旋转180度</span><br><span class="hljs-comment"> *        U8G2_R3 旋转270度</span><br><span class="hljs-comment"> *        U8G2_MIRROR 不做旋转 水平，显示内容是镜像的，暂时不理解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setDisplayRotation</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">u8g2_cb_t</span> *u8g2_cb)</span><br></code></pre></td></tr></table></figure><p><strong>u8g2.setDrawColor() —— 设置绘制颜色</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置绘制颜色（暂时还没有具体去了解用法）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setDrawColor</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> color)</span><br></code></pre></td></tr></table></figure><p><strong>u8g2.setFont() —— 设置字体集</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置字体集（字体集用于字符串绘制方法或者glyph绘制方法）</span><br><span class="hljs-comment"> * @param font 具体的字体集</span><br><span class="hljs-comment"> * @Note 关联方法  drawUTF8 drawStr drawGlyph print</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setFont</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *font)</span><br></code></pre></td></tr></table></figure><ul><li>中文字符集消耗内存大，请谨慎使用，可以用在Arduino 101等ram空间比较大的板子上；</li></ul><p><strong>u8g2.setFontDirection() —— 设置字体方向</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义字符串绘制或者图形绘制的方向</span><br><span class="hljs-comment"> * @param dir 方向</span><br><span class="hljs-comment"> * @param 关联方法 drawStr</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setFontDirection</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dir)</span><br></code></pre></td></tr></table></figure><ul><li>dir参数</li></ul><table><thead><tr><th>Argument</th><th>String Rotation</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0 degree</td><td>Left to right</td></tr><tr><td>1</td><td>90 degree</td><td>Top to down</td></tr><tr><td>2</td><td>180 degree</td><td>Right to left</td></tr><tr><td>3</td><td>270 degree</td><td>Down to top</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.setFont(u8g2_font_ncenB14_tf);<br>u8g2.setFontDirection(<span class="hljs-number">0</span>);<br>u8g2.drawStr(<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Abc&quot;</span>);<br>u8g2.setFontDirection(<span class="hljs-number">1</span>);<br>u8g2.drawStr(<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Abc&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128161138011.png"></p><hr><p><strong>缓存相关函数</strong></p><p>缓存相关函数，一般不会去操作</p><p><strong>u8g2.getBufferPtr() —— 获取缓存空间的地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取缓存空间的地址</span><br><span class="hljs-comment"> * @return 返回缓存空间起始地址</span><br><span class="hljs-comment"> * @Note 关联方法 getBufferTileHeight, getBufferTileWidth, clearBuffer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">uint8_t</span> *<span class="hljs-title function_">U8G2::getBufferPtr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>缓存大小等于 8 * u8g2.getBufferTileHeight() * u8g2.getBufferTileWidth().</li></ul><p><strong>u8g2.getBufferTileHeight() —— 获取缓冲区的Tile高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取缓冲区的Tile高度</span><br><span class="hljs-comment"> * @return 返回高度值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">U8G2::getBufferTileHeight</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>一个tile等于8个像素点.</li></ul><p><strong>u8g2.getBufferTileWidth() —— 获取缓冲区的Tile宽度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取缓冲区的Tile宽度</span><br><span class="hljs-comment"> * @return 返回宽度值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">U8G2::getBufferTileWidth</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p><strong>u8g2.getBufferCurrTileRow() —— 获取缓冲区的当前Tile row</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取缓冲区的当前Tile row行数</span><br><span class="hljs-comment"> * @return 返回当前的tilerow</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">U8G2::getBufferCurrTileRow</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p> <strong>u8g2.setBufferCurrTileRow() —— 设置缓冲区的当前Tile row</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置缓冲区的当前Tile row</span><br><span class="hljs-comment"> * @param 当前的tilerow</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">U8G2::setBufferCurrTileRow</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>  row)</span><br></code></pre></td></tr></table></figure><ul><li>在 firstPage&#x2F;nextPage 循环时，由于底层调用了setBufferCurrTileRow，所以尽量不要自己手动调用该方法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">u8g2.setBufferCurrTileRow(<span class="hljs-number">0</span>);       <span class="hljs-comment">// let y=0 be the topmost row of the buffer</span><br>u8g2.clearBuffer();<br>u8g2.setFont(u8g2_font_helvB08_tr);<br>u8g2.drawStr(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&quot;abcdefg&quot;</span>);<br><br>u8g2.setBufferCurrTileRow(<span class="hljs-number">2</span>);<span class="hljs-comment">// write the buffer to tile row 2 (y=16) on the display</span><br>u8g2.sendBuffer();<br>u8g2.setBufferCurrTileRow(<span class="hljs-number">4</span>);<span class="hljs-comment">// write the same buffer to tile row 4 (y=32) on the display</span><br>u8g2.sendBuffer();<br></code></pre></td></tr></table></figure><p><img src="/imgs/u8g2%E5%AD%A6%E4%B9%A0/image-20241128162439123.png"></p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>u8g2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体内存对齐</title>
    <link href="/2024/11/27/data_struct_memory_alignment/"/>
    <url>/2024/11/27/data_struct_memory_alignment/</url>
    
    <content type="html"><![CDATA[<!-- <!-- data_struct_memory_alignment--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/127718501?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;127718501?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h3><p>我们都知道，定义的变量（元素）是要按照顺序一个一个放到内存中去的，它们也不一定就是紧密排列的，是要按照一定的规则就行排放的，这就是内存对齐。</p><p>对结构体来说，元素的存储从首地址开始，第一个元素的地址和整个结构体的首地址相同，其他的每个元素放置到内存中时，它都会认为内存是按照元素自己的大小来划分空间的，所以元素放置在内存中的位置一定会在元素自己宽度(字节数)的整数倍上开始，这就是所谓的结构体内存对齐问题。</p><h3 id="为什么要有内存对齐"><a href="#为什么要有内存对齐" class="headerlink" title="为什么要有内存对齐"></a>为什么要有内存对齐</h3><p>考虑平台的原因。实际的硬件平台跑代码是有所区别的，一些硬件平台可以对任意地址上的任意数据进行访问，而有一些硬件平台就不行，就是有限制，所以内存对齐是一种解决办法。</p><p>考虑性能的原因。CPU访问内存时，如果内存不对齐的话，为了访问到数据的话就需要几次访问，而对齐的内存只需要访问一次即可，提高了CPU访问内存的速度。</p><h3 id="结构体的内存对齐规则是什么"><a href="#结构体的内存对齐规则是什么" class="headerlink" title="结构体的内存对齐规则是什么"></a>结构体的内存对齐规则是什么</h3><p>内存对齐值称为<strong>内存对齐有效值</strong>，这个值可以是1、2、4、8、16</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">规则1，结构体第一个成员一定是放在结构体内存地址里面的第1位。<br><br>规则2，成员对齐规则：除了第一个成员，之后的每个数据成员的对齐要按照成员自身的长度和内存对齐有效值进行比较，按两者中最小的那个进行对齐，即偏移的倍数。<br><br>规则3，结构体整体对齐规则：数据成员完成对齐之后，对整个结构体的大小进行对齐。按照结构体的大小必须要是内存对齐有效值和结构体中最大数据成员长度两者中的最小值的整数倍，不足的在后面补空。<br></code></pre></td></tr></table></figure><h3 id="规则的验证"><a href="#规则的验证" class="headerlink" title="规则的验证"></a>规则的验证</h3><p>编译器内存对齐有效值&#x3D;4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>&#125;StructDef_t;<br></code></pre></td></tr></table></figure><p>首先，a为int型占4个字节，放在最开始的位置，即offset&#x3D;0的位置，放在0、1、2、3的地址。</p><p>然后，用规则2：b占一个字节，内存对齐有效值为4，所以b要相对于结构体首地址的偏移要为1的倍数，放在4的地址。</p><p>最后，从上面的一步我们知道了这个结构体内的成员对齐之后占了五个字节。用规则3：结构体内最大的成员占4个字节，内存对齐有效值为4，所以整个结构体的大小要为4的倍数，5不是4的倍数，所以要在后面补齐，为8个字节。</p><p>所以，最终这个结构体占用8个字节！</p><p><img src="/imgs/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/image-20241127134948894.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">char</span> c2;<br>&#125;Test1;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> c2;<br>&#125;Test2;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">char</span> c2;<br>    <span class="hljs-type">int</span> i;<br>&#125;Test3;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">sizeof</span>(Test1));  <span class="hljs-comment">// 输出8</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">sizeof</span>(Test2));  <span class="hljs-comment">// 输出12</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">sizeof</span>(Test3));  <span class="hljs-comment">// 输出8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <font color=red>注意：从上面的三个结构体中可以发现，通过调换结构体里面的数据成员的位置，可以改变结构体占空间的大小，这是因为数据元素位置不同，对齐之后的结果也不同。这种方式可以用于结构体的空间优化，通过调整元素的位置，减少内存的占用！</font></p><h3 id="自定义内存的对齐值"><a href="#自定义内存的对齐值" class="headerlink" title="自定义内存的对齐值"></a>自定义内存的对齐值</h3><p>C语言中是允许用户自己定义内存对齐值的，使用一个伪指令即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack (n)    <span class="hljs-comment">// 自定义对齐值，n=1,2,4,8,16</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack ( )    <span class="hljs-comment">// 取消自定义字节对齐</span></span><br></code></pre></td></tr></table></figure><h3 id="1-字节对齐"><a href="#1-字节对齐" class="headerlink" title="1 字节对齐"></a>1 字节对齐</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack (1)</span><br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>&#125;StructDef_t;<br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    StructDef_t Test;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a addr = %x\r\n&quot;</span>,&amp;Test.a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b addr = %x\r\n&quot;</span>,&amp;Test.b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;byte = %d\r\n&quot;</span>,<span class="hljs-built_in">sizeof</span>(Test));<br>&#125; <br> <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack ()</span><br></code></pre></td></tr></table></figure><p>在1字节内存对齐情况下，这里的结构体占5个字节！</p><h3 id="2-字节对齐"><a href="#2-字节对齐" class="headerlink" title="2 字节对齐"></a>2 字节对齐</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack (2)</span><br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>&#125;StructDef_t;<br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    StructDef_t Test;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a addr = %x\r\n&quot;</span>,&amp;Test.a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b addr = %x\r\n&quot;</span>,&amp;Test.b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;byte = %d\r\n&quot;</span>,<span class="hljs-built_in">sizeof</span>(Test));<br>&#125; <br> <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack ()</span><br></code></pre></td></tr></table></figure><p>在2字节内存对齐情况下，这里的结构体占6个字节！</p><h3 id="4-字节对齐"><a href="#4-字节对齐" class="headerlink" title="4 字节对齐"></a>4 字节对齐</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack (1)</span><br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>&#125;StructDef_t;<br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    StructDef_t Test;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a addr = %x\r\n&quot;</span>,&amp;Test.a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b addr = %x\r\n&quot;</span>,&amp;Test.b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;byte = %d\r\n&quot;</span>,<span class="hljs-built_in">sizeof</span>(Test));<br>&#125; <br> <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack ()</span><br></code></pre></td></tr></table></figure><p>​    在4字节内存对齐情况下，这里的结构体占8个字节！</p>]]></content>
    
    
    <categories>
      
      <category>DATA_STRUCT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OTA升级</title>
    <link href="/2024/11/27/embedded_ota/"/>
    <url>/2024/11/27/embedded_ota/</url>
    
    <content type="html"><![CDATA[<!-- embedded_ota--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/127706079?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;127706079?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="OTA-在线升级"><a href="#OTA-在线升级" class="headerlink" title="OTA 在线升级"></a>OTA 在线升级</h3><blockquote><p>   OTA：Over-the-Air Technology，字面意思理解为：空中下载技术。</p><p>​    OTA 在线升级：通过OTA的方式实现产品软件更新的一种方式。</p></blockquote><p>​    所以，简单而言，通过外部的方式（有线 &#x2F; 无线）对产品进行更新，而不是用传统的编程器刷入固件的方式就可以称之为 OTA 在线升级。</p><p>​    严格意义上来讲，OTA 指的是空中下载，即只有通过无线的方式进行更新的才称之为 <strong>OTA 升级</strong>；而那种通过外部的接口接线来实现的更新，应该称之为<strong>本地升级</strong>。这两者还是有点区别的，只是一般我们都没有那么严格去区分罢了！</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><blockquote><p>   1）接收新的升级固件并完成新旧固件的替换，这部分代码为 BootLoader；</p><p>​    2）产品功能的正常程序，用于执行各种应用功能，这部分程序称为 App。</p></blockquote><p>那就是说，要实现在线升级，就需要准备两份程序，一份是BootLoader ，另一份是App。其中 bootloader 用于将外部传入的新固件（应用程序App）接收到内部并存储，接收完成以后，由 bootloader 用新接收到的固件去替换旧的固件，替换完成之后跳转到新的应用程序中进行执行。这样就完成了产品的固件更新。</p><h3 id="后台式升级"><a href="#后台式升级" class="headerlink" title="后台式升级"></a>后台式升级</h3><p>​    后台式升级的意思是：在进行升级的时候，接收新固件包的方式是在后台进行的，不会影响功能的正常执行。等到固件更新完成之后，再跳转到Bootloader中去用新的固件替换旧的固件，替换完成之后呢再跳转到App去执行。</p><p>​    比如，现在的智能手机的在线更新就是后台式升级的方式。在你升级系统的时候，接收升级包的过程中，你还是可以正常使用的手机的，打电话、看视频、玩游戏等都不耽误，直到下载完成，你点击了开始更新之后，手机才进入更新状态，不让你操作，等更新完毕之后重启就又可以继续操作了。</p><h3 id="非后台式式更新"><a href="#非后台式式更新" class="headerlink" title="非后台式式更新"></a>非后台式式更新</h3><p>​    非后台式升级的意思是：在进行升级的时候，接收固件时需要跳转到Bootloader，这个时候你不能在使用这个产品的任何功能，只能一直等着它接收并完成更新，完成之后你才能继续操作其他的功能。</p><h3 id="STM32-的在线升级"><a href="#STM32-的在线升级" class="headerlink" title="STM32 的在线升级"></a>STM32 的在线升级</h3><h5 id="划分-Flash-区域"><a href="#划分-Flash-区域" class="headerlink" title="划分 Flash 区域"></a>划分 Flash 区域</h5><p>要准备两份代码的，一份是BootLoader，另外一份是App。由于这两份代码在STM32中都是要存放在Flash中的，而且它们的空间还不能重叠，要独立区分开</p><p><img src="/imgs/OTA%E5%8D%87%E7%BA%A7/image-20241127110913670.png"></p><p>（1）用于存放Bootloader程序；</p><p>（2）用于存放应用程序；</p><p>（3）用于存放接收到的新固件。（注：这部分可要可不要，根据你的设计选择）</p><p><font color=red>注意：上图中（3）这个Flash区域是考虑用于保存在线升级的固件的，作为备份固件。方便用于以后系统出现异常时，可以从这个备份固件中重新加载到App中，防止固件丢失！</font></p><p><strong>1 - Flash空间地址的划分</strong></p><p>​    首先，我们要知道，在stm32中，flash的地址空间是从0x08000000开始的，在keil中也是默认的从这个位置开始的。</p><p>​    一般而言，Bootloader 是在上电时默认开始执行，因此将Bootloader程序可以存放到STM32默认执行的位置（keil编译器默认从0x08000000地址开始存放）。</p><p>​    应用程序从 Bootloader 后开始存放即可，只要不和BootLoader发生冲突即可。</p><p>​    假设 Bootloader 的大小为10k，即0x2800字节，那么可以选取 0x08000000 ~ 0x08002800 地址范围作为BootLoader的存放区域。</p><p>​     应用程序从0x08005000开始存放</p><p><img src="/imgs/OTA%E5%8D%87%E7%BA%A7/image-20241127111133205.png"></p><p><strong>2 - 设置工程</strong></p><p><strong>设置起始地址和大小</strong></p><p>​    准备两个工程，一个是bootloader的程序，另外一个是应用程序的工程，并对工程进行设置。bootloader选择默认执行的位置，应用程序根据实际需要设置开始存放到flash指定的位置。</p><p>比如：App的起始地址设为0x08005000，大小设为0x1B000（RAM总大小0x20000-0x5000）</p><p><img src="/imgs/OTA%E5%8D%87%E7%BA%A7/image-20241127111251647.png"></p><p> BootLoader 也是一样的设置方式，只是地址不同而已。</p><p><strong>生成 bin 文件</strong></p><p>应用程序需要转换为bin文件才可以写入Flash中，能发送到产品中的固件也是要先转为bin格式的文件的</p><p>编译器可以选择生成hex文件，再把hex文件转换为bin文件</p><p>还可以使用简单方法,编译后直接执行fromelf.exe命令将.axf文件转换为.bin文件。生成的bin文件在工程目录下的out文件夹下</p><p><strong>3 - 接收固件更新包</strong></p><p>​    接收固件更新包的话，就要根据你的实际产品进行选择了。</p><p>​    首先，如果你是后台式更新的话，那接收固件更新包的功能就要在App中实现；如果你是非后台式更新的话，那接收固件更新包的功能就要在BootLoader中实现。</p><p>​    其次，要考虑接收固件更新包的方式。无线的话用的是wifi、蓝牙、4&#x2F;5G网络还是啥的；有线的话用的是串口UART、Spi、IIC、CAN、以太网还是啥的。</p><p>​    最后，最好的方式是能够对接收到的固件更新包做一个校验，防止数据接收过程中出现错误，导致升级后出现严重问题。</p><p>​    <font color=red>注意：BootLoader 需要提前刷入，不然无法完成在线升级！</font></p><p><strong>4 - 拷贝程序至Flash</strong></p><p>​    接收成功固件包之后，需要将数据写入到 Flash 的指定位置（比如 0x08005000）完成固件的更新程序写入。</p><p>​    STM32对Flash的操作过程如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">1） Flash解锁。（FlashUnclock）<br>2） 擦除<span class="hljs-keyword">App</span>所在的Flash页。<br>3） 向<span class="hljs-keyword">App</span>的Flash区域写入数据。<br>4） 写完后，Flash上锁。（FlashClock）<br></code></pre></td></tr></table></figure><p><strong>5 - 跳转至 App 应用程序</strong></p><p>​    将接收到应用程序全部正确写入Flash的App指定位置后，<strong>Bootloader</strong> 需要完成跳转到应用程序App的开始位置的操作。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>）关闭中断，防止在跳转过程中有中断发生。<br><span class="hljs-attribute">2</span>）获取栈指针。<br><span class="hljs-attribute">3</span>）获取复位向量，即为栈指针后的四字节内容（<span class="hljs-number">32</span>bits）。<br><span class="hljs-attribute">4</span>）重定向中断向量表，以保证应用程序中中断的正常工作。应用程序从<span class="hljs-number">0</span>x08005000存储，因此相对于Flash基地址<span class="hljs-number">0</span>x08000000偏移了<span class="hljs-number">0</span>x5000。<br><span class="hljs-attribute">5</span>）设置新的栈指针，上述中所获取的栈指针。<br><span class="hljs-attribute">6</span>）跳转至复位向量开始运行。<br></code></pre></td></tr></table></figure><p><strong>特别注意 - 设置向量中断表偏移</strong></p><p>​    这个跳转到用程序之后，有一个非常重要的事情要注意，就是要重新设置App的中断向量表，否则不能正常运行的。</p><p><img src="/imgs/OTA%E5%8D%87%E7%BA%A7/image-20241127112701182.png"></p><p>STM32的内部闪存（FLASH）的地址默认是从0x8000000开始的，默认也是从这个位置开始执行程序的。并且在STM32的内部有一张 “中断向量表” 用于响应中断，程序在启动以后首先会从中断向量表取出复位中断程序，执行完复位中断程序以后才会跳转到main( )函数开始执行。</p><p>​    中断向量表的位置从0x8000004开始，如果采用的是bootloader和应用程序的方式的话，bootloader一般放在默认开始的位置，所以它的中断向量表还是正确的。</p><p>​    而APP应用程序是放置在其他的位置，那么APP应用程序部分的中断向量表就要发生偏移，才能为应用程序找到并响应中断。</p><p>在应用程序中，与程序跳转需要注意的是，单片机从Bootloader程序跳转至应用程序的复位向量处开始执行，单片机在执行main函数之前会执行一些系统初始化程序</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ota</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模数转换</title>
    <link href="/2024/11/26/embedded_adc/"/>
    <url>/2024/11/26/embedded_adc/</url>
    
    <content type="html"><![CDATA[<!-- embedded_adc--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/127599971?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;127599971?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="理解模拟信号-数字信号"><a href="#理解模拟信号-数字信号" class="headerlink" title="理解模拟信号 &amp; 数字信号"></a>理解模拟信号 &amp; 数字信号</h3><p><strong>模拟信号：</strong>模拟信号是指信息参数在给定范围内表现为连续的信号</p><p>在一段连续的时间间隔内，其代表信息的特征量可以在任意瞬间呈现为任意数值（变动的）的信号。像那些<strong>电压&#x2F;电流与声音</strong>这些都是模拟信号。</p><p><strong>数字信号：</strong>数字信号指信号幅度的取值是离散的，幅值范围被限制在有限个数值之内</p><p>二进制就是一种数字信号。大多数情况下，二进制码受噪声的影响小，易于由数字电路进行处理，所以现在也是被广泛的应用在很多的产品和领域中</p><h3 id="ADC-DAC"><a href="#ADC-DAC" class="headerlink" title="ADC &amp; DAC"></a>ADC &amp; DAC</h3><p> ADC英文名称 - Analog-to-Digital Converter（模数转换器），从字面理解，A 称为模拟信号（Analog signal），D 称为数字信号（digital signal）。</p><p> A&#x2F;D 转换器也就是把模拟信号（A）转换成数字信号（D）的器件。</p><p>DAC英文名称- Digital-to- Analog Converter（数模转换器），D&#x2F;A 转换器刚好与 A&#x2F;D 功能相反，它是把数字信号（D）转换为模拟信号（A）。</p><h3 id="常用ADC-种类介绍"><a href="#常用ADC-种类介绍" class="headerlink" title="常用ADC 种类介绍"></a>常用ADC 种类介绍</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>．逐次逼近型<br><span class="hljs-number">2</span>．积分型 <span class="hljs-keyword">ADC</span><br><span class="hljs-number">3</span>. 压频变换型 <span class="hljs-keyword">ADC</span><br> <br>说明：<br>逐次逼近型、积分型、压频变换型等，主要应用于中速或较低速、中等精度的数据采集和智能仪器中。<br></code></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-number">1.</span>流水线型 <span class="hljs-keyword">ADC</span><br> <br>说明：<br>流水线型 <span class="hljs-keyword">ADC</span>主要应用于高速情况下的瞬态信号处理、快速波形存储与记录等领域。<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>.∑-Δ 型 <span class="hljs-keyword">ADC</span><br> <br>说明：<br>∑-Δ 型 <span class="hljs-keyword">ADC</span> 主应用于高精度数据采集特别是数字音响系统、多媒体、地震勘探仪器、声纳等电子测量领域。<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>．并行比较 <span class="hljs-selector-tag">A</span>/D 转换器<br></code></pre></td></tr></table></figure><h3 id="ADC-的工作原理"><a href="#ADC-的工作原理" class="headerlink" title="ADC 的工作原理"></a>ADC 的工作原理</h3><p>在芯片内，模拟信号传输进去的时候，通过和芯片内部的模拟信号部件进行比对之后，从而转换为数字信号保存到数字信号寄存器中，从而把一段模拟信号用数字的方式表达出来（0和1）的方式表达出来。</p><p>逐次逼近型模数转换器原理框图</p><p><img src="/imgs/%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2/image-20241126162947795.png"></p><p>Ui为需要进行转换的模拟量，Uo为AD比较器的输出电压，通过AD转换器的逐渐比较不断的逼近Ui，最终得到一个与Ui匹配的数字值。（注意：AD转换一般都是需要一个参考电压 Vrf 的）</p><p>逐次逼近型 A&#x2F;D 转换器，就是将输入模拟信号与不同的参考电压作多次比较，使转换所得的数字量在数值上逐次逼近输入模拟量对应值。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">1）转换开始前先将所有寄存器清零。<br>2）开始转换以后，时钟脉冲首先将寄存器最高位置成 1，使输出数字为 100…0。<br>   这个数被数模转换器转换成相应的模拟电压 Uo，送到比较器中与 Ui 进行比较。<br>   若 Uo＞Ui，说明数字过大了，故将最高位的<span class="hljs-number"> 1 </span>清除；<br>   若 Uo＜Ui ，说明数字还不够大，应将最高位的<span class="hljs-number"> 1 </span>保留。<br>3）反复如此，再按同样的方式将次高位置成 1，并且经过比较以后确定这个<span class="hljs-number"> 1 </span>是否应该保留。<br>4）最终就可以得到一个逼近Ui的数值。<br></code></pre></td></tr></table></figure><p>逐次逼近型ADC的工作流程</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">（1）采样<br>（2）保持<br>（3）量化<br></code></pre></td></tr></table></figure><h3 id="STM32的ADC的介绍"><a href="#STM32的ADC的介绍" class="headerlink" title="STM32的ADC的介绍"></a>STM32的ADC的介绍</h3><p>​    目前市场上流行的单片机几乎都有ADC功能，精度有高有低，使用的较多的，当属STM32了。下面以STM32F1为例。</p><p>​    STM32F1的ADC是12位的逐次逼近型的模数转换器。</p><p>​    它的AD的基本特点:</p><h5 id="STM32F1的-ADC-开关控制"><a href="#STM32F1的-ADC-开关控制" class="headerlink" title="STM32F1的 ADC 开关控制"></a>STM32F1的 ADC 开关控制</h5><p>​    通过设置ADC_CR2寄存器的ADON位可给ADC上电。当第一次设置ADON位时，它将ADC从断电状态下唤醒。</p><p>​    ADC上电延迟一段时间后(t STAB )，再次设置ADON位时开始进行转换。通过清除ADON位可以停止转换，并将ADC置于断电模式。在这个模式中，ADC几乎不耗电(仅几个μA)。</p><h5 id="STM32F1的-ADC-时钟"><a href="#STM32F1的-ADC-时钟" class="headerlink" title="STM32F1的 ADC 时钟"></a>STM32F1的 ADC 时钟</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">由时钟控制器提供的ADCCLK时钟和<span class="hljs-built_in">PCLK2</span>(APB2时钟)同步。<br>RCC控制器为ADC时钟提供一个专用的可编程预分频器。<br></code></pre></td></tr></table></figure><h5 id="STM32F1的-ADC-通道"><a href="#STM32F1的-ADC-通道" class="headerlink" title="STM32F1的 ADC 通道"></a>STM32F1的 ADC 通道</h5><p>​    有16个多路通道。可以把转换组织成两组：规则组和注入组。在任意多个通道上以任意顺序进行的一系列转换构成成组转换。例如，可以如下顺序完成转换：通道3、通道8、通道2、通道2、通道0、通道2、通道2、通道15。</p><p>​    如果ADC_SQRx或ADC_JSQR寄存器在转换期间被更改，当前的转换被清除，一个新的启动脉冲将发送到ADC以转换新选择的组。</p><h5 id="ADC转换模式"><a href="#ADC转换模式" class="headerlink" title="ADC转换模式"></a>ADC转换模式</h5><p> 1）单次转换模式下，ADC只执行一次转换。该模式既可通过设置ADC_CR2寄存器的ADON位(只适用于规则通道)启动也可通过外部触发启动(适用于规则通道或注入通道)，这时CONT位为0。</p><p>2）在连续转换模式中，当前面ADC转换一结束马上就启动另一次转换。此模式可通过外部触发启动或通过设置ADC_CR2寄存器上的ADON位启动，此时CONT位是1。</p><h5 id="ADC校准"><a href="#ADC校准" class="headerlink" title="ADC校准"></a>ADC校准</h5><p>​    ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。在校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差。</p><p>​    通过设置ADC_CR2寄存器的CAL位启动校准。一旦校准结束，CAL位被<a href="https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782?utm_source=glcblog&spm=1001.2101.3001.7020">硬件</a>复位，可以开始正常转换。建议在上电时执行一次ADC校准。校准阶段结束后，校准码储存在ADC_DR中。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>建议在每次上电后执行一次校准。<br><span class="hljs-symbol">2 </span>启动校准前， ADC 必须处于关电状态 (ADON=’<span class="hljs-number">0</span>’) 超过至少两个 ADC 时钟周期。<br></code></pre></td></tr></table></figure><h5 id="ADC通道的采样时间"><a href="#ADC通道的采样时间" class="headerlink" title="ADC通道的采样时间"></a>ADC通道的采样时间</h5><p>​    ADC使用若干个ADC_CLK周期对输入电压采样，采样周期数目可以通过ADC_SMPR1和ADC_SMPR2寄存器中的SMP[2:0]位更改。每个通道可以分别用不同的时间采样。</p><p>总转换时间 </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">T</span> CONV = 采样时间+ <span class="hljs-number">12</span>.<span class="hljs-number">5</span>个周期<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">当<span class="hljs-attribute">ADCCLK</span>=14MHz，采样时间为1.5周期<br> <br>T CONV = 1.5 + 12.5 = 14周期 = 1μs<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>adc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构—双向链表</title>
    <link href="/2024/11/26/data_struct_bidirectional_linked/"/>
    <url>/2024/11/26/data_struct_bidirectional_linked/</url>
    
    <content type="html"><![CDATA[<!-- data_struct_bidirectional_linked--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/127090511?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;127090511?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表和单向链表相比，最大的不同是指针域中多了一个指向前一个节点的地址域。这样一来，双向链表中的每个节点就保存了前后节点的地址，从而通过地址形成一条链式的存储结构。</p><p> 双向链表的最大便利之处在于查询链表时不仅可以正向查找也可以反向查找，甚至如果当前查询的位置在链表中间的位置的时候，可以反方向两头查找，提高查找的速度和效率，增加了便利。</p><h3 id="双向不循环链表"><a href="#双向不循环链表" class="headerlink" title="双向不循环链表"></a>双向不循环链表</h3><p>双向不循环链表是头结点的前一个指针指向头结点自身，尾节点的后一个指针指向为NULL</p><p><img src="/imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/image-20241126161306329.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br> <br> <br><span class="hljs-comment">/*** 定义链表操作的位置：开头、中间、结尾 ***/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>Head = <span class="hljs-number">1</span>,<br>Middle,<br>End,<br>&#125;Location;<br> <br> <br><span class="hljs-comment">/*** 定义一个链表节点 ******/</span><br><span class="hljs-comment">// 1.定义一个链表节点的数据域。以记录一个苹果的信息为例，为方便说明，假设每个苹果的信息各不相同</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkData_struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span>  weight; <span class="hljs-comment">// 苹果的重量</span><br><span class="hljs-type">int</span>  hight;  <span class="hljs-comment">// 苹果的高度</span><br><span class="hljs-comment">// ...  // 还可以定义更多的其他的数据</span><br>&#125;LinkData_t;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span></span><br><span class="hljs-class">&#123;</span><br>LinkData_t data;<span class="hljs-comment">// 链表节点的数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span> *<span class="hljs-title">Prev</span>;</span> <span class="hljs-comment">// 链表节点的上一个节点的指针域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span> *<span class="hljs-title">Next</span>;</span> <span class="hljs-comment">// 链表节点的下一个节点的指针域</span><br>&#125;LinkNode_t;<br> <br> <br><span class="hljs-comment">/*** 定义一个单向链表的头结点 ***/</span><br>LinkNode_t AppleInfo_head; <span class="hljs-comment">//作为单向链表的一个头结点</span><br> <br> <br><span class="hljs-comment">// 初始化单向链表的头结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Init_LinkNode</span><span class="hljs-params">(LinkNode_t * HeadNode)</span><br>&#123;<br>HeadNode-&gt;Next = <span class="hljs-literal">NULL</span>;<br>HeadNode-&gt;Prev = <span class="hljs-literal">NULL</span>;<br>&#125;<br> <br><span class="hljs-comment">// 创建一个链表节点并接入到链表中</span><br>LinkNode_t * <span class="hljs-title function_">LinkNode_Create</span><span class="hljs-params">(LinkNode_t * HeadNode, LinkData_t *InsetData)</span><br>&#123;<br>LinkNode_t *Prev_pf,*Next_pf;<br>LinkNode_t *xReturn = <span class="hljs-literal">NULL</span>;<br>LinkNode_t *Node = (LinkNode_t *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode_t));<br> <br><span class="hljs-keyword">if</span> (Node == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点创建失败！！！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br> <br>Prev_pf = Next_pf = HeadNode;<br><br><span class="hljs-comment">// 第一节点从头结点后面开始插入</span><br><span class="hljs-keyword">if</span> (HeadNode-&gt;Next == <span class="hljs-literal">NULL</span> &amp;&amp; HeadNode-&gt;Prev == <span class="hljs-literal">NULL</span>)<br>&#123;<br>HeadNode-&gt;Next = Node;<br>Node-&gt;Next = <span class="hljs-literal">NULL</span>;<br>Node-&gt;Prev = HeadNode;<br>Node-&gt;data.hight  = InsetData-&gt;hight;<br>Node-&gt;data.weight = InsetData-&gt;weight;<br>xReturn = Node;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">while</span> (Next_pf-&gt;Next != <span class="hljs-literal">NULL</span>)<br>&#123;<br>Next_pf = Next_pf-&gt;Next;<br>&#125;<br>Next_pf-&gt;Next = Node;<br>Node-&gt;Prev = Next_pf;<br>Node-&gt;Next = <span class="hljs-literal">NULL</span>;<br>Node-&gt;data.hight = InsetData-&gt;hight;<br>Node-&gt;data.weight = InsetData-&gt;weight;<br>xReturn = Node;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;完成一个链表节点的创建，地址 = 0x%X\r\n&quot;</span>,xReturn);<br><span class="hljs-keyword">return</span> xReturn;<br>&#125;<br> <br><span class="hljs-comment">// 删除链表中的某个节点,根据weight进行删除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy_LinkNode</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> deleteFlag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf;<br> <br>pf = HeadNode;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-keyword">if</span> (pf-&gt;data.weight == weight)<br>&#123;<br>deleteFlag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != <span class="hljs-literal">NULL</span>);<br> <br><span class="hljs-keyword">if</span> (!deleteFlag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表中找不到这个节点！！！\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (pf-&gt;Next == <span class="hljs-literal">NULL</span>)<br>&#123;<br>pf-&gt;Prev-&gt;Next = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pf-&gt;Prev-&gt;Next = pf-&gt;Next;<br>pf-&gt;Next-&gt;Prev = pf-&gt;Prev; <br>&#125;<br><br><span class="hljs-built_in">free</span>(pf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点weight = %d 销毁成功！\r\n&quot;</span>,weight);<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// 输出显示整条链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>length++;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表输出完成。长度为：%d\r\n&quot;</span>,length);<br>&#125;<br> <br> <br><span class="hljs-comment">// 按条件查询链表中某个节点的数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">search_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> search_flag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-keyword">if</span>(pf-&gt;data.weight == weight)<br>&#123;<br>search_flag = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br>length++;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != <span class="hljs-literal">NULL</span>);<br> <br><span class="hljs-keyword">if</span>(search_flag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表查找结束。所在节点位置为：%d\r\n&quot;</span>,length);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;整个链表中无满足此条件的节点！\r\n&quot;</span>);<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// 查询链表中有几个相同的数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">search_Same_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> search_flag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br>length++;<br><span class="hljs-keyword">if</span>(pf-&gt;data.weight == weight)<br>&#123;<br>search_flag = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这个节点在链表中的位置：%d\r\n&quot;</span>,length);<br>cnt++;<br>&#125;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != <span class="hljs-literal">NULL</span>);<br> <br><span class="hljs-keyword">if</span>(search_flag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表查找结束。相同数据的节点数量为：%d\r\n&quot;</span>,cnt);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;整个链表中无满足此条件的节点！\r\n&quot;</span>);<br>&#125;<br>&#125;<br> <br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">print_debug_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;******** 链表控制台 *****************\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*                                  \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  1：创建链表                      \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  2：删除链表                      \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  3：显示整条链表的数据             \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  4：按条件查找链表节点             \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  5：查找链表中有几个相同数据的节点  \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  8：清空显示                      \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  9：结束运行                      \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*                                  \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;************************************\r\n&quot;</span>);<br>&#125;<br> <br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123;<br><span class="hljs-type">int</span> Num,i,j;<br><span class="hljs-type">int</span> Options;<br><span class="hljs-type">int</span> weight,height;<br>LinkData_t InsetData;<br> <br>Init_LinkNode(&amp;AppleInfo_head);<br> <br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>print_debug_info();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n请输入需要操作的键值，按回车键确认！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Options);<br><span class="hljs-keyword">switch</span> (Options)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-comment">/*** 创建任意长度的链表 **********************************************************/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入需要创建的链表节点的数量,按回车结束！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Num);<br> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入节点的数据：\r\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Num; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入第 %d 节点的数据,weight = Height = ,输入完毕按回车结束！\r\n&quot;</span>,i+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;weight,&amp;height);<br>InsetData.weight = weight;<br>InsetData.hight  = height;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d height = %d\r\n&quot;</span>,weight,height);<br> <br><span class="hljs-keyword">if</span>(LinkNode_Create(&amp;AppleInfo_head, &amp;InsetData) &gt; <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点 %d 创建成功！\r\n\r\n\r\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点 %d 创建失败！\r\n\r\n\r\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-comment">/******* 删除链表中的某个节点 ***************************************************/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入需要删除的链表节点的weight,按回车结束！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Num);<br>destroy_LinkNode(&amp;AppleInfo_head, Num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表数据为：\r\n&quot;</span>);<br>print_LinkNode_Info(&amp;AppleInfo_head);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入需要查找的链表节点的weight,按回车结束！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Num);<br>search_LinkNode_Info(&amp;AppleInfo_head, Num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入需要查找的链表节点的weight,按回车结束！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Num);<br>search_Same_LinkNode_Info(&amp;AppleInfo_head, Num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>system(<span class="hljs-string">&quot;cls&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出链表控制台，请再次运行程序！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无效的键值，请重新输入！\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p>双向循环链表是头结点的前一个指针指向尾结点的地址，尾节点的后一个指针指向头结点的地址所在，从而构成一种链式的循环结构</p><p><img src="/imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/image-20241126161455237.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br> <br> <br><span class="hljs-comment">/*** 定义链表操作的位置：开头、中间、结尾 ***/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>Head = <span class="hljs-number">1</span>,<br>Middle,<br>End,<br>&#125;Location;<br> <br> <br><span class="hljs-comment">/*** 定义一个链表节点 ******/</span><br><span class="hljs-comment">// 1.定义一个链表节点的数据域。以记录一个苹果的信息为例，为方便说明，假设每个苹果的信息各不相同</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkData_struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span>  weight; <span class="hljs-comment">// 苹果的重量</span><br><span class="hljs-type">int</span>  hight;  <span class="hljs-comment">// 苹果的高度</span><br><span class="hljs-comment">// ...  // 还可以定义更多的其他的数据</span><br>&#125;LinkData_t;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span></span><br><span class="hljs-class">&#123;</span><br>LinkData_t data;<span class="hljs-comment">// 链表节点的数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span> *<span class="hljs-title">Prev</span>;</span> <span class="hljs-comment">// 链表节点的上一个节点的指针域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span> *<span class="hljs-title">Next</span>;</span> <span class="hljs-comment">// 链表节点的下一个节点的指针域</span><br>&#125;LinkNode_t;<br> <br> <br><span class="hljs-comment">/*** 定义一个单向链表的头结点 ***/</span><br>LinkNode_t AppleInfo_head; <span class="hljs-comment">//作为单向链表的一个头结点</span><br> <br> <br><span class="hljs-comment">// 初始化单向链表的头结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Init_LinkNode</span><span class="hljs-params">(LinkNode_t * HeadNode)</span><br>&#123;<br>HeadNode-&gt;Next = <span class="hljs-literal">NULL</span>;<br>HeadNode-&gt;Prev = HeadNode;<span class="hljs-comment">// 双向循环链表的头结点的前一个指针指向头结点本身</span><br>&#125;<br> <br><span class="hljs-comment">// 创建一个链表节点并接入到链表中</span><br>LinkNode_t * <span class="hljs-title function_">LinkNode_Create</span><span class="hljs-params">(LinkNode_t * HeadNode, LinkData_t *InsetData)</span><br>&#123;<br>LinkNode_t *Prev_pf,*Next_pf;<br>LinkNode_t *xReturn = <span class="hljs-literal">NULL</span>;<br>LinkNode_t *Node = (LinkNode_t *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode_t));<br> <br><span class="hljs-keyword">if</span> (Node == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点创建失败！！！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br> <br>Prev_pf = Next_pf = HeadNode;<br><br><span class="hljs-comment">// 第一节点从头结点后面开始插入</span><br><span class="hljs-keyword">if</span> (HeadNode-&gt;Next == <span class="hljs-literal">NULL</span> &amp;&amp; HeadNode-&gt;Prev == HeadNode)<br>&#123;<br>HeadNode-&gt;Next = Node;<br>HeadNode-&gt;Prev = Node;<br>Node-&gt;Next = HeadNode;<br>Node-&gt;Prev = HeadNode;<br>Node-&gt;data.hight  = InsetData-&gt;hight;<br>Node-&gt;data.weight = InsetData-&gt;weight;<br>xReturn = Node;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">while</span> (Next_pf-&gt;Next != HeadNode)<br>&#123;<br>Next_pf = Next_pf-&gt;Next;<br>&#125;<br>Next_pf-&gt;Next  = Node;<br>HeadNode-&gt;Prev = Node;<br>Node-&gt;Prev = Next_pf;<br>Node-&gt;Next = HeadNode;<br>Node-&gt;data.hight = InsetData-&gt;hight;<br>Node-&gt;data.weight = InsetData-&gt;weight;<br>xReturn = Node;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;完成一个链表节点的创建，地址 = 0x%X\r\n&quot;</span>,xReturn);<br><span class="hljs-keyword">return</span> xReturn;<br>&#125;<br> <br><span class="hljs-comment">// 删除链表中的某个节点,根据weight进行删除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy_LinkNode</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> deleteFlag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf;<br> <br>pf = HeadNode;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-keyword">if</span> (pf-&gt;data.weight == weight)<br>&#123;<br>deleteFlag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != HeadNode);<br> <br><span class="hljs-keyword">if</span> (!deleteFlag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表中找不到这个节点！！！\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (pf-&gt;Next == HeadNode)<br>&#123;<br>pf-&gt;Prev-&gt;Next = HeadNode;<br>HeadNode-&gt;Prev = pf;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pf-&gt;Prev-&gt;Next = pf-&gt;Next;<br>pf-&gt;Next-&gt;Prev = pf-&gt;Prev; <br>&#125;<br><br><span class="hljs-built_in">free</span>(pf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点weight = %d 销毁成功！\r\n&quot;</span>,weight);<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// 输出显示整条链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>length++;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != HeadNode);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表输出完成。长度为：%d\r\n&quot;</span>,length);<br>&#125;<br> <br> <br><span class="hljs-comment">// 按条件查询链表中某个节点的数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">search_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> search_flag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-keyword">if</span>(pf-&gt;data.weight == weight)<br>&#123;<br>search_flag = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br>length++;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != HeadNode);<br> <br><span class="hljs-keyword">if</span>(search_flag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表查找结束。所在节点位置为：%d\r\n&quot;</span>,length);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;整个链表中无满足此条件的节点！\r\n&quot;</span>);<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// 查询链表中有几个相同的数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">search_Same_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> search_flag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br>length++;<br><span class="hljs-keyword">if</span>(pf-&gt;data.weight == weight)<br>&#123;<br>search_flag = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这个节点在链表中的位置：%d\r\n&quot;</span>,length);<br>cnt++;<br>&#125;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != HeadNode);<br> <br><span class="hljs-keyword">if</span>(search_flag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表查找结束。相同数据的节点数量为：%d\r\n&quot;</span>,cnt);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;整个链表中无满足此条件的节点！\r\n&quot;</span>);<br>&#125;<br>&#125;<br> <br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">print_debug_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;******** 链表控制台 *****************\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*                                  \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  1：创建链表                      \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  2：删除链表                      \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  3：显示整条链表的数据             \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  4：按条件查找链表节点             \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  5：查找链表中有几个相同数据的节点  \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  8：清空显示                      \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*  9：结束运行                      \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*                                  \r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;************************************\r\n&quot;</span>);<br>&#125;<br> <br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123;<br><span class="hljs-type">int</span> Num,i,j;<br><span class="hljs-type">int</span> Options;<br><span class="hljs-type">int</span> weight,height;<br>LinkData_t InsetData;<br> <br>Init_LinkNode(&amp;AppleInfo_head);<br> <br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>print_debug_info();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n请输入需要操作的键值，按回车键确认！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Options);<br><span class="hljs-keyword">switch</span> (Options)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-comment">/*** 创建任意长度的链表 **********************************************************/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入需要创建的链表节点的数量,按回车结束！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Num);<br> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入节点的数据：\r\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Num; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入第 %d 节点的数据,weight = Height = ,输入完毕按回车结束！\r\n&quot;</span>,i+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;weight,&amp;height);<br>InsetData.weight = weight;<br>InsetData.hight  = height;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d height = %d\r\n&quot;</span>,weight,height);<br> <br><span class="hljs-keyword">if</span>(LinkNode_Create(&amp;AppleInfo_head, &amp;InsetData) &gt; <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点 %d 创建成功！\r\n\r\n\r\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点 %d 创建失败！\r\n\r\n\r\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-comment">/******* 删除链表中的某个节点 ***************************************************/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入需要删除的链表节点的weight,按回车结束！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Num);<br>destroy_LinkNode(&amp;AppleInfo_head, Num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表数据为：\r\n&quot;</span>);<br>print_LinkNode_Info(&amp;AppleInfo_head);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入需要查找的链表节点的weight,按回车结束！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Num);<br>search_LinkNode_Info(&amp;AppleInfo_head, Num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入需要查找的链表节点的weight,按回车结束！\r\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Num);<br>search_Same_LinkNode_Info(&amp;AppleInfo_head, Num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>system(<span class="hljs-string">&quot;cls&quot;</span>);<br><span class="hljs-keyword">break</span>;<br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出链表控制台，请再次运行程序！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无效的键值，请重新输入！\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DATA_STRUCT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linked</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构—单向链表</title>
    <link href="/2024/11/26/data_struct_singly_linked/"/>
    <url>/2024/11/26/data_struct_singly_linked/</url>
    
    <content type="html"><![CDATA[<!-- data_struct_singly_linked--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/127069907?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;127069907?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="链表是什么"><a href="#链表是什么" class="headerlink" title="链表是什么"></a>链表是什么</h3><p>链表是编程语言中常见的一种数据结构，它可以实现动态的创建和删除，只要内存足够，链表的数量和长度是可以无限多和无限长的。</p><p>链表顾名思义是一种链式的数据结构，它由一个个节点组成，并通过节点之间的互相关联链接，形成了类似一条链式的结构。</p><p>链表的节点一般可以分为数据域和指针域。数据域中是存放节点数据的，往往链表的节点都是结构体类型的，可以方便定义多种不同的数据类型，便于使用。指针域是存放节点的指针的，是链表中每个节点能互相串联起来的关键，这个至关重要！</p><p><img src="/imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/image-20241126150333804.png"></p><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p> 单向链表根据使用情况还分为单向不循环链表、单向循环链表两种。</p><h3 id="单向不循环链表"><a href="#单向不循环链表" class="headerlink" title="单向不循环链表"></a>单向不循环链表</h3><p>单向不循环链表是一种单向的链式结构，节点之间通过指针域互相关联，最后一个节点的指针域为空（NULL）</p><p><img src="/imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/image-20241126150435231.png"></p><p><em><strong>*先定义一个链表的节点*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义一个链表节点的数据域。以记录一个苹果的信息为例，为方便说明，假设每个苹果的信息各不相同</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkData_struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span>  weight; <span class="hljs-comment">// 苹果的重量</span><br><span class="hljs-type">int</span>  hight;  <span class="hljs-comment">// 苹果的高度</span><br><span class="hljs-comment">// ...  // 还可以定义更多的其他的数据</span><br>&#125;LinkData_t;<br> <br><span class="hljs-comment">/*** 定义一个链表节点 ******/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span></span><br><span class="hljs-class">&#123;</span><br>LinkData_t data;<span class="hljs-comment">// 链表节点的数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span> *<span class="hljs-title">Next</span>;</span> <span class="hljs-comment">// 链表节点的指针域</span><br>&#125;LinkNode_t;<br></code></pre></td></tr></table></figure><p><em><strong>*定义一个单向链表的头结点*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*** 定义一个单向链表的头结点 ***/</span><br>LinkNode_t AppleInfo_head; <span class="hljs-comment">//作为单向链表的一个头结点</span><br></code></pre></td></tr></table></figure><p><em><strong>*初始化单向链表*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 初始化单向链表的头结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Init_LinkNode</span><span class="hljs-params">(LinkNode_t * HeadNode)</span><br>&#123;<br>HeadNode-&gt;Next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>*创建链表节点并接入到链表中*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个链表节点并接入到链表中</span><br>LinkNode_t * <span class="hljs-title function_">LinkNode_Create</span><span class="hljs-params">(LinkNode_t * HeadNode, LinkData_t *InsetData)</span><br>&#123;<br>LinkNode_t *Node,*pf;<br>LinkNode_t *xReturn = <span class="hljs-literal">NULL</span>;<br>Node = (LinkNode_t *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode_t));<br> <br><span class="hljs-keyword">if</span> (Node == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点创建失败！！！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br> <br>pf = HeadNode;<br><span class="hljs-keyword">while</span>(pf-&gt;Next != <span class="hljs-literal">NULL</span>)<br>&#123;<br>pf = pf-&gt;Next;<br>&#125;<br>pf-&gt;Next = Node;<br>Node-&gt;Next = <span class="hljs-literal">NULL</span>;<br>Node-&gt;data.hight = InsetData-&gt;hight;<br>Node-&gt;data.weight = InsetData-&gt;weight;<br>xReturn = Node;<br> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;完成一个链表节点的创建，地址 = 0x%X\r\n&quot;</span>,xReturn);<br><span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>*删除链表中的节点*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 删除链表中的某个节点,根据weight进行删除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy_LinkNode</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> deleteFlag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf,*preStre;<br> <br>pf = preStre = HeadNode;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">if</span> (pf-&gt;data.weight == weight)&#123;<br>deleteFlag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>preStre = pf;<br>pf = pf-&gt;Next;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != <span class="hljs-literal">NULL</span>);<br> <br><span class="hljs-keyword">if</span> (!deleteFlag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找不到这个节点！！！\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(pf-&gt;Next == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">// 该点是尾节点</span><br>&#123;<br>preStre-&gt;Next = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>preStre-&gt;Next = pf-&gt;Next;<br>&#125;<br><span class="hljs-built_in">free</span>(pf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点weight = %d 销毁成功！\r\n&quot;</span>,weight);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>*输出整条链表的数据*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 输出显示整条链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>length++;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表输出完成。长度为：%d\r\n&quot;</span>,length);<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>*按条件查询链表中某个节点的数据*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 按条件查询链表中某个节点的数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">search_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> search_flag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-keyword">if</span>(pf-&gt;data.weight == weight)<br>&#123;<br>search_flag = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br>length++;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != <span class="hljs-literal">NULL</span>);<br> <br><span class="hljs-keyword">if</span>(search_flag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表查找结束。所在节点位置为：%d\r\n&quot;</span>,length);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;整个链表中无满足此条件的节点！\r\n&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h3><p>单向循环链表是一种单向的可回头的链表，节点之间通过指针域互相关联，最后一个节点的指针域为头结点的地址。</p><p><img src="/imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/image-20241126150907283.png"></p><p><em><strong>*先定义一个链表的节点*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义一个链表节点的数据域。以记录一个苹果的信息为例，为方便说明，假设每个苹果的信息各不相同</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkData_struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span>  weight; <span class="hljs-comment">// 苹果的重量</span><br><span class="hljs-type">int</span>  hight;  <span class="hljs-comment">// 苹果的高度</span><br><span class="hljs-comment">// ...  // 还可以定义更多的其他的数据</span><br>&#125;LinkData_t;<br> <br><span class="hljs-comment">/*** 定义一个链表节点 ******/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span></span><br><span class="hljs-class">&#123;</span><br>LinkData_t data;<span class="hljs-comment">// 链表节点的数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode_Struct</span> *<span class="hljs-title">Next</span>;</span> <span class="hljs-comment">// 链表节点的指针域</span><br>&#125;LinkNode_t;<br></code></pre></td></tr></table></figure><p><em><strong>*定义一个单向链表的头结点*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*** 定义一个单向链表的头结点 ***/</span><br>LinkNode_t AppleInfo_head; <span class="hljs-comment">//作为单向链表的一个头结点</span><br></code></pre></td></tr></table></figure><p><em><strong>*初始化单向链表*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 初始化单向循环链表的头结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Init_LinkNode</span><span class="hljs-params">(LinkNode_t * HeadNode)</span><br>&#123;<br>HeadNode-&gt;Next = HeadNode;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>*创建链表节点并接入到链表中*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个链表节点并接入到单向循环链表中</span><br>LinkNode_t * <span class="hljs-title function_">LinkNode_Create</span><span class="hljs-params">(LinkNode_t * HeadNode, LinkData_t *InsetData)</span><br>&#123;<br>LinkNode_t *Node,*pf;<br>LinkNode_t *xReturn = <span class="hljs-literal">NULL</span>;<br>Node = (LinkNode_t *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode_t));<br> <br><span class="hljs-keyword">if</span> (Node == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点创建失败！！！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br> <br>pf = HeadNode;<br><span class="hljs-keyword">while</span>(pf-&gt;Next != HeadNode)<br>&#123;<br>pf = pf-&gt;Next;<br>&#125;<br>pf-&gt;Next = Node;<br>Node-&gt;Next = HeadNode;<br>Node-&gt;data.hight = InsetData-&gt;hight;<br>Node-&gt;data.weight = InsetData-&gt;weight;<br>xReturn = Node;<br> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;完成一个链表节点的创建，地址 = 0x%X\r\n&quot;</span>,xReturn);<br><span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>*删除链表中的节点*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 删除链表中的某个节点,根据weight进行删除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy_LinkNode</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> deleteFlag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf,*preStre;<br> <br>pf = preStre = HeadNode;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>preStre = pf;<br>pf = pf-&gt;Next;<br><span class="hljs-keyword">if</span> (pf-&gt;data.weight == weight)&#123;<br>deleteFlag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != HeadNode);<br> <br><span class="hljs-keyword">if</span> (!deleteFlag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找不到这个节点！！！\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(pf-&gt;Next == HeadNode)<span class="hljs-comment">// 该点是尾节点</span><br>&#123;<br>preStre-&gt;Next = HeadNode;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>preStre-&gt;Next = pf-&gt;Next;<br>&#125;<br><span class="hljs-built_in">free</span>(pf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节点weight = %d 销毁成功！\r\n&quot;</span>,weight);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>*输出整条链表的数据*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 输出显示整条链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == HeadNode)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>length++;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != HeadNode);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表输出完成。长度为：%d\r\n&quot;</span>,length);<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>*按条件查询链表中某个节点的数据*</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 按条件查询链表中某个节点的数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">search_LinkNode_Info</span><span class="hljs-params">(LinkNode_t * HeadNode, <span class="hljs-type">int</span> weight)</span><br>&#123;<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> search_flag = <span class="hljs-number">0</span>;<br>LinkNode_t *pf = HeadNode;<br> <br><span class="hljs-keyword">if</span> (pf-&gt;Next == HeadNode)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该链表长度为零，不能输出结果！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-keyword">do</span><br>&#123;<br>pf = pf-&gt;Next;<br><span class="hljs-keyword">if</span>(pf-&gt;data.weight == weight)<br>&#123;<br>search_flag = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.weight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;height = %d\r\n&quot;</span>, (<span class="hljs-type">int</span>)pf-&gt;data.hight);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br>length++;<br>&#125;<span class="hljs-keyword">while</span> (pf-&gt;Next != HeadNode);<br> <br><span class="hljs-keyword">if</span>(search_flag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表查找结束。所在节点位置为：%d\r\n&quot;</span>,length);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;整个链表中无满足此条件的节点！\r\n&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color=red>单向不循环链表和单向循环链表基本是相同的，不同之处主要在于尾节点的指针域不同。单向不循环链表的尾节点的指针域为空，到尾节点的位置链表就结束了；单向循环链表的尾节点保存的是头节点的地址，从尾节点可以知道首节点的位置，形成一种循环的链式结构。</font></p>]]></content>
    
    
    <categories>
      
      <category>DATA_STRUCT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linked</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAN协议</title>
    <link href="/2024/11/25/can_protocol/"/>
    <url>/2024/11/25/can_protocol/</url>
    
    <content type="html"><![CDATA[<!-- can_protocol--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125885971?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125885971?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="CAN总线的介绍"><a href="#CAN总线的介绍" class="headerlink" title="CAN总线的介绍"></a>CAN总线的介绍</h3><p>CAN总线简称 — 控制器局域网络，由德国BOSCH公司开发，是一种串行的差分总线，并且这种差分总线只传递数据信息。</p><p>CAN总线已经是国际上的一种通信标准（ISO11519），它具有高可靠性、良好的错误检测能力、总线仲裁等优良特点，被广泛应用在汽车控制系统、环境恶劣场所、电磁辐射强、干扰性大等场所中。</p><p>CAN是一种异步的通信方式，它的通讯不需要时钟进行同步，线路上只有CAN_H、CAN_L两根通信线，数据以差分信号的方式进行传输。</p><h3 id="CAN的通信网络"><a href="#CAN的通信网络" class="headerlink" title="CAN的通信网络"></a>CAN的通信网络</h3><h5 id="闭环总线网络"><a href="#闭环总线网络" class="headerlink" title="闭环总线网络"></a>闭环总线网络</h5><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241125104317313.png"></p><p>闭环通信网络的特点如下：</p><p>1）遵照标准为 ISO11898；</p><p>2）最高速度可达1Mbps，总线最大长度为40m；</p><p>3）总线的两端要求各有一个120欧姆的电阻。</p><h5 id="开环总线网络"><a href="#开环总线网络" class="headerlink" title="开环总线网络"></a>开环总线网络</h5><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241125104419542.png"></p><p>开环通信网络的特点如下：</p><p>1）遵循ISO11519-2标准；</p><p>2）最高的通信速度为125Kbps，是一种低速通信的连接方式；</p><p>3）最大的通信距离可达1Km；</p><p>4）两根总线独立，且要求每根总线上要串联一个2.2K欧姆的电阻。</p><h3 id="CAN的通信速率"><a href="#CAN的通信速率" class="headerlink" title="CAN的通信速率"></a>CAN的通信速率</h3><p>按照 ISO11898 标准中所规定的，CAN总线的通讯波特率最高为 1Mbps。大多数项目常用的CAN总线波特率有125Kbits&#x2F;s，250Kbits&#x2F;s，500Kbits&#x2F;s，1MKbits&#x2F;s等。</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241125104554319.png"></p><h3 id="CAN的差分信号"><a href="#CAN的差分信号" class="headerlink" title="CAN的差分信号"></a>CAN的差分信号</h3><p>CAN总线的数据传输使用的是差分信号的方式进行的。这两根线中的信号振幅相等，相位相反，逻辑1 和 逻辑0 通过两根信号线的电压差值表示出来。</p><p>在CAN的应用中，逻辑1也称为隐性电平，逻辑0也称为显性电平。</p><p>比如，以高速CAN为例：</p><p><font color=red>逻辑1：CAN_H、CAN_L的电压均为2.5V，电压差为VH - VL &#x3D; 0V。</font></p><p><font color=red>逻辑0：CAN_H电压为3.5V，CAN_L电压为1.5V，电压差为 VH - VL &#x3D; 2V</font></p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241125104744383.png"></p><p>两根信号线的电压值根据标准的不同是有所差异的</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241125104950893.png"></p><p><font color=red>注意：CAN总线上，在同一个时刻只能处于隐性电平（逻辑1）或者显性电平（逻辑0）中的一个状态，且显性电平相比隐性电平具有优先权。比如：CAN总线上有两个节点，在同一个时刻，一个输出隐性电平，一个输出显性电平，这个时候总线上是显性电平状态。</font></p><h3 id="CAN-的位同步"><a href="#CAN-的位同步" class="headerlink" title="CAN 的位同步"></a>CAN 的位同步</h3><p>由于CAN总线是异步通信的，它不像IIC、SPI这种同步通行方式一样具有同步时钟，所以总线网络中的节点就需要约定好通信的波特率。</p><p>在CAN中使用了 “位同步” 的方式来抵抗干扰、吸收误差，实现对总线电平信号的正常采样，确保通讯正常进行。</p><p>CAN实现位同步的过程中，会把每一个数据位的时序进行分解，会分解成SS段、PTS段、PBS1段、PBS2段，这四个段加起来就是一个CAN的数据位长度。分解后的最小时间单位为Tq。它们分别如下：</p><p><strong>同步段（SS段）：该段的大小固定为1Tq。</strong></p><p>当总线上的节点在SS段的范围内检测到总线上信号发生了跳变，就认为该节点与总线的时序是同步的。当节点与总线同步时，在采样点采集到的总线电平即可以确认为该位的电平。</p><p><strong>传播时间段（PTS段）：该段的大小为 1Tq ~ 8Tq。</strong></p><p>这个时间段是用于补偿网络的物理延时时间。是总线上输入比较器延时和输出驱动器延时总和的两倍。</p><p><strong>相位缓冲段1（PBS1）：该段的大小为 1Tq ~ 8Tq。</strong></p><p>主要用来补偿边沿阶段的误差，它的时间长度在重新同步的时候可以加长。</p><p><strong>相位缓冲段2（PBS2）：该段的大小为 1Tq ~ 8Tq。</strong></p><p>是用来补偿边沿阶段误差的，它的时间长度在重新同步时可以缩短。</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126134622484.png"></p><p>每个数据位的长度为19Tq（SS 段占 1Tq，PTS 段占 6Tq，PBS1 段占 5Tq，PBS2 段占 7Tq），信号的采样点位于 PBS1 段与 PBS2 段之间，通过控制各段的长度，可以改变采样点的位置</p><h3 id="CAN-的数据同步"><a href="#CAN-的数据同步" class="headerlink" title="CAN 的数据同步"></a>CAN 的数据同步</h3><p>CAN的数据同步使用到SS段、PTS段、PBS1段、PBS2段，并且数据的同步分为硬同步、重新同步。</p><p><strong>硬同步</strong></p><p>CAN节点希望通过总线发送数据时，会发送一个由高变低的下降沿作为通讯的起始信号；而节点不发送数据时会时刻检测总线上的信号。</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126134821908.png"></p><p>当总线上出现了帧起始信号时，某一个节点检测到总线的帧起始信号不在该节点内部时序的 SS 段范围，所以就可以判断它自己的内部时序与总线不同步，因而这种状态下的采样点采集得的数据是不正确的。所以节点以硬同步的方式调整，把自己的位时序中的 SS 段平移至总线出现下降沿的部分，获得同步，同步后采样点就可以采集得正确数据了。</p><p><strong>重新同步</strong></p><p>硬同步是存在帧起始信号时才起作用，但是假如是一帧很长的数据，这一长串数据内不再出现帧起始信号，那么在节点信号与总线信号出现相位偏移时，用硬同步方式就行不通了。</p><p>所以就有了重新同步的方式，这种方式利用普通数据位的电平的高至低的跳变沿来同步同样都是在 SS 段中进行检测，从而实现同步的目的。</p><p><font color=red>注意：同步的目的都是为了能在节点内的 SS 段把跳变沿包含起来。</font></p><p>重新同步可以细分为两种同步方式：相位超前重新同步和相位滞后重新同步。这两种方式以总线跳变沿与 SS 段的相对位置进行区分的。</p><p><strong>相位超前重新同步</strong></p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126135037293.png"></p><p>节点的SS段相对于总线的边沿跳变往前了两个Tq的时间，即节点的时序比它检测的总线时序相对超前了2Tq。</p><p>解决这个问题可以在下一个位时序中的PBS1段增加2Tq的时间长度，使得节点与总线时序重新同步</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126135118495.png"></p><p><strong>相位滞后重新同步</strong></p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126135200868.png"></p><p>节点的SS段相对于总线的边沿跳变延迟了两个Tq的时间，即节点的时序比它检测的总线时序相对落后了2Tq</p><p>解决这个问题可以在下一个位时序中的PBS2段减少2Tq的时间长度，使得节点与总线时序重新同步</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126135251259.png"></p><h3 id="CAN的波特率"><a href="#CAN的波特率" class="headerlink" title="CAN的波特率"></a>CAN的波特率</h3><p>在CAN总线的通讯中，各个通讯的节点只要确定了1个Tq的时间长度以及每个数据位占多少个Tq，由此就可以算出CAN通讯的波特率。</p><p>在CAN中，波特率也就只是约定了每个数据位的长度而已。</p><p>假设1Tq &#x3D; 1us，每个数据位由19个Tq组成，则每传输1Bit数据需要的时间为：19Tq &#x3D; 19us。则一秒可以传输的数据位（bit）为：</p><p>1000000 &#x2F; 19 &#x3D; 52.6316K（bps）</p><p><font color=red>注意：波特率指的是每秒可以传输的数据位（bit）的个数。</font></p><h3 id="CAN的帧种类和用途"><a href="#CAN的帧种类和用途" class="headerlink" title="CAN的帧种类和用途"></a>CAN的帧种类和用途</h3><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126135437826.png"></p><p>特别地，数据帧和遥控帧有标准格式和扩展格式两种格式。</p><p><strong>标准格式 — 有 11 个位的标识符 ID</strong></p><p><strong>扩展格式 — 有 29 个位的 标识符 ID</strong></p><h5 id="CAN总线的数据帧"><a href="#CAN总线的数据帧" class="headerlink" title="CAN总线的数据帧"></a>CAN总线的数据帧</h5><p>数据帧一般由 7 个段构成</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126135548603.png"></p><p>1） 帧起始。表示数据帧开始的段。</p><p>2） 仲裁段。表示该帧优先级的段,即ID信息。</p><p>3） 控制段。表示数据的字节数及保留位的段。</p><p>4） 数据段。数据的内容，一帧可发送 0~8 个字节的数据。</p><p>5） CRC 段。检查帧的传输错误的段。</p><p>6） ACK 段。表示确认正常接收的段。</p><p>7） 帧结束。表示数据帧结束的段。</p><p>CAN的数据帧有标准格式和扩展格式两种</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126135703020.png"></p><p>数据帧的标准格式和扩展格式两者的不同之处主要在于仲裁段中，控制段中有细微的不同</p><p>1）标准格式的ID是11位。</p><p>从ID28到ID18一次发送，禁止高7位都为隐形（禁止ID&#x3D;1111111XXXX）。</p><p>2）扩展格式的ID有29个位。</p><p>基本ID从ID28到ID18，扩展ID由ID17到ID0表示。基本ID和标准格式的ID相同。</p><p>RTR位：帧选择位<br>0：数据帧 1：远程帧</p><p>IDE位：<br>0：标准标识符 1：扩展标识符</p><p>SRR位：</p><p>远程请求位，为隐形位，代替了标准帧中的RTR位。</p><p>r0、r1位：</p><p>保留位，发送时必须全部是显性电平，但是接收时可以是显性、隐形、任意组合的电平。</p><h6 id="起始帧"><a href="#起始帧" class="headerlink" title="起始帧"></a>起始帧</h6><p>CAN的数据帧和远程帧开始发送时，是需要发送一个开始的标志的，称之为帧起始。它是一个显性位（逻辑0）。</p><p>一个CAN节点只有在总线处于空闲状态时才可以发送起始帧。</p><h6 id="仲裁段"><a href="#仲裁段" class="headerlink" title="仲裁段"></a>仲裁段</h6><p>起始帧发送完成之后，紧接着发送出的就是仲裁段的数据。</p><p>CAN2.0A的仲裁场一共有12位</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126135946862.png"></p><p>在这12位中，前11位表示的是11位标识符，第12位是远程发送请求RTR。在数据帧中RTR为显性，在远程帧中RTR为隐性。如果相同标识符的数据帧与远程帧发生冲突，数据帧优先。</p><p>CAN2.0B的仲裁场一共有32位，它在CAN2.0A的基础上，将CAN ID扩展到了29位，并且向CAN2.0A兼容</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140036105.png"></p><h6 id="控制段"><a href="#控制段" class="headerlink" title="控制段"></a>控制段</h6><p>仲裁之段后便是控制场。控制场的头两位为保留位（R1、R0），为隐性。</p><p>后面是数据长度代码DLC（Data Length Code）。数据长度代码指示了数据场中有效的字节个数。</p><p>DLC的长度为4位二进制数，虽然可以最大范围可以表示到0~15，但是由于CAN总线的数据域长度最大为8个字节，所以DLC的大小可以认为是最大为8。</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140121097.png"></p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140151824.png"></p><h6 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h6><p>控制场传输完成之后，紧接着传输的就是数据场了，数据场里面传输的就是我们想要传输的数据，长度为8个字节</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140223633.png"></p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140243810.png"></p><h6 id="CRC段"><a href="#CRC段" class="headerlink" title="CRC段"></a>CRC段</h6><p>CAN数据每次发送的时候，都会将CAN数据帧里面的有效数据进行CRC校验，并且将最终生成的CRC信息一起包含在数据帧中的CRC域内进行发送。接收端接收到一帧CAN总线数据后，会将接收到的数据进行CRC计算，并且同发出端的CRC校验码进行比较，如果相同，则代表当前接收到的信息是正确的。</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140319650.png"></p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140343928.png"></p><p>在经典CAN中，使用15位CRC。在硬件可使用移位和异或运算完成CRC的计算。</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140443327.png"></p><h6 id="应答段"><a href="#应答段" class="headerlink" title="应答段"></a>应答段</h6><p>CAN总线的应答场长度为2个位，包含应答间隙（ACK SLOT）和应答界定符（ACK DELIMITER）。</p><p>在应答场里，发送站发送两个“隐性”位。当接收器正确地接收到有效的报文，接收器就会在应答间隙（ACK SLOT）期间（发送ACK信号）向发送器发送一“显性”的位以示应答。</p><p><strong>应答间隙：</strong>所有接收到匹配CRC序列（CRC SEQUENCE）的站会在应答间隙（ACK SLOT）期间用以“显性”的位写入发送器的“隐性”位来作出回答。</p><p><strong>ACK界定符：</strong>ACK界定符是ACK场的第二个位，并且是一个必须为“隐性”的位。因此，应答间隙（ACK SLOT）被两个“隐性”的位所包围，也就是CRC界定符（CRC DELIMITER）和ACK界定符（ACK DELIMITER）。</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140542369.png"></p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140605820.png"></p><h6 id="帧结束"><a href="#帧结束" class="headerlink" title="帧结束"></a>帧结束</h6><p>应答段之后的7位数据是CAN总线的结束帧，是为7位连续的1（隐性电平）</p><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140633755.png"></p><h3 id="CAN通信的数据段示例"><a href="#CAN通信的数据段示例" class="headerlink" title="CAN通信的数据段示例"></a>CAN通信的数据段示例</h3><p><img src="/imgs/CAN%E5%8D%8F%E8%AE%AE/image-20241126140706903.png"></p>]]></content>
    
    
    <categories>
      
      <category>Protocol</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modbus-协议基本原理</title>
    <link href="/2024/11/25/modbus_protocol/"/>
    <url>/2024/11/25/modbus_protocol/</url>
    
    <content type="html"><![CDATA[<!-- modbus_protocol--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125762016?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125762016?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="Modbus简介"><a href="#Modbus简介" class="headerlink" title="Modbus简介"></a>Modbus简介</h3><p>Modbus 是由 Modicon（现为施耐德电气公司的一个品牌）在 1979 年发明的，是全球第一个真正用于工业现场的总线协议。</p><p>ModBus 网络是一个工业通信系统，由带智能终端的可编程序控制器和计算机通过公用线路或局部专用线路连接而成。其系统结构既包括硬件、亦包括软件。它可应用于各种数据采集和过程监控。</p><p>为更好地普及和推动 Modbus 在基于以太网上的分布式应用，目前施耐德公司已将 Modbus 协议的所有权移交给 IDA（Interface for Distributed Automation，分布式自动化接口）组织，并成立了Modbus-IDA 组织，为 Modbus 今后的发展奠定了基础。</p><h3 id="Modbus协议概述"><a href="#Modbus协议概述" class="headerlink" title="Modbus协议概述"></a>Modbus协议概述</h3><p>Modbus是一个主-从模式的通信协议，属于数据链路层上的协议，协议本身不涉及具体的硬件要求。<br>常见的应用Modbus协议的物理接口有RS-485、RS232、USART等的通信链路中。</p><p>Modbus协议中，一个时刻内只允许有一个主机连接于总线，多个从机连接于总线上，通信都是只能由主机发起，从机进行响应。不能从机主动发起通信。</p><h3 id="Modbus-主从机通信模式"><a href="#Modbus-主从机通信模式" class="headerlink" title="Modbus 主从机通信模式"></a>Modbus 主从机通信模式</h3><p>主机和从机之间的通信，可以用两种模式进行：广播通知模式、单播点对点模式。</p><h5 id="单播点对点模式"><a href="#单播点对点模式" class="headerlink" title="单播点对点模式"></a>单播点对点模式</h5><p>主机按照从机的明确地址访问相应的从机，从机接到来自主机的请求并处理完请求后，从机会向主机返回一个应答，完成一个通信。</p><p>在这种模式，一个 Modbus 事务处理包含 2 个报文：一个来自主机的请求，一个来自从机的应答。</p><p>在总线上，每个从机都必须有唯一的从机地址 (1 到 247)，这样才能区别于其它节点被独立的寻址。</p><h5 id="广播通知模式"><a href="#广播通知模式" class="headerlink" title="广播通知模式"></a>广播通知模式</h5><p>主机向所总线通过广播指令发送请求，所有的从机都要接收来自主机的广播信息。</p><p>对于主机广播的请求，从机是没有应答返回的。所有的从机必须要接受主机的广播模写功能。</p><p><font color=red>注意：地址 0 是专门用于主机向各个从机广播数据的。</font></p><h3 id="Modbus-地址规则"><a href="#Modbus-地址规则" class="headerlink" title="Modbus 地址规则"></a>Modbus 地址规则</h3><p>Modbus 寻址空间有 256 个不同地址。</p><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125100326114.png"></p><p>地址 0 为<strong>广播地址</strong>。所有的从机必须识别广播地址。</p><p>Modbus 主机本身是没有地址的，只有从机必须要有一个地址。 该地址必须在 Modbus 串行总线上唯一。</p><p>248~255作为预留使用的地址。</p><h3 id="Modbus-的帧格式"><a href="#Modbus-的帧格式" class="headerlink" title="Modbus 的帧格式"></a>Modbus 的帧格式</h3><p>Modbus的帧格式按照选择的模式不同帧格式也是有所区别的。</p><h5 id="RTU模式"><a href="#RTU模式" class="headerlink" title="RTU模式"></a>RTU模式</h5><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125100459918.png"></p><p>Modbus RTU 帧总长度最大为 256 字节。</p><p>RTU 模式每个字节 ( 11 位 ) </p><p>每字节的 bit 流:<br><strong>1 起始位<br>8 数据位， 首先发送最低有效位<br>1 位作为奇偶校验<br>1 停止位</strong></p><p>偶校验是要求的， 其它模式 ( 奇校验， 无校验 ) 也可以使用。 为了保证与其它产品的最大兼容性，同时支持无校验模式是建议的。默认校验模式模式 必须为偶校验。</p><p><strong>注 : 使用无校验要求 2 个停止位。</strong></p><p>RTU时，每个字符或字节均由此顺序发送(从左到右)：<br>最低有效位 (LSB) . . . 最高有效位 (MSB)</p><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125101948042.png"></p><h5 id="RTU模式下的帧通信"><a href="#RTU模式下的帧通信" class="headerlink" title="RTU模式下的帧通信"></a>RTU模式下的帧通信</h5><p>由发送设备将 Modbus 报文构造为带有已知起始和结束标记的帧。这使设备可以在报文的开始接收新帧，并且知道何时报文结束。</p><p>不完整的报文必须能够被检测到而错误标志必须作为结果被设置。</p><p>在 RTU 模式，报文帧由时长至少为 3.5 个字符时间的空闲间隔区分。</p><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125102132052.png"></p><p>整个报文帧必须以连续的字符流发送。</p><p>如果两个字符之间的空闲间隔大于 1.5 个字符时间，则报文帧被认为不完整应该被接收节点丢弃。</p><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125102222471.png"></p><p><font color=red>注意 : RTU 模式下接收数据时，由于 t1.5 和 t3.5 的时间隔要求的存在，一般在高通信速率下，会导致 CPU 负担加重。因此，在通信速率等于或低于 19200 bps 时，这两个定时必须严格遵守； 对于波特率大于 19200 bps 的情形，应该使用 2 个定时的固定值： 建议的字符间超时时间(t1.5)为 750µs， 帧间的超时时间 (t1.5) 为 1.750ms。</font></p><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125102332565.png"></p><ul><li><p>从 “初始” 态到 “空闲” 态转换需要 t3.5 定时超时: 这保证帧间延迟</p></li><li><p>“空闲” 态是没有发送和接收报文要处理的正常状态。</p></li><li><p>在 RTU 模式， 当没有活动的传输的时间间隔达 3.5 个字符长时，通信链路被认为在 “空闲” 态。</p></li><li><p>当链路空闲时， 在链路上检测到的任何传输的字符被识别为帧起始。 链路变为 “活动” 状态。 然后当链路上没有字符传输的时间间个达到 t3.5 后，被识别为帧结束。</p></li><li><p>检测到帧结束后，完成 CRC 计算和检验。然后，分析地址域以确定帧是否发往此设备，如果不是，则丢弃此帧。 为了减少接收处理时间，地址域可以在一接到就分析，而不需要等到整个帧结束。这样，CRC 计算只需要在帧寻址到该节点 (包括广播帧) 时进行。</p></li></ul><h5 id="RTU模式的CRC校验"><a href="#RTU模式的CRC校验" class="headerlink" title="RTU模式的CRC校验"></a>RTU模式的CRC校验</h5><p>在 RTU 模式包含一个对全部报文内容执行的，基于循环冗余校验 (CRC - Cyclical Redundancy Checking) 算法的错误检验域。CRC 域检验整个报文的内容。不管报文有无奇偶校验，均执行此检验。</p><p>CRC 包含由两个 8 位字节组成的一个 16 位值。</p><p>CRC 域作为报文的最后的域附加在报文之后。计算后，首先附加低字节，然后是高字节。CRC 高字<br>节为报文发送的最后一个子节。</p><p>附加在报文后面的 CRC 的值由发送设备计算。接收设备在接收报文时重新计算 CRC 的值，并将计<br>算结果于实际接收到的 CRC 值相比较。如果两个值不相等，则为错误。</p><p>CRC 的计算, 开始对一个 16 位寄存器预装全 1。 然后将报文中的连续的 8 位子节对其进行后续的计<br>算。只有字符中的 8 个数据位参与生成 CRC 的运算，起始位，停止位和校验位不参与 CRC 计算。</p><p>CRC 的生成过程中， 每个 8–位字符与寄存器中的值异或。然后结果向最低有效位(LSB)方向移动<br>(Shift) 1 位，而最高有效位(MSB)位置充零。 然后提取并检查 LSB：如果 LSB 为 1， 则寄存器中的值与一个固定的预置值异或；如果 LSB 为 0， 则不进行异或操作。</p><p>这个过程将重复直到执行完 8 次移位。完成最后一次（第 8 次）移位及相关操作后，下一个 8 位字节与寄存器的当前值异或，然后又同上面描述过的一样重复 8 次。当所有报文中子节都运算之后得到的寄存器的最终值，就是 CRC。</p><h5 id="ASCII传输模式"><a href="#ASCII传输模式" class="headerlink" title="ASCII传输模式"></a>ASCII传输模式</h5><p>当 Modbus 串行链路的设备被配置为使用 ASCII模式通信时，报文中的每个 8 位字节以两个 ASCII 字符发送。<br>一般在通信链路或者设备无法符合 RTU 模式的定时管理时使用该模式。</p><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125102901509.png"></p><p>比如 : 字节 0X5B 会被编码为两个字符 : 0x35 和 0x42 ( ASCII 编码 0x35 &#x3D;“5”， 0x42 &#x3D;“B” )。</p><p><font color=red>注 : 由于一个子节需要两个字符，此模式比 RTU 效率低。</font></p><p>ASCII 模式每个字节 ( 10 位 ) 的格式为 :<br><strong>1 起始位<br>7 数据位， 首先发送最低有效位<br>1 位作为奇偶校验<br>1 停止位</strong></p><p>偶校验是要求的， 其它模式 ( 奇校验， 无校验 ) 也可以使用。 为了保证与其它产品的最大兼容性，<br>同时支持无校验模式是建议的。默认校验模式模式 必须为偶校验。</p><p><font color=red>注 : 使用无校验要求 2 个停止位。</font></p><h5 id="ASCII的报文帧"><a href="#ASCII的报文帧" class="headerlink" title="ASCII的报文帧"></a>ASCII的报文帧</h5><p>在 ASCII 模式， 报文用特殊的字符区分帧起始和帧结束。一个报文必须以一个‘冒号’ ( : ) (ASCII十六进制 3A )起始，以 ‘回车-换行’ (CR LF) 对 (ASCII 十六进制 0D 和 0A) 结束。</p><p>对于所有的域，允许传送的字符为十六进制 0–9， A–F (ASCII 编码)。 设备连续的监视总线上的 ‘冒<br>号’ 字符。当收到这个字符后，每个设备解码后续的字符一直到帧结束。</p><p>报文中字符间的时间间隔可以达一秒。如果有更大的间隔，则接受设备认为发生了错误。</p><p><font color=red>每个字符子节需要用两个字符编码。因此，为了确保 ASCII 模式 和 RTU 模式在 Modbus 应用级兼容，ASCII 数据域最大数据长度为 (2x252) 是 RTU 数据域 (252) 的两倍。</font></p><p> Modbus ASCII 帧的最大尺寸为 513 个字符。</p><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125103236852.png"></p><ul><li>“空闲” 态是没有发送和接收报文要处理的正常状态。</li><li>每次接收到 “:” 字符表示新的报文的开始。如果在一个报文的接收过程中收到该字符，则当前地报文被认为不完整并被丢弃。而一个新的接收缓冲区被重新分配。</li><li>检测到帧结束后，完成 LRC 计算和检验。然后，分析地址域以确定帧是否发往此设备，如果不是，则丢弃此帧。 为了减少接收处理时间，地址域可以在一接到就分析，而不需要等到整个帧结束。</li></ul><h5 id="ASCII的LRC校验"><a href="#ASCII的LRC校验" class="headerlink" title="ASCII的LRC校验"></a>ASCII的LRC校验</h5><p>在 ASCII 模式，包含一个对全部报文内容执行的，基于纵向冗余校验 (LRC - Longitudinal<br>Redundancy Checking) 算法的错误检验域。LRC 域检验不包括起始“冒号”和结尾 CRLF 对的整个报<br>文的内容。不管报文有无奇偶校验，均执行此检验。</p><p>LRC 域为一个子节，包含一个 8 位二进制值。LRC 值由发送设备计算，然后将 LRC 附在报文后面。<br>接收设备在接收报文时重新计算 LRC 的值，并将计算结果于实际接收到的 LRC 值相比较。如果两个值不相等，则为错误。</p><p>LRC 的计算, 对报文中的所有的连续 8 位字节相加，忽略任何进位，然后求出其二进制补码。执行检<br>验针对不包括起始“冒号”和结尾 CRLF 对的整个 ASCII 报文域的内容。在 ASCII 模式，LRC 的结果<br>被 ASCII 编码为两个字节并放置于 ASCII 模式报文帧的结尾，CRLF 之前。</p><h3 id="Modbus的异常码"><a href="#Modbus的异常码" class="headerlink" title="Modbus的异常码"></a>Modbus的异常码</h3><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125103418980.png"></p><p>1） 一个正确的 MODBUS 响应：响应功能码 &#x3D; 请求功能码</p><p>2） 一个 MODBUS 异常响应</p><p>3）用来为客户机提供处理过程中与被发现的差错相关的信息</p><p>4）响应功能码 &#x3D; 请求功能码 + 0x80</p><p>5）提供一个异常码来指示差错原因。</p><h3 id="Modbus的功能码"><a href="#Modbus的功能码" class="headerlink" title="Modbus的功能码"></a>Modbus的功能码</h3><p>目前Modbus的功能中可以分为三类：公共功能码、用户定义功能码、保留功能码。</p><p><img src="/imgs/Modbus-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20241125103536667.png"></p><p>公共功能码：是已经被定义的功能码。</p><p>用户定义功能码：有两个可以由用户定义功能码。范围为： 65 至 72 和十进制 100 至 110。</p><p>保留功能码：特殊情况下使用的，并且对公共使用是无效的功能码。</p>]]></content>
    
    
    <categories>
      
      <category>Protocol</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Modbus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS学习-五种内存管理方式</title>
    <link href="/2024/11/25/freertos_learn_heap/"/>
    <url>/2024/11/25/freertos_learn_heap/</url>
    
    <content type="html"><![CDATA[<!-- freertos_learn_heap--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125572135?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125572135?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="内存管理方式-1（heap-1-c）"><a href="#内存管理方式-1（heap-1-c）" class="headerlink" title="内存管理方式 1（heap_1.c）"></a>内存管理方式 1（heap_1.c）</h3><p>heap_1 动态内存管理方式是五种动态内存管理方式中最简单的，这种方式的动态内存管理一旦申请了相应内存后，是不允许被释放的。</p><p>尽管如此，这种方式的动态内存管理还是可以满足许多的嵌入式项目的，因为有些嵌入式产品在系统启动阶段就明确了任务创建、事件标志组、信号量、消息队列等资源的使用情况，而且这些资源是整个运行过程中都要一直使用的，并不打算释放或者丢弃，所以也就不需要释放内存。</p><p>FreeRTOS 的动态内存可以申请的大小范围可以在 FreeRTOSConfig.h 文件中进行了定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTOTAL_HEAP_SIZE   ( ( size_t ) ( 30 * 1024 ) ) <span class="hljs-comment">//单位字节</span></span><br></code></pre></td></tr></table></figure><p>这个宏其实是规定了操作系统的堆栈空间的总大小，动态申请的内存大小是不能操作这个这个值的。</p><p>我们可以通过函数 xPortGetFreeHeapSize 就能获得 FreeRTOS 动态内存的剩余情况，进而可以根据剩余情况优化动态内存的大小。</p><p>heap_1 方式的动态内存管理有以下特点：</p><p>​1）项目不需要删除任务、信号量、消息队列等已经创建的资源。</p><p>​2）所申请的动态内存的时间是固定的，并且不会产生内存碎片。</p><p>​3）是一种静态内存分配方案，因为申请的内存是不会被释放掉。</p><h3 id="内存管理方式-2（heap-2-c）"><a href="#内存管理方式-2（heap-2-c）" class="headerlink" title="内存管理方式 2（heap_2.c）"></a>内存管理方式 2（heap_2.c）</h3><p>heap_2 动态内存管理利用了自适应算法，并且支持内存释放，但是不支持内存碎片整理。</p><p>FreeRTOS 的动态内存可以申请的大小范围可以在 FreeRTOSConfig.h 文件中进行了定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 30 * 1024 ) ) <span class="hljs-comment">//单位字节</span></span><br></code></pre></td></tr></table></figure><p>通过函数 xPortGetFreeHeapSize 能获得 FreeRTOS 动态内存的剩余，可以根据剩余情况优化动态内存的大小。</p><p>heap_2 方式的内存管理有以下特点：</p><p>​1）在不考虑内存碎片的情况下，这种方式支持重复的任务、信号量、事件标志组、软件定时器等内部资源的创建和删除。因为不使用的资源是支持释放的，所以可以让内存资源得到反复的使用！</p><p>​2）如果申请和释放的动态内存大小是随机的，不建议采用这种动态内存管理方式。</p><p>​3）项目中需要重复的创建和删除任务，如果每次创建需要动态内存大小相同，那么 heap_2 比较适合，但每次创建需要动态内存大小不同，那么方式 heap_2 就不合适了，因为容易产生内存碎片，内存碎片过多的话会导致无法申请出一个大的内存块出来。</p><p>​4）项目中需要重复的创建和删除消息队列，也会出现类似上面的情况。</p><p>​5）直接的调用函数 pvPortMalloc() 和 vPortFree() 也容易出现内存碎片。如果按一定顺序的申请和释放，基本没有内存碎片的，而不按顺序的随机申请和释放容易产生内存碎片。</p><p>​6）如果随机的创建和删除任务、消息队列、事件标志组、信号量等内部资源也容易出现内存碎片。</p><h3 id="内存管理方式-3（heap-3-c）"><a href="#内存管理方式-3（heap-3-c）" class="headerlink" title="内存管理方式 3（heap_3.c）"></a>内存管理方式 3（heap_3.c）</h3><p>这种方式实现的内存管理是对编译器提供的 malloc 和 free 函数进行了封装，保证是线程安全的。</p><p>FreeRTOS 的动态内存大小在 FreeRTOSConfig.h 文件中进行了定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 30 * 1024 ) ) <span class="hljs-comment">//单位字节</span></span><br></code></pre></td></tr></table></figure><p>heap_3 方式的内存管理有以下特点：</p><p>​1）需要编译器提供 malloc 和 free 函数。</p><p>​2）不具有时间确定性，即申请动态内存的时间不是固定的。</p><p>​3）增加 RTOS 内核的代码量。</p><p>另外要特别注意一点，这种方式的动态内存申请和释放不是用的 FreeRTOSConfig.h 文件中定义的heap空间大小，而是用的编译器设置的heap空间大小。</p><h3 id="内存管理方式-4（heap-4-c）"><a href="#内存管理方式-4（heap-4-c）" class="headerlink" title="内存管理方式 4（heap_4.c）"></a>内存管理方式 4（heap_4.c）</h3><p>heap_4 动态内存管理利用了最适应算法，且支持内存碎片的回收并将其整理为一个大的内存块。</p><p>FreeRTOS 的动态内存大小在 FreeRTOSConfig.h 文件中进行了定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 30 * 1024 ) ) <span class="hljs-comment">//单位字节</span></span><br></code></pre></td></tr></table></figure><p>heap_4 同时支持将动态内存设置在指定的 RAM 空间位置。通过函数 xPortGetFreeHeapSize 就能获得 FreeRTOS 动态内存的剩余。</p><p>使用函数 xPortGetMinimumEverFreeHeapSize 能够获取从系统启动到当前时刻的动态内存最小剩余。</p><p>heap_4 方式的内存管理有以下特点：</p><p>​1）可以用于需要重复的创建和删除任务、信号量、事件标志组、软件定时器等资源的项目中。</p><p>​2）调用 pvPortMalloc() 和 vPortFree()，即使每次申请的内存大小都不同，也不会产生很多的内存碎片。</p><p>​3）申请动态内存的时间不是确定的。</p><h3 id="内存管理方式-5-（heap-5-c）"><a href="#内存管理方式-5-（heap-5-c）" class="headerlink" title="内存管理方式 5 （heap_5.c）"></a>内存管理方式 5 （heap_5.c）</h3><p>如果希望申请的空间可以采用不连续的内存区，比希望可以将内存定义在内部 SRAM 中的某一部分，或者外部 SRAM 的一部分，就可以采用 heap_5 动态内存管理方式。</p><p>heap_5 内存管理通过函数 vPortDefineHeapRegions 进行初始化的，即在创建任务 FreeRTOS 的内部资源前要优先调用这个函数 vPortDefineHeapRegions，否则是无法通过函数pvPortMalloc 申请到动态内存的。</p><h3 id="五种内存申请方式的比较"><a href="#五种内存申请方式的比较" class="headerlink" title="五种内存申请方式的比较"></a>五种内存申请方式的比较</h3><p>​1）heap_1.c：五种方式里面最简单的，但是申请的内存不允许释放。</p><p>​2）heap_2.c：支持动态内存的申请和释放，但是不支持内存碎片的处理，无法将碎片内存合并成一个大的内存块。</p><p>​3）heap_3.c：将编译器自带的 malloc 和 free 函数进行简单的封装，以支持线程安全，即支持多任务调用。</p><p>​4）heap_4.c：支持动态内存的申请和释放，支持内存碎片处理，支持将动态内存设置在个固定的地址（内部或者外部 RAM）。</p><p>​5）heap_5.c：在 heap_4.c 的基础上支持将动态内存设置在不连续的区域上。</p><p>其实大多数项目中使用的都是 heap_4.c 这种内存的管理方式，这种方式支持动态内存的申请和释放，支持内存碎片处理，还支持将动态内存设置在个固定的地址，对大多数的项目都有很高的满足性，基本上都能够适配上了！</p>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS学习-事件标志组</title>
    <link href="/2024/11/23/freertos_learn_event/"/>
    <url>/2024/11/23/freertos_learn_event/</url>
    
    <content type="html"><![CDATA[<!-- freertos_learn_event--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125567314?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125567314?spm&#x3D;1001.2014.3001.5502</a></p><p>假如在项目中，有些任务或者动作需要等到某种条件成立的时候才能被执行，不成立的时候不执行，这种情况就可以考虑使用事件标志组。设定一个事件标志，在项目运行过程中监控某种条件是否成立，如果条件成立了就设置这个事件标志位，另外一个地方如果发现这个标志位有效了，就执行这个任务或者动作，完成这个同步的过程。</p><h3 id="事件标志组的配置-原理"><a href="#事件标志组的配置-原理" class="headerlink" title="事件标志组的配置 &amp; 原理"></a>事件标志组的配置 &amp; 原理</h3><p><strong>选择 8 个可用的事件标志组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_16_BIT_TICKS 1</span><br></code></pre></td></tr></table></figure><p>配置宏定义 configUSE_16_BIT_TICKS 为 1 时，每创建一个事件标志组，用户可以使用的事件标志是8 个。</p><p><strong>选择 24 个可用的事件标志组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_16_BIT_TICKS 0</span><br></code></pre></td></tr></table></figure><p>配置宏定义 configUSE_16_BIT_TICKS 为 0 时，每创建一个事件标志组，用户可以使用的事件标志是24 个。</p><p>FreeRTOS的事件标志组的实现原理就是定义了一个变量，如果是 16 位变量，就仅使用了低 8bit<br>；如果定义了一个 32 位变量，就仅使用了低 24bit。</p><p>每一个 bit 用 0 和 1 两种状态来代表事件标志。</p><h3 id="事件标志组的创建"><a href="#事件标志组的创建" class="headerlink" title="事件标志组的创建"></a>事件标志组的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">EventGroupHandle_t <span class="hljs-title function_">xEventGroupCreate</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<br></code></pre></td></tr></table></figure><p>函数描述：</p><p>函数 xEventGroupCreate 用于创建事件标志组。</p><p>返回值，如果创建成功，此函数返回事件标志组的句柄，失败会返回 NULL。</p><h3 id="事件标志组的位设置"><a href="#事件标志组的位设置" class="headerlink" title="事件标志组的位设置"></a>事件标志组的位设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupSetBits</span><span class="hljs-params">( EventGroupHandle_t xEventGroup, <span class="hljs-comment">/* 事件标志组句柄 */</span></span><br><span class="hljs-params">          <span class="hljs-type">const</span> EventBits_t uxBitsToSet )</span>; <span class="hljs-comment">/* 事件标志位设置 */</span><br></code></pre></td></tr></table></figure><p>函数描述：</p><p>函数 xEventGroupSetBits 用于设置指定的事件标志位为 1。</p><p>第 1 个参数是事件标志组句柄。</p><p>第 2 个参数表示 24 个可设置的事件标志位，EventBits_t 是定义的 32 位变量，低 24 位用于事件标志设置。变量 uxBitsToSet 的低 24 位的某个位设置为 1，那么被设置的事件标志组的相应位就设置为 1。变量 uxBitsToSet 设置为 0 的位对事件标志相应位没有影响。比如设置变量 uxBitsToSet &#x3D; 0x0003 就表示将事件标志的位 0 和位 1 设置为1，其余位没有变化。</p><p>返回当前的事件标志组数值。</p><h3 id="中断中设置事件标志组"><a href="#中断中设置事件标志组" class="headerlink" title="中断中设置事件标志组"></a>中断中设置事件标志组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">BaseType_t <span class="hljs-title function_">xEventGroupSetBitsFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">    EventGroupHandle_t xEventGroup,     <span class="hljs-comment">/* 事件标志组句柄 */</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventBits_t uxBitsToSet, <span class="hljs-comment">/* 事件标志位设置 */</span></span><br><span class="hljs-params">    BaseType_t *pxHigherPriorityTaskWoken )</span>; <span class="hljs-comment">/* 高优先级任务是否被唤醒的状态保存 */</span><br></code></pre></td></tr></table></figure><p>函数描述：</p><p>函数 xEventGroupSetBits 用于设置指定的事件标志位为 1。</p><p>第 1 个参数是事件标志组句柄。</p><p>第 2 个参数表示 24 个可设置的事件标志位，EventBits_t 是定义的 32 位变量，低 24 位用于事件标志设置。变量 uxBitsToSet 的低 24 位的某个位设置为 1，那么被设置的事件标志组的相应位就设置为 1。变量 uxBitsToSet 设置为 0 的位对事件标志相应位没有影响。比如设置变量 uxBitsToSet &#x3D; 0x0003 就表示将事件标志的位 0 和位 1 设置为 1，其余位没有变化。</p><p>第3个参数用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值pdTRUE，<br>说明有高优先级任务要执行，否则没有。</p><p>返回值，如果消息成功发送给 daemon 任务（就是 FreeRTOS 的定时器任务）返回 pdPASS，否则<br>返回 pdFAIL，另外 daemon 任务中的消息队列满了也会返回 pdFAIL。</p><p>使用前一定要保证事件标志已经通过函数 xEventGroupCreate 创建了。同时要在 FreeRTOSConfig.h<br>文件中使能如下三个宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xEventGroupSetBitFromISR 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIMERS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTimerPendFunctionCall 1</span><br></code></pre></td></tr></table></figure><h3 id="事件标志组的位清除"><a href="#事件标志组的位清除" class="headerlink" title="事件标志组的位清除"></a>事件标志组的位清除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupClearBits</span><span class="hljs-params">(</span><br><span class="hljs-params">                                 EventGroupHandle_t xEventGroup,</span><br><span class="hljs-params">                                 <span class="hljs-type">const</span> EventBits_t uxBitsToClear )</span>;<br></code></pre></td></tr></table></figure><p>函数描述：</p><p>xEventGroup：需要操作的事件标志组；</p><p>uxBitsToClear：要清零的事件位，比如要清楚bit2就设置为0x04。</p><p>返回值：将指定事件位清零之前的事件组值。</p><h3 id="等待时间标志组中的指定位被设置"><a href="#等待时间标志组中的指定位被设置" class="headerlink" title="等待时间标志组中的指定位被设置"></a>等待时间标志组中的指定位被设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupWaitBits</span><span class="hljs-params">(</span><br><span class="hljs-params">                    <span class="hljs-type">const</span> EventGroupHandle_t xEventGroup,  <span class="hljs-comment">/* 事件标志组句柄 */</span></span><br><span class="hljs-params">                    <span class="hljs-type">const</span> EventBits_t uxBitsToWaitFor,     <span class="hljs-comment">/* 等待被设置的事件标志位 */</span></span><br><span class="hljs-params">                    <span class="hljs-type">const</span> BaseType_t xClearOnExit,         <span class="hljs-comment">/* 选择是否清零被置位的事件标志位 */</span></span><br><span class="hljs-params">                    <span class="hljs-type">const</span> BaseType_t xWaitForAllBits,      <span class="hljs-comment">/* 选择是否等待所有标志位都被设置 */</span></span><br><span class="hljs-params">                    TickType_t xTicksToWait )</span>;             <span class="hljs-comment">/* 设置等待时间 */</span><br></code></pre></td></tr></table></figure><p>函数描述：</p><p>函数 xEventGroupWaitBits 等待事件标志被设置。</p><p>第 1 个参数是事件标志组句柄。</p><p>第 2 个参数表示等待 24 个事件标志位中的指定标志，EventBits_t 是定义的 32 位变量，低 24 位用于事件标志设置。比如设置变量 uxBitsToWaitFor &#x3D; 0x0003 就表示等待事件标志的位 0 和位 1 设置为 1。此参数切不可设置为 0。</p><p>第 3 个参数选择是否清除已经被置位的事件标志，如果这个参数设置为 pdTRUE，且函数<br>xEventGroupWaitBits 在参数 xTicksToWait 设置的溢出时间内返回，那么相应被设置的事件标志<br>位会被清零。如果这个参数设置为 pdFALSE，对已经被设置的事件标志位没有影响。</p><p>第 4 个参数选择是否等待所有的标志位都被设置，如果这个参数设置为 pdTRUE，要等待第 2 个参<br>数 uxBitsToWaitFor 所指定的标志位全部被置 1，函数才可以返回。当然，超出了在参数<br>xTicksToWait 设置的溢出时间也是会返回的。如果这个参数设置为 pdFALSE，第 2 个参数<br>uxBitsToWaitFor 所指定的任何标志位被置 1，函数都会返回，超出溢出时间也会返回。</p><p>第 5 个参数设置等待时间，单位时钟节拍周期。如果设置为 portMAX_DELAY，表示永久等待。<br>返回值：由于设置的时间超时或者指定的事件标志位被置 1，导致函数退出时返回的事件标志组数值。</p><h3 id="删除事件标志组"><a href="#删除事件标志组" class="headerlink" title="删除事件标志组"></a>删除事件标志组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vEventGroupDelete</span><span class="hljs-params">( EventGroupHandle_t xEventGroup )</span>;<br>xEventGroup：要删除的时间标志组<br></code></pre></td></tr></table></figure><h3 id="事件标志组的示例demo"><a href="#事件标志组的示例demo" class="headerlink" title="事件标志组的示例demo"></a>事件标志组的示例demo</h3><p>代码中创建了两个任务和一个24bit可用的时间标志组，一个任务通过按键扫描设置事件标志组的值，通过按键按三下设置事件标志组的值为0x00000008，然后另外一个任务阻塞等待，直到检测到事件标志组被设置为0x00000008之后翻转LED的闪烁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">EventGroupHandle_t FlagEventGroup;  <span class="hljs-comment">//事件标志组</span><br>FlagEventGroup = xEventGroupCreate();   <span class="hljs-comment">//创建事件标志组 24bit可用</span><br><br><span class="hljs-comment">//task1任务函数 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">task1_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> <span class="hljs-comment">//prio = 2</span><br>&#123;<br>    u8 keyVal = <span class="hljs-number">0</span>;<br>    EventBits_t FlagVal;<br>    u32 setVal = <span class="hljs-number">0x0001</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        keyVal = KEY_Scan(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(keyVal == KEY0_PRES) <br>        &#123;<br>           FlagVal = xEventGroupSetBits(FlagEventGroup, setVal); <br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;事件标志组设置值为：%d\r\n&quot;</span>,FlagVal);<br>           xEventGroupClearBits(FlagEventGroup, setVal);<span class="hljs-comment">//清除标志位</span><br>           setVal &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        LED1 ^= <span class="hljs-number">1</span>;<br>        vTaskDelay(<span class="hljs-number">200</span>);   <span class="hljs-comment">//延时n个时钟节拍</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//task2任务函数  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">task2_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> <span class="hljs-comment">//prio = 3</span><br>&#123;<br>    u32 i,j;<br>    u32 TxStr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>        xEventGroupWaitBits(FlagEventGroup,<span class="hljs-comment">//事件标志组句柄</span><br>                            <span class="hljs-number">0x0008</span>,<span class="hljs-comment">//等待 24 个事件标志位中的指定标志</span><br>                            pdFALSE,<span class="hljs-comment">//是否清除已经被置位的事件标志，pdTRUE - 清除，pdFALSE - 不清除</span><br>                            pdFALSE,<span class="hljs-comment">//是否等待所有的标志位都被设置，pdTRUE - 是，pdFALSE - 不是</span><br>                            portMAX_DELAY <span class="hljs-comment">//等待时间，单位时钟节拍周期</span><br>                           );<br>        <br>        LED0 ^= <span class="hljs-number">1</span>;<br><br>        vTaskDelay(<span class="hljs-number">500</span>);       <span class="hljs-comment">//延时n个时钟节拍</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS学习-配置项</title>
    <link href="/2024/11/23/freertos_learn_config/"/>
    <url>/2024/11/23/freertos_learn_config/</url>
    
    <content type="html"><![CDATA[<!-- freertos_learn_config--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125562063?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125562063?spm&#x3D;1001.2014.3001.5502</a></p><p>FreeRTOS的大部分配置项都在文件 FreeRTOSConfig.h 和 FreeRTOS.h 中，这两个文件中有很多的宏定义，用于系统的配置和裁剪，是很重要的文件</p><p>想要更加详细的了解相关的宏的作用和使用方法，可以参考freeRTOS官网给出的有关说明，链接如下：<br><a href="https://www.freertos.org/a00110.html#configUSE_PREEMPTION">https://www.freertos.org/a00110.html#configUSE_PREEMPTION</a></p><h3 id="系统调度模式的选择"><a href="#系统调度模式的选择" class="headerlink" title="系统调度模式的选择"></a>系统调度模式的选择</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PREEMPTION1</span><br></code></pre></td></tr></table></figure><p>这个宏就是用于配置系统的调度模式的，调度模式选择如下：</p><p>0 - 合作式调度，任务之间根据时间片轮流的进行执行；</p><p>1 - 抢占式调度，即优先级高的任务可以抢占低优先级任务的运行权，优先执行；<br>系统要求实时响应的话，该宏配置为 1 即可。</p><h3 id="tickless-低功耗模式"><a href="#tickless-低功耗模式" class="headerlink" title="tickless 低功耗模式"></a>tickless 低功耗模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICKLESS_IDLE    0</span><br></code></pre></td></tr></table></figure><p>0 - 禁能 tickless 低功耗模式</p><p>1 - 使能 tickless 低功耗模式</p><h3 id="系统主频的设置"><a href="#系统主频的设置" class="headerlink" title="系统主频的设置"></a>系统主频的设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCPU_CLOCK_HZ( 72000000 )</span><br></code></pre></td></tr></table></figure><p>这个宏用于配置CPU的主频，单位是Hz。这个数值要根据所用的cpu的实际时钟大小进行设置。比如：<br>STM32F103的主频最高位72MHz，STM32F407的主频为168MHz，这个不要填错。</p><h3 id="系统心跳的速率"><a href="#系统心跳的速率" class="headerlink" title="系统心跳的速率"></a>系统心跳的速率</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTICK_RATE_HZ(1000 )</span><br></code></pre></td></tr></table></figure><p>心跳速率也称为系统滴答，即系统每秒钟滴答的次数。比如上面配置为1000，就是把1秒分成了1000份，每一份为 1 毫秒。</p><h3 id="系统最大的优先级"><a href="#系统最大的优先级" class="headerlink" title="系统最大的优先级"></a>系统最大的优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_PRIORITIES( 5 )</span><br></code></pre></td></tr></table></figure><p>这个宏用于配置系统最大可用的优先级。比如上面设置为 5，所以系统可以用的优先级为 0 - 4，5是不能用的。如果优先级超过这个设定，系统会忽略不处理。</p><p>注意：FreeRTOS中优先级数值越大，优先级越高。而UCOS则相反。</p><h3 id="最小堆栈的设置"><a href="#最小堆栈的设置" class="headerlink" title="最小堆栈的设置"></a>最小堆栈的设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMINIMAL_STACK_SIZE( 128 )</span><br></code></pre></td></tr></table></figure><p>在系统中，这个宏用于配置一些任务的堆栈空间的大小，一般用于空闲、定时等一些系统任务中。<br>注意：这个配置的单位是字，而不是字节！在RAM中，一个字是4byte！！</p><h3 id="系统总堆栈大小"><a href="#系统总堆栈大小" class="headerlink" title="系统总堆栈大小"></a>系统总堆栈大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTOTAL_HEAP_SIZE( 30 * 1024 ) </span><br></code></pre></td></tr></table></figure><p>这个宏用于设定系统的可用堆栈的总量大小（单位为字）。</p><p>使用时需要根据MCU的RAM和项目开发的功能情况定义这个值。不能定义太小，太小内存容易溢出；也不能定义太大，如果芯片RAM容量不够大，会导致变量定义失败，或分配其他堆栈空间时申请不到空间。</p><h3 id="任务名称最大长度"><a href="#任务名称最大长度" class="headerlink" title="任务名称最大长度"></a>任务名称最大长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_TASK_NAME_LEN( 25 )</span><br></code></pre></td></tr></table></figure><p>这个宏用于定义任务名称允许的最大字符串长度。</p><p>注意：结束符“\0”也包括在内。</p><h3 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MUTEXES1</span><br></code></pre></td></tr></table></figure><p>互斥信号量是一种很重要的同步手段。一般用于资源共享的“加锁” 和任务优先级反转上。</p><p>它可以实现多任务间对共享资源的独占和保护。即在某个资源在某个时刻只允许一个任务使用，使用完之后才允许其他任务使用该共享资源。</p><p>比如：任务A是高优先级任务，B是低优先级任务；A、B任务都用同一个串口发送指令数据，（每次必须发送完整，不能被打断）。当任务B正在发送数据时，任务A要打断任务B，任务B就需要使用互斥信号占有该串口，等发送完数据之后，再释放该串口给任务A使用。</p><h3 id="信号量计数功能"><a href="#信号量计数功能" class="headerlink" title="信号量计数功能"></a>信号量计数功能</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_COUNTING_SEMAPHORES1</span><br></code></pre></td></tr></table></figure><p>0 - 不使用信号量计数功能</p><p>1 - 使用信号量计数功能</p><h3 id="使能任务间直接的消息传递"><a href="#使能任务间直接的消息传递" class="headerlink" title="使能任务间直接的消息传递"></a>使能任务间直接的消息传递</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TASK_NOTIFICATIONS    1</span><br></code></pre></td></tr></table></figure><p>0 - 禁止任务间直接的消息传递</p><p>1 - 使能任务间直接的消息传递，包含信号量，事件标志组和消息邮箱。</p><h3 id="版本兼容性选择"><a href="#版本兼容性选择" class="headerlink" title="版本兼容性选择"></a>版本兼容性选择</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configENABLE_BACKWARD_COMPATIBILITY    1</span><br></code></pre></td></tr></table></figure><p>0 - 新旧版本不兼容</p><p>1 - 新旧版本之间可兼容，即新版本兼容老版本</p><h3 id="获取任务运行信息"><a href="#获取任务运行信息" class="headerlink" title="获取任务运行信息"></a>获取任务运行信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configGENERATE_RUN_TIME_STATS0</span><br></code></pre></td></tr></table></figure><p>0 - 禁止获取任务运行状态参数</p><p>1 - 使能任务运行状态参数统计</p><h3 id="开启软件定时器"><a href="#开启软件定时器" class="headerlink" title="开启软件定时器"></a>开启软件定时器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIMERS1</span><br></code></pre></td></tr></table></figure><p>通过将这个宏设置为1来使能软件定时器功能。</p><h3 id="配置软件定时器任务的优先级"><a href="#配置软件定时器任务的优先级" class="headerlink" title="配置软件定时器任务的优先级"></a>配置软件定时器任务的优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_PRIORITY( 3 )</span><br></code></pre></td></tr></table></figure><p>软件定时器的实现是基于系统心跳实现的，管理软件定时器本质也是由一个定时器任务进行的，所以也是需要设置定时器任务的优先级的。具体的优先级根据自己项目的实际情况设置吧！</p><h3 id="软件定时器命令队列的长度"><a href="#软件定时器命令队列的长度" class="headerlink" title="软件定时器命令队列的长度"></a>软件定时器命令队列的长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_QUEUE_LENGTH10</span><br></code></pre></td></tr></table></figure><p>说白了，FreeRTOS的软件定时器其实是通过消息队列实现的。具体的数值根据你使用到多个软件定时器而定吧！</p><h3 id="软件定时器任务的栈空间"><a href="#软件定时器任务的栈空间" class="headerlink" title="软件定时器任务的栈空间"></a>软件定时器任务的栈空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_STACK_DEPTH128</span><br></code></pre></td></tr></table></figure><p>软件定时器任务的堆栈空间的大小，和创建任务一样，也要给软件定时器任务分配堆栈空间。</p><h3 id="断言设置"><a href="#断言设置" class="headerlink" title="断言设置"></a>断言设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configASSERT( ( x ) ) <span class="hljs-keyword">if</span>( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )</span><br></code></pre></td></tr></table></figure><p>关键字 <strong>LINE</strong> 表示源代码行号，关键字__FILE__表示源代码文件名,函数 vAssertCalled 里面调用串口打印之类的功能，将出现错误的源文件和代码行号打印出来,比较方便！</p>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS学习-消息队列</title>
    <link href="/2024/11/23/freertos_learn_queue/"/>
    <url>/2024/11/23/freertos_learn_queue/</url>
    
    <content type="html"><![CDATA[<!-- freertos_learn_queue--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125555241?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125555241?spm&#x3D;1001.2014.3001.5502</a></p><h2 id="FreeRTOS的消息队列"><a href="#FreeRTOS的消息队列" class="headerlink" title="FreeRTOS的消息队列"></a>FreeRTOS的消息队列</h2><p>FreeRTOS中提供了任务之间互相通信的另外的一种手段——消息队列。它的作用主要有：<br>1）为了在任务与任务之间、任务与中断之间的通信而准备的，可以在任务与任务之间，任务与中断之间传递消息；<br>2）消息队列可以存储有限的、大小固定的数据项目；</p><p>它具有的特点有几个：<br>1）FreeRTOS中的消息队列传递的是一个实际的数据，而不是数据的地址。在RTX、ucos-ii、ucos-iii中的消息队列传递的是消息的地址。<br>2）消息队列不属于某个特定的任务，任何的任务都可以向队列中发送消息，也可以从队列中提取消息。<br>3）消息队列所能容纳的最大的数据项目就是队列的长度。</p><h3 id="FreeRTOS的消息队列的管理"><a href="#FreeRTOS的消息队列的管理" class="headerlink" title="FreeRTOS的消息队列的管理"></a>FreeRTOS的消息队列的管理</h3><p><strong>队列的出队方式 &amp; 数据存储</strong></p><p>通常的队列都是采取先进先出（FIFO）的存储缓冲机制方式，即往队列中发送消息的时候永远是先发到队列的尾部，而从队列中提取消息的时候是从头部提取的。同时FreeRTOS也支持 后进先出（LIFO）的方式。<br>因为FreeRTOS的消息队列传递的是实际的数据，所以数据发送到队列中会导致数据拷贝，会浪费一些时间。但是好处在于一旦消息被拷贝到了消息队列中，那么原始的数据缓冲区或者数据就可以删除或者改变，达到反复利用的效果。</p><p><strong>队列的阻塞</strong></p><p>队列阻塞的作用是在当任务从队列中获取消息的时候，所指定的一个等待时间。队列在出队和入队都是可以设置阻塞的。有三种阻塞的时间：<br>不等待：不等待直接执行之后的内容（为0不等待）；</p><p>定时等待：任务等待一个固定的时间间隔，可以为 0 ~ portMAX_DELAY；</p><p>一直等待：设置为 portMAX_DELAY 的时候，会一直等待。</p><h3 id="FreeRTOS的队列的实现"><a href="#FreeRTOS的队列的实现" class="headerlink" title="FreeRTOS的队列的实现"></a>FreeRTOS的队列的实现</h3><p><img src="/imgs/FreeRTOS%E5%AD%A6%E4%B9%A0-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20241123101027534.png"></p><p><img src="/imgs/FreeRTOS%E5%AD%A6%E4%B9%A0-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20241123101112971.png"></p><p><strong>消息队列的两种通信方式</strong></p><p><img src="/imgs/FreeRTOS%E5%AD%A6%E4%B9%A0-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20241123101302746.png"></p><h3 id="FreeRTOS-消息队列实现的API函数"><a href="#FreeRTOS-消息队列实现的API函数" class="headerlink" title="FreeRTOS 消息队列实现的API函数"></a>FreeRTOS 消息队列实现的API函数</h3><p><strong>创建消息队列</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t <span class="hljs-title function_">xQueueCreate</span><span class="hljs-params">( UBaseType_t uxQueueLength, <span class="hljs-comment">/* 消息个数 */</span></span><br><span class="hljs-params">     UBaseType_t uxItemSize )</span>;  <span class="hljs-comment">/* 每个消息大小，单位字节 */</span><br><br></code></pre></td></tr></table></figure><p>函数描述：<br>函数 xQueueCreate 用于创建消息队列。<br>第 1 个参数是消息队列支持的消息个数。即队列长度。<br>第 2 个参数是每个消息的大小，单位字节。<br>返回值：如果创建成功会返回消息队列的句柄，失败会返回 NULL。</p><p>使用这个函数要注意以下问题：<br>1）FreeRTOS 的消息传递是数据的复制，而不是传递的数据地址，这点要特别注意。每一次传递都是<br>uxItemSize 个字节。<br>2.）uxItemSize：所要发送&#x2F;接收的消息队列的总字节数。比如要发送10个消息，每个消息占4个字节，所以<br>uxItemSize &#x3D; 4(byte) * 10(个) &#x3D; 40 Byte</p><p><strong>向消息队列中发送消息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueSend</span><span class="hljs-params">(</span><br><span class="hljs-params">    QueueHandle_t xQueue,       <span class="hljs-comment">/* 消息队列句柄 */</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue, <span class="hljs-comment">/* 要传递数据地址 */</span></span><br><span class="hljs-params">    TickType_t xTicksToWait     <span class="hljs-comment">/* 等待消息队列有空间的最大等待时间 */</span></span><br><span class="hljs-params">               )</span>;<br><br></code></pre></td></tr></table></figure><p>函数描述：<br>函数 xQueueSend 用于任务中消息发送。<br>第 1 个参数：是消息队列句柄。<br>第 2 个参数：要传递的数据地址，每次发送都是将消息队列创建函数 xQueueCreate 所指定的单个消息大<br>小复制到消息队列空间中。<br>第 3 个参数：是当消息队列已经满时，等待消息队列有空间时的最大等待时间，单位为系统时钟节拍。<br>返回值：如果消息成功发送返回 pdTRUE，否则返回errQUEUE_FULL。</p><p>使用这个函数要注意以下问题：<br>1）FreeRTOS 的消息传递是数据的复制，而不是传递的数据地址。</p><p>2）此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是<br>xQueueSendFromISR。</p><p>3）如果消息队列已经满且第三个参数为 0，那么此函数会立即返回。</p><p>4）如果用户将 FreeRTOSConfig.h 文件中的宏定义INCLUDE_vTaskSuspend 配置为 1 且第三个参数配<br>置为 portMAX_DELAY，那么此发送函数会永久等待直到消息队列有空间可以使用。</p><p>5）消息队列还有两个函数 xQueueSendToBack 和 xQueueSendToFront，函数 xQueueSendToBack<br>实现的是 FIFO 方式的存取，函数 xQueueSendToFront 实现的是 LIFO 方式的读写。一般说的函<br>数 xQueueSend 等效于 xQueueSendToBack，即实现的是 FIFO 方式的存取。</p><p><strong>从消息队列中读取消息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueReceive</span><span class="hljs-params">(</span><br><span class="hljs-params">    QueueHandle_t xQueue, <span class="hljs-comment">/* 消息队列句柄 */</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *pvBuffer, <span class="hljs-comment">/* 接收消息队列数据的缓冲地址 */</span></span><br><span class="hljs-params">    TickType_t xTicksToWait <span class="hljs-comment">/* 等待消息队列有数据的最大等待时间 */</span></span><br><span class="hljs-params">          )</span>;<br><br></code></pre></td></tr></table></figure><p>函数描述：<br>函数 xQueueReceive 用于接收消息队列中的数据。<br>第 1 个参数：是消息队列句柄。<br>第 2 个参数：是从消息队列中复制出数据后所储存的缓冲地址，缓冲区空间要大于等于消息队列创建函<br>数 xQueueCreate 所指定的单个消息大小，否则取出的数据无法全部存储到缓冲区，从而造成内存溢<br>出。<br>第 3 个参数：是消息队列为空时，等待消息队列有数据的最大等待时间，单位系统时钟节拍。<br>返回值：如果接到到消息返回 pdTRUE，否则返回 pdFALSE。</p><p>使用这个函数要注意以下问题：<br>1）此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序使用的是<br>xQueueReceiveFromISR 。</p><p>2）如果消息队列为空且第三个参数为 0，那么此函数会立即返回。</p><p>3）如果将 FreeRTOSConfig.h 文件中的宏定义 INCLUDE_vTaskSuspend 配置为 1 且第三个参数配<br>置为 portMAX_DELAY，那么此函数会永久等待直到消息队列有数据。</p><p><strong>队列初始化函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvInitialiseNewQueue</span><span class="hljs-params">( <span class="hljs-type">const</span> UBaseType_t uxQueueLength, <span class="hljs-comment">//队列长度</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> UBaseType_t uxItemSize,    <span class="hljs-comment">//队列项目长度</span></span><br><span class="hljs-params">        <span class="hljs-type">uint8_t</span> *pucQueueStorage,  <span class="hljs-comment">//队列项目的存储区</span></span><br><span class="hljs-params">            <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> ucQueueType,  <span class="hljs-comment">//队列类型</span></span><br><span class="hljs-params">               Queue_t *pxNewQueue )</span> <span class="hljs-comment">//队列结构</span><br><br></code></pre></td></tr></table></figure><p><strong>队列复位</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueGenericReset</span><span class="hljs-params">( QueueHandle_t xQueue, BaseType_t xNewQueue )</span><br></code></pre></td></tr></table></figure><p>创建两个任务，一个任务发送三个数据给另外一个任务，另一个任务接收并打印，循环发送，每次发送都对发送的数据增加后发送。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span>、创建消息队列<br>QueueHandle_t     NewQueue;<span class="hljs-comment">//消息队列</span><br>NewQueue  = xQueueCreate(<span class="hljs-number">3</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*<span class="hljs-number">3</span>); <span class="hljs-comment">//这一步非常重要，所需字节数 = 每个消息的字节数*队列长度</span><br><br><span class="hljs-number">2</span>、发送消息队列 &amp;&amp; 接收消息队列<br><span class="hljs-comment">//task1任务函数 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">task1_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> <span class="hljs-comment">//prio = 2</span><br>&#123;<br><br>    u32 recStr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        xQueueReceive(NewQueue, recStr, <span class="hljs-number">0</span>);<span class="hljs-comment">//接收消息队列</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tx0 = %d Tx1 = %d Tx2 = %d\r\n&quot;</span>,recStr[<span class="hljs-number">0</span>],recStr[<span class="hljs-number">1</span>],recStr[<span class="hljs-number">2</span>]);<br>        LED1 ^= <span class="hljs-number">1</span>;<br>        vTaskDelay(<span class="hljs-number">200</span>);   <span class="hljs-comment">//延时n个时钟节拍</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//task2任务函数  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">task2_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> <span class="hljs-comment">//prio = 3</span><br>&#123;<br><br>    u32 TxStr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>        xQueueSend(NewQueue, TxStr, portMAX_DELAY);<span class="hljs-comment">//发送消息队列</span><br>        TxStr[<span class="hljs-number">0</span>] ++;<br>        TxStr[<span class="hljs-number">1</span>] += <span class="hljs-number">5</span>;<br>        TxStr[<span class="hljs-number">2</span>] += <span class="hljs-number">10</span>;<br>        LED0 ^= <span class="hljs-number">1</span>;<br><br>        vTaskDelay(<span class="hljs-number">500</span>);       <span class="hljs-comment">//延时n个时钟节拍</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS学习-消息邮箱</title>
    <link href="/2024/11/23/freertos_learn_Notify/"/>
    <url>/2024/11/23/freertos_learn_Notify/</url>
    
    <content type="html"><![CDATA[<!-- freertos_learn_Notify--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125539750?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125539750?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="FreeRTOS中的消息邮箱"><a href="#FreeRTOS中的消息邮箱" class="headerlink" title="FreeRTOS中的消息邮箱"></a>FreeRTOS中的消息邮箱</h3><p>FreeRTOS实现的消息邮箱是基于任务通知方式而实现的。</p><p>FreeRTOS中的消息邮箱使用是比较灵活的，它可以实现二值信号量、计数信号量、事件标志组、消息队列等通知方式。</p><p>但用这种 方式实现信号量和事件标志组也有它的局限性，主要表现在以下两个方面：</p><p>​1）任务通知方式仅可以用在只有一个任务等待信号量，消息邮箱或者事件标志组的情况。</p><p>​2）如果使用任务通知方式实现消息邮箱替代消息队列时，发送消息的任务是不支持超时等待的。在消息队列中，当数据已经满时，是可以等待消息队列有空间才存新的数据的，但是任务通知方式实现的消息邮箱就不支持超时等待。</p><h3 id="有关FreeRTOS中的任务控制块"><a href="#有关FreeRTOS中的任务控制块" class="headerlink" title="有关FreeRTOS中的任务控制块"></a>有关FreeRTOS中的任务控制块</h3><p>FreeRTOS中的每一个任务都有一个任务控制块，而任务控制块本质就是一个结构体变量，用于记录任务的相关的消息。</p><p>而在结构体变量中有一个32位的变量成员ulNotifiedValue是可以专门用于任务通知的。这个变量可以实现计数信号量，二值信号量，事件标志组和消息邮箱（消息邮箱就是消息队 列长度为 1 的情况）。</p><p>ulNotifiedValue 实现的：</p><p>​1）设置接收任务控制块中的变量 ulNotifiedValue 可以实现消息邮箱。</p><p>​2）如果接收任务控制块中的变量 ulNotifiedValue 还没有被其接收到，也可以用新数据覆盖原有数据 ，这就是覆盖方式的消息邮箱。</p><p>​3）设置接收任务控制块中的变量 ulNotifiedValue 的 bit0-bit31 数值可以实现事件标志组。</p><p>​4）设置接收任务控制块中的变量 ulNotifiedValue 数值进行加一或者减一操作可以实现计数信号量和二值信号量。</p><h2 id="FreeRTOS中消息邮箱的管理API函数"><a href="#FreeRTOS中消息邮箱的管理API函数" class="headerlink" title="FreeRTOS中消息邮箱的管理API函数"></a>FreeRTOS中消息邮箱的管理API函数</h2><h4 id="消息邮箱的创建"><a href="#消息邮箱的创建" class="headerlink" title="消息邮箱的创建"></a>消息邮箱的创建</h4><p>FreeRTOS中的消息邮箱是用于任务之间的一种通知方式，它的使用是不需要像信号量这样要专门创建的。是直接发送通知的。</p><h4 id="消息邮箱的发送"><a href="#消息邮箱的发送" class="headerlink" title="消息邮箱的发送"></a>消息邮箱的发送</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskNotify</span><span class="hljs-params">( TaskHandle_t xTaskToNotify, <span class="hljs-comment">/* 任务句柄 */</span> </span><br><span class="hljs-params">                        <span class="hljs-type">uint32_t</span> ulValue, <span class="hljs-comment">/* 更新任务控制块中的变量 ulNotifiedValue */</span>             </span><br><span class="hljs-params">                        eNotifyAction eAction )</span>; <span class="hljs-comment">/* 任务通知模式设置 */</span><br></code></pre></td></tr></table></figure><p>使用这个函数要注意以下问题：</p><p>​    1）任务创建后，任务控制块中的变量 ulNotifiedValue 初始计数值是 0。</p><p>​    2）默认配置此函数可以使用的的宏定义已经在 FreeRTOS.h 文件中使能：#define configUSE_TASK_NOTIFICATIONS 1  如果不需要使用任务通知功能相关的函数，可以在 FreeRTOSConfig.h 文件中配置此宏定 义为 0 来禁止，这样创建的每个任务可以节省 8 个字节的需求。</p><p>​    3）此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是 xTaskNotifyFromISR。</p><p>​    4）根据 FreeRTOS 的建议，实现二值信号量和计数信号量时使用函数 xTaskNotifyGive()替代此函数 xTaskNotify()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskNotifyFromISR</span><span class="hljs-params">( </span><br><span class="hljs-params">                                TaskHandle_t xTaskToNotify, <span class="hljs-comment">/* 任务句柄 */</span> </span><br><span class="hljs-params">                                <span class="hljs-type">uint32_t</span> ulValue, <span class="hljs-comment">/* 更新任务控制块中的变量 ulNotifiedValue */</span> </span><br><span class="hljs-params">                                eNotifyAction eAction, <span class="hljs-comment">/* 任务通知模式设置 */</span> </span><br><span class="hljs-params">                                BaseType_t *pxHigherPriorityTaskWoken )</span>; <span class="hljs-comment">/* 高优先级任务是否被唤醒的状态保存 */</span><br></code></pre></td></tr></table></figure><h4 id="等待消息邮箱"><a href="#等待消息邮箱" class="headerlink" title="等待消息邮箱"></a>等待消息邮箱</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskNotifyWait</span><span class="hljs-params">( </span><br><span class="hljs-params">                    <span class="hljs-comment">/* 设置函数执行前清零任务控制块中变量 ulNotifiedValue 那些位 */</span> </span><br><span class="hljs-params">                    <span class="hljs-type">uint32_t</span> ulBitsToClearOnEntry, </span><br><span class="hljs-params"> </span><br><span class="hljs-params">                    <span class="hljs-comment">/*设置函数退出前清零任务控制块中变量 ulNotifiedValue 那些位 */</span> </span><br><span class="hljs-params">                    <span class="hljs-type">uint32_t</span> ulBitsToClearOnExit, </span><br><span class="hljs-params"> </span><br><span class="hljs-params">                    <span class="hljs-comment">/* 保存任务控制块中的变量 ulNotifiedValue 到指针变量 pulNotifiedValue 所指向的存储单元 */</span> </span><br><span class="hljs-params">                    <span class="hljs-type">uint32_t</span> *pulNotificationValue, </span><br><span class="hljs-params"> </span><br><span class="hljs-params">                    <span class="hljs-comment">/* 等待消息通知的最大等待时间 */</span> </span><br><span class="hljs-params">                    TickType_t xTicksToWait )</span>;<br></code></pre></td></tr></table></figure><h3 id="消息邮箱的应用示例"><a href="#消息邮箱的应用示例" class="headerlink" title="消息邮箱的应用示例"></a>消息邮箱的应用示例</h3><p>创建3个任务：start_task,led0_task,led2_task。start_task任务用于创建led0_task和led2_task任务，led0_task任务判断按键的情况，然后根据按键按下，消息邮箱发送不同的消息到任务led2_task，在这个任务中改变LED2和LED3的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">start_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span><br>&#123;<br>    pvParameters =  pvParameters;<br>    taskENTER_CRITICAL();  <span class="hljs-comment">//进入临界区</span><br>  <br>    xTaskCreate((TaskFunction_t)  led0_task,<br>                 (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)    <span class="hljs-string">&quot;led0_task&quot;</span>,<br>                  (<span class="hljs-type">uint16_t</span>)      TASK_STK_LED0_SIZE,<br>                  (<span class="hljs-type">void</span>*)         <span class="hljs-literal">NULL</span>,<br>                  (UBaseType_t)   TASK_LED0_PRIO,<br>                  (TaskHandle_t*) &amp;LED0_Handler );<br>                  <br>    xTaskCreate((TaskFunction_t)  led2_task,<br>                 (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)    <span class="hljs-string">&quot;led2_task&quot;</span>,<br>                  (<span class="hljs-type">uint16_t</span>)      TASK_STK_LED2_SIZE,<br>                  (<span class="hljs-type">void</span>*)         <span class="hljs-literal">NULL</span>,<br>                  (UBaseType_t)   TASK_LED2_PRIO,<br>                  (TaskHandle_t*) &amp;LED2_Handler );<br>    vTaskDelete(StartTask_Handler);   <span class="hljs-comment">//删除开始任务</span><br>    taskEXIT_CRITICAL();   <span class="hljs-comment">//退出临界区</span><br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">led0_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span><br>&#123;<br>  <span class="hljs-comment">//pvParameters =  pvParameters;</span><br>  BaseType_t err = pdFALSE;<br>  <span class="hljs-type">uint32_t</span> MboxValue=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(;;)<br>  &#123; <br>     <span class="hljs-keyword">if</span>(gd_eval_key_state_get(KEY_WAKEUP) == RESET)<br>     &#123;<br>       MboxValue = <span class="hljs-number">10</span>;<br>       err = xTaskNotify((TaskHandle_t )  LED2_Handler, <span class="hljs-comment">//任务句柄，指明往哪个任务发送消息，很重要</span><br>                         (<span class="hljs-type">uint32_t</span> )      MboxValue,    <span class="hljs-comment">//发送的消息</span><br>                         (eNotifyAction)  eSetValueWithOverwrite <span class="hljs-comment">//消息发送方式</span><br>                        );<br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(gd_eval_key_state_get(KEY_TAMPER) == RESET)<br>     &#123;<br>       MboxValue = <span class="hljs-number">50</span>;<br>       err = xTaskNotify((TaskHandle_t )  LED2_Handler, <span class="hljs-comment">//任务句柄</span><br>                         (<span class="hljs-type">uint32_t</span> )     MboxValue,     <span class="hljs-comment">//发送的消息</span><br>                         (eNotifyAction) eSetValueWithOverwrite <span class="hljs-comment">//消息发送方式</span><br>                        );<br>     &#125;<br>     <span class="hljs-keyword">else</span>&#123;&#125;<br>     gd_eval_led_toggle(LED4);<br>     vTaskDelay(<span class="hljs-number">200</span>);<br>  &#125;<br>&#125; <br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">led2_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span><br>&#123;<br>  <span class="hljs-comment">//pvParameters = pvParameters; </span><br>  <span class="hljs-type">uint32_t</span> notifyValue = <span class="hljs-number">0</span>;<br>  BaseType_t err;<br>  <span class="hljs-keyword">for</span>(;;)<br>  &#123;<br>     err = xTaskNotifyWait((<span class="hljs-type">uint32_t</span> )  <span class="hljs-number">0x00</span>,         <span class="hljs-comment">//进入函数时不清楚bit</span><br>                           (<span class="hljs-type">uint32_t</span>)   <span class="hljs-number">0xffffffff</span>,   <span class="hljs-comment">//退出函数时清除所有的bit</span><br>                           (<span class="hljs-type">uint32_t</span>*)  &amp;notifyValue, <span class="hljs-comment">//保存消息的内容</span><br>                           (TickType_t) portMAX_DELAY <span class="hljs-comment">//阻塞时间</span><br>                          );<br>    <span class="hljs-keyword">if</span>(err == pdTRUE)<br>    &#123;<br>       <span class="hljs-keyword">switch</span>(notifyValue)     <br>       &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>           gd_eval_led_toggle(LED2);<br>           <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">50</span>:<br>           gd_eval_led_toggle(LED3);<br>           <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>           <span class="hljs-keyword">break</span>;<br>       &#125;<br>    &#125;<br>    vTaskDelay(<span class="hljs-number">100</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS学习-信号量与优先级反转</title>
    <link href="/2024/11/22/freertos_learn_Semaphore/"/>
    <url>/2024/11/22/freertos_learn_Semaphore/</url>
    
    <content type="html"><![CDATA[<!-- freertos_learn_Semaphore--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125528885?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125528885?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="FreeRTOS学习-信号量与优先级反转"><a href="#FreeRTOS学习-信号量与优先级反转" class="headerlink" title="FreeRTOS学习-信号量与优先级反转"></a>FreeRTOS学习-信号量与优先级反转</h3><p>FreeRTOS中最常用到的信号量有：二值信号量、计数信号量、互斥信号量。</p><h4 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h4><p>二值信号量是指所创建的信号量只有两个值（0 和 1），通常用于互斥访问或者同步。</p><p> 二值信号量在某处被占有使用之后，其他地方想要申请这个二值信号量是无法成功申请的，只有当这个被占有的二值信号量被使用完毕并释放之后，才能被再次申请占有使用！</p><p>总而言之，二值信号量被使用之后会变为无效状态，需要被重新释放才能进入有效状态。</p><h4 id="创建二值信号量"><a href="#创建二值信号量" class="headerlink" title="创建二值信号量"></a>创建二值信号量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">SemaphoreHandle_t xSemaphoreCreateBinary(void)<br></code></pre></td></tr></table></figure><p>函数描述：</p><p>​    函数 xSemaphoreCreateBinary 用于创建二值信号量。</p><p>​    返回值：如果创建成功会返回二值信号量的句柄，创建失败会返回 NULL。</p><h4 id="等待二值信号量"><a href="#等待二值信号量" class="headerlink" title="等待二值信号量"></a>等待二值信号量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 复制">xSemaphoreTake( SemaphoreHandle_t xSemaphore,     /* 信号量句柄 */ <br>                TickType_t xTicksToWait );        /* 等待信号量可用的最大等待时间 */<br></code></pre></td></tr></table></figure><p>函数 xSemaphoreTake 用于在任务代码中获取信号量。</p><h4 id="在中断中等待信号量"><a href="#在中断中等待信号量" class="headerlink" title="在中断中等待信号量"></a>在中断中等待信号量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )<br></code></pre></td></tr></table></figure><h4 id="释放二值信号量"><a href="#释放二值信号量" class="headerlink" title="释放二值信号量"></a>释放二值信号量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); /* 信号量句柄 */<br></code></pre></td></tr></table></figure><p>返回值，如果信号量释放成功返回 pdTRUE，否则返回 pdFALSE，因为信号量的实现是基于消息队列，返回失败的主要原因是消息队列已经满了。</p><h4 id="用于在中断中释放二值信号量"><a href="#用于在中断中释放二值信号量" class="headerlink" title="用于在中断中释放二值信号量"></a>用于在中断中释放二值信号量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 复制">xSemaphoreGiveFromISR(    SemaphoreHandle_t xSemaphore, <br>                          signed BaseType_t *pxHigherPriorityTaskWoken)<br></code></pre></td></tr></table></figure><h3 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h3><p>计数信号量是一个相当于长度大于1的队列，用于任务之间的同步和共享资源的保护。</p><p>计数信号量与二值信号量的不同在于，二值信号量只能被一个地方申请使用，只有在这个申请使用的地方了释放了才能被其他处申请使用。而计数信号量是可以创建一定数量的信号量的，多个地方可以同时申请使用，直到达到最大的计数信号量的阈值。</p><h4 id="创建计数信号量"><a href="#创建计数信号量" class="headerlink" title="创建计数信号量"></a>创建计数信号量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 复制">SemaphoreHandle_t xSemaphoreCreateCounting( <br>                                            UBaseType_t uxMaxCount, /* 支持的最大计数值 */                                                     <br>                                            UBaseType_t uxInitialCount); /* 初始计数值 */<br></code></pre></td></tr></table></figure><h3 id="优先级反转-互斥信号量"><a href="#优先级反转-互斥信号量" class="headerlink" title="优先级反转 &amp; 互斥信号量"></a>优先级反转 &amp; 互斥信号量</h3><p>在实时操作系统中，优先级反转的问题是不容忽视的，程序设计的过程中，也是要充分考虑这个问题的。</p><p>那优先级反转到底是什么呢？</p><p>优先反转是指：假如一个系统中有高（H）、中（M）、低（L）三个优先级的任务，并有一个二值信号量。在某一个时刻二值信号量被低（L）优先级的任务使用了，并在运行过程中，高优先级任务（H）抢占了低优先级（L）的CPU使用权，但是也想要获取二值信号量被低优先（L）的任务占有着，高优先级任务（H）由此被挂起等待了，中优先级任务（M）因为不需要二值信号量，会抢占低优先级（L）任务的执行而得到运行，而高优先级任务（H）依然只能等到低优先级任务（L）释放二值信号量才能得到执行。</p><p>由此造成了高优先级任务得不到及时的执行，而低优先级任务却能比高优先级任务更多的得到执行。</p><p><img src="/imgs/FreeRTOS%E5%AD%A6%E4%B9%A0-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC/image-20241122171402197.png"></p><p>解决优先级反转的问题最好的办法是使用互斥信号量。</p><p>互斥信号量和二值信号量比较相似，不同之处在于互斥信号量具有优先级继承的特性，如果一个互斥信号量正在被一个低优先级的任务使用，而此时这个高优先级的任务也希望获取这个互斥信号量的话就会被阻塞。</p><p>使用互斥信号量时，高优先级的任务会把低优先级的任务的优先级先提高到和自己相同的优先级，保证低优先级的任务能够继续运行至结束这样极大减少了因为高优先级获取不到信号量被阻塞过长时间的问题。</p><h4 id="创建互斥信号量"><a href="#创建互斥信号量" class="headerlink" title="创建互斥信号量"></a>创建互斥信号量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">SemaphoreHandle_t xSemaphoreCreateMutex(void)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS学习-任务的创建与管理</title>
    <link href="/2024/11/20/freertos_learn_task/"/>
    <url>/2024/11/20/freertos_learn_task/</url>
    
    <content type="html"><![CDATA[<!-- freertos_learn_task--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125505717?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125505717?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="FreeRTOS学习-任务的创建与管理"><a href="#FreeRTOS学习-任务的创建与管理" class="headerlink" title="FreeRTOS学习-任务的创建与管理"></a>FreeRTOS学习-任务的创建与管理</h3><h3 id="FreeRTOS的任务"><a href="#FreeRTOS的任务" class="headerlink" title="FreeRTOS的任务"></a>FreeRTOS的任务</h3><p><strong>任务的状态</strong></p><p>FreeRTOS中，任务在运行时，可能出现以下几种状态：</p><p>1）运行态。任务当前正在运行中，占有cpu的使用权。        </p><p> 2）就绪态。满足了运行条件，但是当前没有运行，可能是有高优先级任务在执行或者在中断，处于等待获得cpu使用权然后运行的状态中 。</p><p>3）阻塞态。在某些条件下被阻塞了，不能得到运行。比如等待某些信号量，消息队列或者调用了延迟函数。</p><p>4）挂起态。任务被通过调用挂起操作被终止执行了，直到被从挂起状态中恢复为止，否则将一直处于挂起的状态中。</p><p><strong>任务的优先级</strong></p><p><font color=red> FreeRTOS的任务优先级是数值越大，任务的优先级越高。</font></p><p>FreeRTOS 中任务的最高优先级是通过 <strong>FreeRTOSConfig.h</strong> 文件中的configMAX_PRIORITIES进行配置的，用户实际可以使用的优先级范围是 0 到 configMAX_PRIORITIES – 1。</p><p><strong>FreeRTOS 的任务切换的实现</strong></p><p><em>PendSV中断</em></p><p>freeRTOS系统的任务切换的具体过程最终都是在pendSV中断服务函数里面完成的。</p><p><strong>PendSV</strong>是一种不精确的异常处理，优先级和挂起状态可以通过编程实现，一般在实时操作系统中 <strong>PendSV</strong> 的优先级都会被设置为最低，在其他所有的异常中断处理完以后才执行，对上下文的切换非常有用。</p><p><em>Systick中断</em></p><p> <strong>Systick</strong>中断服务函数中会进行任务切换。</p><h3 id="FreeRTOS的任务管理的API函数"><a href="#FreeRTOS的任务管理的API函数" class="headerlink" title="FreeRTOS的任务管理的API函数"></a>FreeRTOS的任务管理的API函数</h3><p><img src="/imgs/FreeRTOS%E5%AD%A6%E4%B9%A0-%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86/image-20241122165504131.png"></p><h3 id="FreeRTOS任务创建"><a href="#FreeRTOS任务创建" class="headerlink" title="FreeRTOS任务创建"></a>FreeRTOS任务创建</h3><p>在freeRTOS中，可以根据实际使用的需要创建一定数量的任务(线程)，任务只有被成功创建了，才有可能被执行到。</p><p>在FreeRTOS实时操作系统中，创建任务可以使用如下的API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs 复制"><br>portBASE_TYPE xTaskCreate(<br> <br>         pdTASK_CODE pvTaskCode,<br> <br>         const char * const pcName,<br> <br>         unsigned short usStackDepth,<br> <br>         void *pvParameters,<br> <br>         unsigned portBASE_TYPE uxPriority,<br> <br>         xTaskHandle *pvCreatedTask<br> <br>        );<br> <br>函数参数说明：<br> <br>    pvTaskCode：指向任务入口函数的指针。即任务函数。<br> <br>    pcName：任务的描述。一般都是为了调试方便而使用的。由 tskMAX_TASK_NAME_LEN 定义的最大长度，默认为 16。<br> <br>    usStackDepth：任务堆栈的大小。不是字节数而是以字为单位。例如，如果堆栈为 16 位宽，并且             usStackDepth 定义为 100，则将分配 200 个字节用于堆栈存储。<br> <br>    pvParameters：任务的参数的指针。可以向创建的任务中传入参数，不需要传送参数可以选NULL。<br> <br>    uxPriority：任务运行的优先级。<br> <br>    pvCreatedTask：任务的句柄，通过该句柄引用创建的任务。<br> <br>返回值：<br></code></pre></td></tr></table></figure><p>创建一个任务的示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 复制">xTaskCreate((TaskFunction_t )Start_Task,            //任务函数<br> <br>            (const char*    )&quot;Start_Task&quot;,          //任务名称<br> <br>            (uint16_t       )128,                   //任务堆栈大小<br> <br>            (void *         )NULL,                  //传递给任务函数的参数<br> <br>            (UBaseType_t    )5,                     //任务优先级<br> <br>            (TaskHandle_t * )&amp;StartTask_Handler);   //任务句柄<br></code></pre></td></tr></table></figure><p>任务的优先级要根据 FreeRTOSConfig.h 文件中的 configMAX_PRIORITIES进行设置的，可以使用的优先级范围是 <strong>0 到 configMAX_PRIORITIES – 1</strong>，如果创建的任务所选的任务优先级超过了这个设置的范围，会被忽略掉，不会被执行。</p><h3 id="FreeRTOS任务挂起"><a href="#FreeRTOS任务挂起" class="headerlink" title="FreeRTOS任务挂起"></a>FreeRTOS任务挂起</h3><p>当任务在系统运行过程中，因为某些条件或者有其他的更加重要的事情要做的时候，可以考虑把某些任务先挂起，等候条件到达之后再恢复任务继续调度运行。</p><p>挂起任务的函数为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 复制">void vTaskSuspend( xTaskHandle pxTaskToSuspend )<br> <br>参数：<br> <br>    pxTaskToSuspend：需要被挂起的任务的优先级<br> <br>返回值：无<br></code></pre></td></tr></table></figure><p>要使用这个函数，需要在 <strong>FreeRTOSConfig.h</strong>中将宏定义 <strong>INCLUDE_vTaskSuspend</strong> 定义为 1</p><p>此外，如果要挂起、恢复整个系统所有的任务，freeRTOS也提供了一个API函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 复制">void vTaskSuspendAll( void )  // 挂起所有的任务<br> <br>BaseType_t xTaskResumeAll( void ) // 恢复所有被挂起的任务<br></code></pre></td></tr></table></figure><h3 id="FreeRTOS任务删除"><a href="#FreeRTOS任务删除" class="headerlink" title="FreeRTOS任务删除"></a>FreeRTOS任务删除</h3><p>如果有某些任务只是需要存在于某些条件，当条件满足之后就不再需要这个任务参与运行，这个时候可以选择删除掉这个任务，释放该任务所占用的堆栈空间。</p><p>删除任务可以使用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 复制">void vTaskDelete( xTaskHandle pxTask )<br> <br>参数：<br> <br>    pxTask：需要被删除的任务句柄<br> <br>返回值：无<br></code></pre></td></tr></table></figure><p>要使用这个函数，需要将宏定义 <strong>INCLUDE_vTaskDelete</strong> 设置为 1 。</p><h2 id="FreeRTOS的内核管理函数"><a href="#FreeRTOS的内核管理函数" class="headerlink" title="FreeRTOS的内核管理函数"></a>FreeRTOS的内核管理函数</h2><p><img src="/imgs/FreeRTOS%E5%AD%A6%E4%B9%A0-%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86%5Cimage-20241122170042089.png"></p>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI协议</title>
    <link href="/2024/11/20/spi_protocol/"/>
    <url>/2024/11/20/spi_protocol/</url>
    
    <content type="html"><![CDATA[<!--spi_protocol--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125439812?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125439812?spm&#x3D;1001.2014.3001.5502</a></p><p>SPI协议是由摩托罗拉公司提出的一种串行外围设备通信接口，是一种高速全双工的通信总线。</p><h3 id="SPI-的硬件层"><a href="#SPI-的硬件层" class="headerlink" title="SPI 的硬件层"></a>SPI 的硬件层</h3><p>SPI是采用主从模式的一种通信方式，它支持一主一从、一主多从，但是不支持多主机模式。</p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\SPI协议\image-20241120144932393.png) --><p><img src="/imgs/SPI%E5%8D%8F%E8%AE%AE/image-20241120144934860.png"></p><h3 id="SPI接口的信号线"><a href="#SPI接口的信号线" class="headerlink" title="SPI接口的信号线"></a>SPI接口的信号线</h3><p>SPI接口共有四根信号线，它们分别如下：</p><ul><li>SCLK：时钟信号线。由主机产生并控制。</li><li>MOSI：主机数据输出，从机数据输入。（主出从入）</li><li>MISO：主机数据输入，从机数据输出。（主入从出）</li><li>NSS：从机片选使能信号线。该信号由主机进行控制。在一主对多从的模式下，每一个从机都需要一个NSS，用于主机选择和那个从机进行通信（一般为低电平有效）。当一个SPI设备需要发送广播数据，它必须拉低NSS信号，以通知所有其它的设备它是主设备。</li></ul><h3 id="SPI通信常见的连接方式"><a href="#SPI通信常见的连接方式" class="headerlink" title="SPI通信常见的连接方式"></a>SPI通信常见的连接方式</h3><p><strong>全双工的连接方式：</strong></p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\SPI协议\image-20241120155713133.png) --><p><img src="/imgs/SPI%E5%8D%8F%E8%AE%AE/image-20241120155715602.png"></p><p> 这种连接方式允许主从机之间互相进行通信，时钟均由主机产生。</p><p><strong>单工模式 —— 主机接收，从机发送</strong></p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\SPI协议\image-20241120155759178.png) --><p><img src="/imgs/SPI%E5%8D%8F%E8%AE%AE/image-20241120155800696.png"></p><p>这种模式下由主机产生时钟SCK，主机只能收到从机上报的数据，不能向从机下发数据。</p><p><strong>单工模式 —— 主机发送，从机接收</strong></p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\SPI协议\image-20241120155847266.png) --><p><img src="/imgs/SPI%E5%8D%8F%E8%AE%AE/image-20241120155847928.png"></p><p>​    这种模式下由主机产生时钟SCK，主机只能向从机下发数据，不能接收从机上报的数据。常见的应用有带SPI接口的LCD显示屏。</p><p><strong>双向通信的连接方式</strong></p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\SPI协议\image-20241120155948960.png) --><p><img src="/imgs/SPI%E5%8D%8F%E8%AE%AE/image-20241120155949852.png"></p><h3 id="SPI的通信协议"><a href="#SPI的通信协议" class="headerlink" title="SPI的通信协议"></a>SPI的通信协议</h3><p> SPI的协议定义了通信的起始信号、停止信号、数据有效性、时钟同步等。</p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\SPI协议\image-20241120160034813.png) --><p><img src="/imgs/SPI%E5%8D%8F%E8%AE%AE/image-20241120160035535.png"></p><p>这是一个主机的通信时序，信号线 NSS、SCK、MOSI 都是由主机控制，MISO 是由从机进行控制。其中 MOSI 和 MISO 上的数据仅在 NSS 为低时才有效，并且每个SCK 时钟周期只交换一位数据。</p><h4 id="起始信号"><a href="#起始信号" class="headerlink" title="起始信号"></a>起始信号</h4><p>由主机控制NSS从高电平到低电平，从而选择要进行通信的从机，再通过主机产生时钟信号SCK，启动一次数据的传输</p><h4 id="停止信号"><a href="#停止信号" class="headerlink" title="停止信号"></a>停止信号</h4><p>由主机控制NSS从低电平到高电平，从而结束一次数据的传输。</p><h4 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h4><p>SPI 在 SCK 时钟的同步下进行数据的准备和采样，在 NSS 为低的情况时，在 SCK 的上升沿时 MISO 和 MOSI 进行数据准备，SCK 的下降沿时读取 MISO 和 MOSI 上的数据。在 NSS 为高时，MISO 和MOSI 上的数据无效。</p><h3 id="时钟的同步"><a href="#时钟的同步" class="headerlink" title="时钟的同步"></a>时钟的同步</h3><p>SPI 的数据传输是需要 SCK 时钟信号严格同步的，每一个 SCK 周期只传输一位数据，这一个周期里要完成数据的准备和采样，且数据的输入和输出是同时进行的。</p><p>SPI中数据是MSB 先行或 LSB先行，在协议中是没有硬性规定，只需通信双方保持统一即可。</p><p>SPI 一次数据传输可以是 8 位或 16 位为单位，每次传输的单位数不受限制。</p><h3 id="SPI的四种工作模式"><a href="#SPI的四种工作模式" class="headerlink" title="SPI的四种工作模式"></a>SPI的四种工作模式</h3><p> SPI 一共有四种工作模式。它们的区别是：</p><p>​    1）总线空闲时 SCK 的电平状态</p><p>​    2）数据开始采样的时刻。</p><p>这四种模式是通过 “时钟极性 CPOL” 和 “时钟相位 CPHA” 的电平来实现和区分的。如下：</p><p>1）CPOL&#x3D;0 时，SCK 引脚在空闲状态保持低电平；</p><p>2）CPOL&#x3D;1 时，SCK 引脚在空闲状态保持高电平；</p><p>3）CPHA&#x3D;0 时，SCK 时钟的第一个边沿进行采样；</p><p> 4）CPHA &#x3D;1 时，SCK 时钟的第二个边沿进行采样。</p>]]></content>
    
    
    <categories>
      
      <category>Protocol</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RS-485协议</title>
    <link href="/2024/11/20/rs485_protocol/"/>
    <url>/2024/11/20/rs485_protocol/</url>
    
    <content type="html"><![CDATA[<!-- rs485_protocol--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125423065?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125423065?spm&#x3D;1001.2014.3001.5502</a></p><p>RS-485是美国电子工业协会（EIA）在1983年批准的一种信号传输标准，它只是一个电气的标准，不涉及上层协议的规定，仅仅是接口的物理层规定</p><h3 id="RS-485的特性"><a href="#RS-485的特性" class="headerlink" title="RS-485的特性"></a>RS-485的特性</h3><p>1）采用差分信号进行传输，增加了抗噪声能力，减少噪声辐射带来的干扰；<br>2）支持长距离传输，最长可以达到4000英尺（约1219米）；<br>3）传输速率较高，在40英尺内，速率可高达10Mbps；<br>4）同一总线可以连接多个驱动器和接收器；<br>5）共模电压范围大，允许的最大共模电压可达到 -7V - 12V；</p><h3 id="RS-485常见的电路连接方式"><a href="#RS-485常见的电路连接方式" class="headerlink" title="RS-485常见的电路连接方式"></a>RS-485常见的电路连接方式</h3><!-- ![](C:\Users\w6530\MyBlog\source\imgs\RS-485协议\image-20241120142829087.png) --><p><img src="/imgs/RS-485%E5%8D%8F%E8%AE%AE/image-20241120142829697.png"></p><p>R0为发送引脚，DI为接收引脚，RE&#x2F;DE为收发控制引脚。485芯片每次只能单独一个方向传输数据，不能收发同时进行，而且收发必须要控制收发引脚的电平状态才能实现收发的功能。</p><h3 id="RS-485的电平信号"><a href="#RS-485的电平信号" class="headerlink" title="RS-485的电平信号"></a>RS-485的电平信号</h3><p>RS-485采用的是差分信号的方式进行传输，通过AB两根线的电压差作为电平信号，差分信号对外界因素的干扰反映到两根线上影响是一样的，两根线的电压差不变，信号传递也就不会受干扰，因此会有更强的抗噪声干扰能力。</p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\RS-485协议\image-20241120143007252.png) --><p><img src="/imgs/RS-485%E5%8D%8F%E8%AE%AE/image-20241120143008144.png"></p><p>RS-485差分线路包括以下2个信号：<br><strong>A</strong>：非反向（non-inverting）信号<br><strong>B</strong>：反向（inverting）信号<br><strong>逻辑1</strong>：线路B信号电压比线路A高。一般 +2V ~ +6V。<br><strong>逻辑0</strong>：线路A信号电压比线路B高。一般 -2V ~ -6V。</p><p>根据RS485总线的相关标准，当RS485总线差分电压大于+200mV时，RS485收发器输出高电平；当RS485总线差分电压小于-200mV时，RS485收发器输出低电平；当RS485总线上的电压在-200mV～+200mV之间时，RS485收发器可能输出高电平也可能输出低电平。<br>因此，为了防止RS-485总线上的差分电压处于-200mV～+200mV之间，就需要利用上拉下拉电阻来钳位总线上电压差值。上下拉电阻的阻止一般选用4.7K，实际需要多大的电阻，需要根据实际线路负载和电路情况计算选值。</p><h3 id="RS-485总线上的收发器数量"><a href="#RS-485总线上的收发器数量" class="headerlink" title="RS-485总线上的收发器数量"></a>RS-485总线上的收发器数量</h3><p>RS-485总线上可以带的发射器和接收器的最大数量是和负载特性有关的。<br>根据485的规定文件中的说明，一根传输总线上最多可以挂载128个收发器。</p><h3 id="RS-485总线的工作方式"><a href="#RS-485总线的工作方式" class="headerlink" title="RS-485总线的工作方式"></a>RS-485总线的工作方式</h3><p>半双工与全双工。</p><h4 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h4><!-- ![](C:\Users\w6530\MyBlog\source\imgs\RS-485协议\image-20241120143256246.png) --><p><img src="/imgs/RS-485%E5%8D%8F%E8%AE%AE/image-20241120143257317.png"></p><h4 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h4><!-- ![](C:\Users\w6530\MyBlog\source\imgs\RS-485协议\image-20241120143353739.png) --><p><img src="/imgs/RS-485%E5%8D%8F%E8%AE%AE/image-20241120143354565.png"></p><h3 id="RS-485的总线终端电阻"><a href="#RS-485的总线终端电阻" class="headerlink" title="RS-485的总线终端电阻"></a>RS-485的总线终端电阻</h3><p>为避免信号反射，当通信线路长度很长时数据传输线必须有终点，并且分支长度尽可能的短。正确的通信线路终端需要终端电阻RT匹配，RS-485标准建议线缆的 Z0&#x3D;120Ω。<br>通信线路通常终端匹配120Ω的电阻，线缆的末尾处各一个</p>]]></content>
    
    
    <categories>
      
      <category>Protocol</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RS485</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IIC协议</title>
    <link href="/2024/11/20/iic_protocol/"/>
    <url>/2024/11/20/iic_protocol/</url>
    
    <content type="html"><![CDATA[<!-- iic_protocol--><span id="more"></span><p>转载自<a href="https://blog.csdn.net/weixin_43866583/article/details/125407605?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43866583&#x2F;article&#x2F;details&#x2F;125407605?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="IIC协议的诞生"><a href="#IIC协议的诞生" class="headerlink" title="IIC协议的诞生"></a>IIC协议的诞生</h3><p>IIC协议最早1982年由飞利浦公司设计开发，是一种两线制（SDA + SCL）的串行通信方式，提供了主从机之间通行的一种方案，在今天也是被广泛的应用在很多的产品设备上。</p><p>一个使用IIC协议进行通信的设备，它既可以作为主机又可以作为从机（支持多主多从），并且它是一种半双工的通信方式。</p><p>IIC可以支持的通信速率范围较大，可以很好的满足多种设备的不同的通信速度的要求，它支持的速率有如下几个：</p><p>1）普通模式（100kHz即100kbps）<br>2）快速模式(Fm）（400kHz）<br>3）快速模式+(Fs+)（1MHz）<br>4）高速模式(Hs）（3.4MHz）<br>5）超高速模式(UFm)（5MHz）</p><h3 id="IIC总线的术语说明"><a href="#IIC总线的术语说明" class="headerlink" title="IIC总线的术语说明"></a>IIC总线的术语说明</h3><!-- ![](C:\Users\w6530\MyBlog\source\imgs\IIC协议\image-20241120134437440.png) --><p><img src="/imgs/IIC%E5%8D%8F%E8%AE%AE/image-20241120134450282.png"></p><h3 id="SDA-线和-SCL线"><a href="#SDA-线和-SCL线" class="headerlink" title="SDA 线和 SCL线"></a>SDA 线和 SCL线</h3><p>IIC设备有两条接口线：串行数据 SDA 线和串行时钟 SCL 线。</p><p>连接到IIC总线上的设备通过这两根线互相传递信息，SDA 和 SCL 都是双向线，可以互相之间进行信息的交互，但是是一种同步半双工的通信方式，同一时刻只能有一个方向进行数据的操作，不能同时进行。</p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\IIC协议\image-20241120134930368.png) --><p><img src="/imgs/IIC%E5%8D%8F%E8%AE%AE/image-20241120135008477.png"></p><h3 id="IIC总线协议"><a href="#IIC总线协议" class="headerlink" title="IIC总线协议"></a>IIC总线协议</h3><!-- ![](C:\Users\w6530\MyBlog\source\imgs\IIC协议\image-20241120135106749.png) --><p><img src="/imgs/IIC%E5%8D%8F%E8%AE%AE/image-20241120135106749.png"></p><h3 id="IIC总线的起始信号"><a href="#IIC总线的起始信号" class="headerlink" title="IIC总线的起始信号"></a>IIC总线的起始信号</h3><p>发送启动信号时，时钟线SCL需要稳定的保持在高电位，SDA由高电位变化为低电位。启动信号发送完成之后就可以进行数据的发送了。</p><p>如果在一次通信过程中，有两台以上的设备同时发出了起始信号，都希望获得总线控制权的话，那么第一个发出起始信号的设备将获得总线控制权，作为主设备开始传输数据。<br>注意：起始信号由主机负责产生。</p><h3 id="停止信号"><a href="#停止信号" class="headerlink" title="停止信号"></a>停止信号</h3><p>停止信号是在时钟线SCL为高电位的时候，数据线SDA由低电平变化为高电平。停止信号一般是在通信完成之后或者通信失败退出之后发送的。<br>注意：停止信号由主机负责产生。</p><h3 id="数据传输与有效性"><a href="#数据传输与有效性" class="headerlink" title="数据传输与有效性"></a>数据传输与有效性</h3><p>IIC协议要求在时钟信号SCL为高电位的期间，数据线SDA上的数据要保持稳定，不能发生变化。只有在时钟信号SCL电位变低的时候，数据线SDA上的电平状态才能发生跳变。<br>每一个数据的bit位传输需要一个时钟脉冲，一次传输最多是8bit。</p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\IIC协议\image-20241120140151269.png) --><p><img src="/imgs/IIC%E5%8D%8F%E8%AE%AE/image-20241120140153360.png"></p><p>通信开始时，最开始发送的都是地址帧。比如，一个7Bit的地址，首先发出的是最高位，即读写位（1-读，0-写），用于指示是读操作还是写操作。</p><p>帧的第9位是应答位（ACK&#x2F;NACK）。所有帧（数据或地址）都是一样的。一旦发送帧的前8位，接收设备就可以控制数据线SDA。如果接收设备在第9个时钟脉冲没有将SDA线拉低进行应答，则可能是接收设备没有接收到数据，或者出现错误。在这种情况下，主机需要决定该做什么样的处理（一般考虑重发或者退出）。</p><p>注意：SCL时钟信号由主机负责产生。数据的发送是高位先发的！</p><h3 id="总线的仲裁"><a href="#总线的仲裁" class="headerlink" title="总线的仲裁"></a>总线的仲裁</h3><p>IIC总线支持多个主机同时在总线上发送数据，但是同一时刻只能有一个主机传送数据。因此必须要通过某些手段来决定哪个主机获得总线的控制权，其它的没有获得主机控制权的设备就只能进行等待，直到获得总线控制权才能进行数据的传输。</p><p>IIC总线仲裁的方式有两种：时钟同步、仲裁。</p><h3 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h3><p>时钟同步是通过时钟线SCL来实现的。在时钟信号SCL由高到低的切换过程中，IIC器件会开始数自身的低电平周期。当主器件的时钟信号变为低电平的时候，它会使SCL线保持这个电平状态直到达到高电平。假如这个时候有另外一个器件的时钟依然是处于低电平的周期，这个时钟的低到高的变化不会改变SCL线的状态。</p><p>因此，SCL线被有着最长的低电平周期的器件占有总线的控制权，而这个时候低电平周期短的器件会进入高电平的等待状态，直到当前的主器件释放总线控制权，自身能够获得总线控制权才会改变这些状态。</p><h3 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h3><p>仲裁和同步一样，都是为了解决多主机情况下的总线控制冲突。仲裁的过程与从机无关。</p><p>只有在总线空闲的时候主机才可以启动传输。两个主机可能在比较短的时间内在总线上同时产生一个有效的起始信号，这种情况下需要仲裁来决定由哪个主机占有总线控制权来完成数据传输。</p><p>仲裁是逐位进行，在每一位数据的仲裁期间，当时钟线SCL为高电平时，每个主机都检查数据总线SDA上的电平是否和自己要发送的相同。</p><p>这个过程需要持续很多位。理论上讲，如果两个主机所传输的内容完全相同，那么他们能够成功传输而不出现错误。但是，如果一个主机发送高电平但检测到SDA总线上的电平为低时，则认为自己仲裁失败并关闭自己的SDA数据线上的数据传输，而另一个主机则继续完成自己的传输。</p><h3 id="IIC通信的流程"><a href="#IIC通信的流程" class="headerlink" title="IIC通信的流程"></a>IIC通信的流程</h3><p>每个I2C设备都通过唯一的器件地址进行识别，根据设备功能，他们既可以是发送器也可作为接收器。通信的流程如下：</p><p>1）IIC从机检测到IIC总线上的起始信号之后，就开始从总线上接收地址，之后会把从总线接收到的地址和自身的器件地址（通过软件编程）进行比较，一旦两个地址相同，IIC从机将发送一个确认应答（ACK），并响应总线的后续命令；</p><p>2）发送或接收所数据；</p><p>3）发送或接收完成之后，在收到应答信号ACK之后结束数据的传输。</p><p>此外，如果软件开启了广播呼叫，则IIC从机始终对一个广播地址 （0x00）发送确认应答。I2C模块始终支持7位和10位的地址。</p><h3 id="地址帧的发送"><a href="#地址帧的发送" class="headerlink" title="地址帧的发送"></a>地址帧的发送</h3><p><strong>7 位地址的 IIC 通讯流程</strong></p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\IIC协议\image-20241120141541800.png) --><p><img src="/imgs/IIC%E5%8D%8F%E8%AE%AE/image-20241120141543024.png"></p><p>7Bit地址的通信中，开始信号之后的第一帧是地址帧+读写位，刚好是8Bit的数据，直接发送，等待从设备应答之后便可以进行数据的通信。</p><p><strong>10 位地址的 IIC 通讯流程（主机发送）</strong></p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\IIC协议\image-20241120141716825.png) --><p> <img src="/imgs/IIC%E5%8D%8F%E8%AE%AE/image-20241120141718784.png"> </p><p>对于10-bit地的址设备，需要使用两个帧来传输10Bit的slave地址。</p><p>第一个帧的前5个bit固定为b11110xx，后接slave地址的高2位，第8位仍然是读写(R&#x2F;W)位，接着是一个ACK位，由于总线上可能有多个10 Bit 从设备地址的高2bit相同，因此这个ACK可能由多有slave设备返回。</p><p>第二个帧紧接着第一帧发送，包含slave地址的低8位（7:0），接着该地址的slave回复一个ACK（或NACK）。RS-485协议</p><p>注意：10-bit地址的设备和7-bit地址的设备在总线中是可以并存的，因为7-bit地址的高5位不可能是b11110。</p><p><strong>10 位地址的 I2C 通讯流程（主机接收）</strong></p><!-- ![](C:\Users\w6530\MyBlog\source\imgs\IIC协议\image-20241120141856456.png)  --><p><img src="/imgs/IIC%E5%8D%8F%E8%AE%AE/image-20241120141900401.png"></p>]]></content>
    
    
    <categories>
      
      <category>Protocol</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IIC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT基础学习</title>
    <link href="/2024/11/18/mqtt_learn/"/>
    <url>/2024/11/18/mqtt_learn/</url>
    
    <content type="html"><![CDATA[<!-- mqtt_learn --><span id="more"></span><h2 id="什么是-MQTT？"><a href="#什么是-MQTT？" class="headerlink" title="什么是 MQTT？"></a>什么是 MQTT？</h2><p>MQTT（Message Queuing Telemetry Transport）是一种轻量级、基于发布-订阅模式的消息传输协议，适用于资源受限的设备和低带宽、高延迟或不稳定的网络环境。它在物联网应用中广受欢迎，能够实现传感器、执行器和其它设备之间的高效通信。</p><h2 id="为什么-MQTT-是适用于物联网的最佳协议？"><a href="#为什么-MQTT-是适用于物联网的最佳协议？" class="headerlink" title="为什么 MQTT 是适用于物联网的最佳协议？"></a>为什么 MQTT 是适用于物联网的最佳协议？</h2><p>MQTT 所具有的适用于物联网特定需求的特点和功能，使其成为物联网领域最佳的协议之一。它的主要特点包括：</p><ul><li><strong>轻量级：</strong>物联网设备通常在处理能力、内存和能耗方面受到限制。MQTT 开销低、报文小的特点使其非常适合这些设备，因为它消耗更少的资源，即使在有限的能力下也能实现高效的通信。</li><li><strong>可靠：</strong>物联网网络常常面临高延迟或连接不稳定的情况。MQTT 支持多种 QoS 等级、会话感知和持久连接，即使在困难的条件下也能保证消息的可靠传递，使其非常适合物联网应用。</li><li><strong>安全通信：</strong>安全对于物联网网络至关重要，因为其经常涉及敏感数据的传输。为确保数据在传输过程中的机密性，MQTT 提供传输层安全（TLS）和安全套接层（SSL）加密功能。此外，MQTT 还通过用户名&#x2F;密码凭证或客户端证书提供身份验证和授权机制，以保护网络及其资源的访问。</li><li><strong>双向通信：</strong>MQTT 的发布-订阅模式为设备之间提供了无缝的双向通信方式。客户端既可以向主题发布消息，也可以订阅接收特定主题上的消息，从而实现了物联网生态系统中的高效数据交换，而无需直接将设备耦合在一起。这种模式也简化了新设备的集成，同时保证了系统易于扩展。</li><li><strong>连续、有状态的会话：</strong>MQTT 提供了客户端与 Broker 之间保持有状态会话的能力，这使得系统即使在断开连接后也能记住订阅和未传递的消息。此外，客户端还可以在建立连接时指定一个保活间隔，这会促使 Broker 定期检查连接状态。如果连接中断，Broker 会储存未传递的消息（根据 QoS 级别确定），并在客户端重新连接时尝试传递它们。这个特性保证了通信的可靠性，降低了因间断性连接而导致数据丢失的风险。</li><li><strong>大规模物联网设备支持：</strong>物联网系统往往涉及大量设备，需要一种能够处理大规模部署的协议。MQTT 的轻量级特性、低带宽消耗和对资源的高效利用使其成为大规模物联网应用的理想选择。通过采用发布-订阅模式，MQTT 实现了发送者和接收者的解耦，从而有效地减少了网络流量和资源使用。此外，协议对不同 QoS 等级的支持使得消息传递可以根据需求进行定制，确保在各种场景下获得最佳的性能表现。</li><li><strong>语言支持：</strong>物联网系统包含使用各种编程语言开发的设备和应用。MQTT 具有广泛的语言支持，使其能够轻松与多个平台和技术进行集成，从而实现了物联网生态系统中的无缝通信和互操作性。您可以阅读我们的 <a href="https://www.emqx.com/zh/blog/category/mqtt-programming">MQTT 客户端编程</a>系列文章，学习如何在 PHP、Node.js、Python、Golang、Node.js 等编程语言中使用 MQTT。</li></ul><h2 id="MQTT-的工作原理"><a href="#MQTT-的工作原理" class="headerlink" title="MQTT 的工作原理"></a>MQTT 的工作原理</h2><p>要了解 MQTT 的工作原理，首先需要掌握以下几个概念：MQTT 客户端、MQTT Broker、发布-订阅模式、主题、QoS。</p><p><strong>MQTT 客户端</strong></p><p>任何运行 <a href="https://www.emqx.com/zh/mqtt-client-sdk">MQTT 客户端库</a>的应用或设备都是 MQTT 客户端。例如，使用 MQTT 的即时通讯应用是客户端，使用 MQTT 上报数据的各种传感器是客户端，各种 <a href="https://www.emqx.com/zh/blog/mqtt-client-tools">MQTT 测试工具</a>也是客户端。</p><p><strong>MQTT Broker</strong></p><p>MQTT Broker 是负责处理客户端请求的关键组件，包括建立连接、断开连接、订阅和取消订阅等操作，同时还负责消息的转发。一个高效强大的 MQTT Broker 能够轻松应对海量连接和百万级消息吞吐量，从而帮助物联网服务提供商专注于业务发展，快速构建可靠的 MQTT 应用。</p><p>关于 MQTT Broker 的更多详情，请参阅文章 <a href="https://www.emqx.com/zh/blog/the-ultimate-guide-to-mqtt-broker-comparison">2024 年最全面的 MQTT Broker 比较指南</a>。</p><p><strong>发布-订阅模式</strong></p><p>发布-订阅模式与客户端-服务器模式的不同之处在于，它将发送消息的客户端（发布者）和接收消息的客户端（订阅者）进行了解耦。发布者和订阅者之间无需建立直接连接，而是通过 MQTT Broker 来负责消息的路由和分发。</p><p>下图展示了 MQTT 发布&#x2F;订阅过程。温度传感器作为客户端连接到 MQTT Broker，并通过发布操作将温度数据发布到一个特定主题（例如 <code>Temperature</code>）。MQTT Broker 接收到该消息后会负责将其转发给订阅了相应主题（<code>Temperature</code>）的订阅者客户端。</p><p><img src="/imgs/MQTT%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20241118103856227.png"></p><p><strong>主题</strong></p><p>MQTT 协议根据主题来转发消息。主题通过 <code>/</code> 来区分层级，类似于 URL 路径，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 复制">chat/room/1<br><br>sensor/10/temperature<br><br>sensor/+/temperature<br></code></pre></td></tr></table></figure><p>MQTT 主题支持以下两种通配符：<code>+</code> 和 <code>#</code>。</p><ul><li><code>+</code>：表示单层通配符，例如 <code>a/+</code> 匹配 <code>a/x</code> 或 <code>a/y</code>。</li><li><code>#</code>：表示多层通配符，例如 <code>a/#</code> 匹配 <code>a/x</code>、<code>a/b/c/d</code>。</li></ul><blockquote><p><strong>注意</strong>：通配符主题只能用于订阅，不能用于发布。</p></blockquote><p><strong>QoS</strong></p><p>MQTT 提供了三种服务质量（QoS），在不同网络环境下保证消息的可靠性。</p><ul><li>QoS 0：消息最多传送一次。如果当前客户端不可用，它将丢失这条消息。</li><li>QoS 1：消息至少传送一次。</li><li>QoS 2：消息只传送一次。</li></ul><h2 id="MQTT-的工作流程"><a href="#MQTT-的工作流程" class="headerlink" title="MQTT 的工作流程"></a>MQTT 的工作流程</h2><p>在了解了 MQTT 的基本组件之后，让我们来看看它的一般工作流程：</p><ol><li><strong>客户端使用 TCP&#x2F;IP 协议与 Broker 建立连接</strong>，可以选择使用 TLS&#x2F;SSL 加密来实现安全通信。客户端提供认证信息，并指定会话类型（Clean Session 或 Persistent Session）。</li><li><strong>客户端既可以向特定主题发布消息，也可以订阅主题以接收消息</strong>。当客户端发布消息时，它会将消息发送给 MQTT Broker；而当客户端订阅消息时，它会接收与订阅主题相关的消息。</li><li><strong>MQTT Broker 接收发布的消息</strong>，并将这些消息转发给订阅了对应主题的客户端。它根据 QoS 等级确保消息可靠传递，并根据会话类型为断开连接的客户端存储消息。</li></ol><h2 id="控制报文简介"><a href="#控制报文简介" class="headerlink" title="控制报文简介"></a>控制报文简介</h2><p>报文是网络中交换与传输的数据最小单元，通俗来讲就是站点一次性要发送的数据块。它包含了将要发送的完整教据信息，其长不一致，长度不限目可变。HOTT 客户端和服务端通过交换控制报文来完成它们的工作，比如订阅主题和发布消息。</p><p><img src="/imgs/MQTT%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20241118105229841.png"></p><h2 id="MQTT报文格式"><a href="#MQTT报文格式" class="headerlink" title="MQTT报文格式"></a>MQTT报文格式</h2><p>由<font color=blue>固定报头，可变报头，有效载荷</font> 三个部分组成</p><p><font color=red>固定报头固定存在于所有控制报文中，而可变报头和有效载荷是否存在以及它们的内容则取决于具体的报文类型</font></p>]]></content>
    
    
    <categories>
      
      <category>Protocol</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mqtt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署Yapi</title>
    <link href="/2023/07/04/docker_install_yapi/"/>
    <url>/2023/07/04/docker_install_yapi/</url>
    
    <content type="html"><![CDATA[<!-- Docker部署Yapi --><span id="more"></span><p>Docker部署Yapi</p><h3 id="新建docker-compose-yml"><a href="#新建docker-compose-yml" class="headerlink" title="新建docker-compose.yml"></a>新建docker-compose.yml</h3><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">yapi-web</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">liuqingzheng/yapi:latest</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">yapi-web</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">3000:3000</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">YAPI_ADMIN_ACCOUNT=123@123.com</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">YAPI_ADMIN_PASSWORD=123456</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">YAPI_CLOSE_REGISTER=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">YAPI_DB_SERVERNAME=yapi-mongo</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">YAPI_DB_PORT=27017</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">YAPI_DB_DATABASE=yapi</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">YAPI_MAIL_ENABLE=false</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">YAPI_LDAP_LOGIN_ENABLE=false</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">YAPI_PLUGINS=[]</span><br>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">yapi-mongo</span><br>    <span class="hljs-attribute">links</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">yapi-mongo</span><br>  <span class="hljs-attribute">yapi-mongo</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">mongo:latest</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">yapi-mongo</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/db:/data/db</span><br>    <span class="hljs-attribute">expose</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">27017</span><br></code></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d <span class="hljs-comment"># 启动</span><br>docker-compose stop  <span class="hljs-comment"># 停止</span><br>docker-compose <span class="hljs-built_in">rm</span>    <span class="hljs-comment"># 删除</span><br></code></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">http:<span class="hljs-comment">//127.0.0.1:3000/</span><br>输入邮箱：<span class="hljs-symbol">123@</span><span class="hljs-number">123.</span>com<br>输入密码：<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Yapi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH基础使用</title>
    <link href="/2023/06/24/ssh_use/"/>
    <url>/2023/06/24/ssh_use/</url>
    
    <content type="html"><![CDATA[<!-- SSH基础使用 --><span id="more"></span><p>SSH基础使用</p><h3 id="SSH-是什么"><a href="#SSH-是什么" class="headerlink" title="SSH 是什么"></a>SSH 是什么</h3><p>历史上，网络主机之间的通信是不加密的，属于明文通信。这使得通信很不安全，一个典型的例子就是服务器登录。登录远程服务器的时候，需要将用户输入的密码传给服务器，如果这个过程是明文通信，就意味着传递过程中，线路经过的中间计算机都能看到密码，这是很可怕的。</p><p>SSH 就是为了解决这个问题而诞生的，它能够加密计算机之间的通信，保证不被窃听或篡改。它还能对操作者进行认证（authentication）和授权（authorization）。明文的网络协议可以套用在它里面，从而实现加密</p><h3 id="SSH-架构"><a href="#SSH-架构" class="headerlink" title="SSH 架构"></a>SSH 架构</h3><p>SH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 ssh；接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 sshd</p><p>OpenSSH 还提供一些辅助工具软件（比如 ssh-keygen 、ssh-agent）和专门的客户端工具（比如 scp 和 sftp）</p><h3 id="SSH-客户端"><a href="#SSH-客户端" class="headerlink" title="SSH 客户端"></a>SSH 客户端</h3><p>OpenSSH 的客户端是二进制程序 ssh。它在 Linux&#x2F;Unix 系统的位置是 <strong>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ssh</strong></p><p>Linux 系统一般都自带 ssh，如果没有就需要安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Ubuntu 和 Debian</span><br>$ sudo apt <span class="hljs-keyword">install</span> openssh-client<br><br><span class="hljs-comment"># CentOS 和 Fedora</span><br>$ sudo dnf <span class="hljs-keyword">install</span> openssh-clients<br></code></pre></td></tr></table></figure><p>安装以后，可以使用-V参数输出版本号，查看一下是否安装成功。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh -V<br></code></pre></td></tr></table></figure><h4 id="ssh-登录服务器的命令"><a href="#ssh-登录服务器的命令" class="headerlink" title="ssh 登录服务器的命令"></a>ssh 登录服务器的命令</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh hostname<br></code></pre></td></tr></table></figure><p>hostname是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名。不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。如果要指定用户名，可以采用下面的语法</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh user<span class="hljs-variable">@hostname</span><br></code></pre></td></tr></table></figure><p>用户名也可以使用ssh的-l参数指定，这样的话，用户名和主机名就不用写在一起了。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh -l username host<br></code></pre></td></tr></table></figure><p>ssh 默认连接服务器的22端口，-p参数可以指定其他端口。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh -p <span class="hljs-number">8821</span> foo.com<br></code></pre></td></tr></table></figure><h4 id="执行远程命令"><a href="#执行远程命令" class="headerlink" title="执行远程命令"></a>执行远程命令</h4><p>SSH 登录成功后，用户就进入了远程主机的命令行环境，所看到的提示符，就是远程主机的提示符。这时，你就可以输入想要在远程主机执行的命令</p><p>另一种执行远程命令的方法，是将命令直接写在ssh命令的后面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh username@hostname <span class="hljs-built_in">command</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh foo@server.example.com <span class="hljs-built_in">cat</span> /etc/hosts</span><br></code></pre></td></tr></table></figure><p>采用这种语法执行命令时，ssh 客户端不会提供互动式的 Shell 环境，而是直接将远程命令的执行结果输出在命令行。但是，有些命令需要互动式的 Shell 环境，这时就要使用-t参数。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 报错</span><br>$ ssh remote.<span class="hljs-keyword">server</span>.com emacs<br>emacs: standard input <span class="hljs-keyword">is</span> not a tty<br><br><span class="hljs-meta"># 不报错</span><br>$ ssh -t <span class="hljs-keyword">server</span>.example.com emacs<br></code></pre></td></tr></table></figure><h4 id="加密参数"><a href="#加密参数" class="headerlink" title="加密参数"></a>加密参数</h4><p>SSH 连接的握手阶段，客户端必须跟服务端约定加密参数集（cipher suite）。</p><p>加密参数集包含了若干不同的加密参数，它们之间使用下划线连接在一起，下面是一个例子。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">TLS_RS<span class="hljs-built_in">A_WITH</span>_AES_128_CBC_SHA<br></code></pre></td></tr></table></figure><ul><li>TLS：加密通信协议</li><li>RSA：密钥交换算法</li><li>AES：加密算法</li><li>128：加密算法的强度</li><li>CBC：加密算法的模式</li><li>SHA：数字签名的 Hash 函数</li></ul><h4 id="ssh-命令行配置项"><a href="#ssh-命令行配置项" class="headerlink" title="ssh 命令行配置项"></a>ssh 命令行配置项</h4><p>ssh 命令有很多配置项，修改它的默认行为。</p><p><strong>-c</strong> 参数指定加密算法。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-operator">$</span> ssh <span class="hljs-operator">-</span><span class="hljs-built_in">c</span> blowfish<span class="hljs-punctuation">,</span><span class="hljs-number">3</span>des server.example.com<br><span class="hljs-comment"># 或者</span><br><span class="hljs-operator">$</span> ssh <span class="hljs-operator">-</span><span class="hljs-built_in">c</span> blowfish <span class="hljs-operator">-</span><span class="hljs-built_in">c</span> <span class="hljs-number">3</span>des server.example.com<br></code></pre></td></tr></table></figure><p>上面命令指定使用加密算法blowfish或3des。</p><p><strong>-C</strong> 参数表示压缩数据传输。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ ssh -C <span class="hljs-keyword">server</span>.example.com<br></code></pre></td></tr></table></figure><p><strong>-D</strong> 参数指定本机的 Socks 监听端口，该端口收到的请求，都将转发到远程的 SSH 主机，又称动态端口转发</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ ssh -D <span class="hljs-number">1080</span> <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p><strong>-f</strong> 参数表示 SSH 连接在后台运行。</p><p><strong>-F</strong> 参数指定配置文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ ssh -F <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/ssh/</span>other_config<br></code></pre></td></tr></table></figure><p><strong>-i</strong> 参数用于指定私钥，意为“identity_file”，默认值为<del>&#x2F;.ssh&#x2F;id_dsa（DSA 算法）和</del>&#x2F;.ssh&#x2F;id_rsa（RSA 算法）。注意，对应的公钥必须存放到服务器。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ ssh -i my-<span class="hljs-built_in">key</span> server.<span class="hljs-built_in">example</span>.com<br></code></pre></td></tr></table></figure><p><strong>-l</strong> 参数指定远程登录的账户名。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh -l sally server.example.com<br><span class="hljs-comment"># 等同于</span><br><span class="hljs-variable">$ </span>ssh sally<span class="hljs-variable">@server</span>.example.com<br></code></pre></td></tr></table></figure><p><strong>-L</strong> 参数设置本地端口转发。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh  -L <span class="hljs-number">9999</span><span class="hljs-symbol">:targetServer</span><span class="hljs-symbol">:</span><span class="hljs-number">80</span> user<span class="hljs-variable">@remoteserver</span><br></code></pre></td></tr></table></figure><p>上面命令中，所有发向本地9999端口的请求，都会经过remoteserver发往 targetServer 的 80 端口，这就相当于直接连上了 targetServer 的 80 端口。</p><p><strong>-m</strong> 参数指定校验数据完整性的算法（message authentication code，简称 MAC）。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ ssh -m hmac-sha1,hmac-md5 <span class="hljs-keyword">server</span>.example.com<br></code></pre></td></tr></table></figure><p>上面命令指定数据校验算法为hmac-sha1或hmac-md5。</p><p><strong>-N</strong> 参数用于端口转发，表示建立的 SSH 只用于端口转发，不能执行远程命令，这样可以提供安全性</p><p><strong>-o</strong> 参数用来指定一个配置命令。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ ssh -o <span class="hljs-string">&quot;User sally&quot;</span> -o <span class="hljs-string">&quot;Port 220&quot;</span> <span class="hljs-keyword">server</span>.example.com<br></code></pre></td></tr></table></figure><p>使用等号时，配置命令可以不用写在引号里面，但是等号前后不能有空格。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ ssh -o <span class="hljs-attribute">User</span>=sally -o <span class="hljs-attribute">Port</span>=220 server.example.com<br></code></pre></td></tr></table></figure><p><strong>-p</strong> 参数指定 SSH 客户端连接的服务器端口。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ssh -<span class="hljs-selector-tag">p</span> <span class="hljs-number">2035</span> server<span class="hljs-selector-class">.example</span>.com<br></code></pre></td></tr></table></figure><p><strong>-q</strong> 参数表示安静模式（quiet），不向用户输出任何警告信息。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ssh –<span class="hljs-selector-tag">q</span> foo<span class="hljs-selector-class">.com</span><br>root’s password:<br></code></pre></td></tr></table></figure><p><strong>-R</strong> 参数指定远程端口转发</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh -R <span class="hljs-number">9999</span><span class="hljs-symbol">:targetServer</span><span class="hljs-symbol">:</span><span class="hljs-number">902</span> local<br></code></pre></td></tr></table></figure><p>上面命令需在跳板服务器执行，指定本地计算机local监听自己的 9999 端口，所有发向这个端口的请求，都会转向 targetServer 的 902 端口。</p><p><strong>-t</strong> 参数在 ssh 直接运行远端命令时，提供一个互动式 Shell。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ssh -t server<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span> emacs<br></code></pre></td></tr></table></figure><p><strong>-v</strong> 参数显示详细信息。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ ssh -v <span class="hljs-keyword">server</span>.example.com<br></code></pre></td></tr></table></figure><p>-v可以重复多次，表示信息的详细程度，比如-vv和-vvv。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ ssh -vvv <span class="hljs-keyword">server</span>.example.com<br><span class="hljs-meta"># 或者</span><br>$ ssh -v -v -v <span class="hljs-keyword">server</span>.example.com<br></code></pre></td></tr></table></figure><p><strong>-V</strong>参 数输出 ssh 客户端的版本。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ ssh –V<br>ssh: SSH Secure <span class="hljs-keyword">Shell</span> 3.2.3 (non-commercial <span class="hljs-keyword">version</span>) <span class="hljs-keyword">on</span> i686-pc-linux<br></code></pre></td></tr></table></figure><p><strong>-X</strong> 参数表示打开 X 窗口转发。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ ssh -X <span class="hljs-keyword">server</span>.example.com<br></code></pre></td></tr></table></figure><p>-4指定使用 IPv4 协议，这是默认值。<br>-6指定使用 IPv6 协议。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ssh -<span class="hljs-number">4</span> server<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span><br>$ ssh -<span class="hljs-number">6</span> server<span class="hljs-selector-class">.example</span>.com<br></code></pre></td></tr></table></figure><h4 id="客户端配置文件"><a href="#客户端配置文件" class="headerlink" title="客户端配置文件"></a>客户端配置文件</h4><p>SSH 客户端的全局配置文件是&#x2F;etc&#x2F;ssh&#x2F;ssh_config，用户个人的配置文件在~&#x2F;.ssh&#x2F;config，优先级高于全局配置文件</p><ul><li>~&#x2F;.ssh&#x2F;id_ecdsa：用户的 ECDSA 私钥。</li><li>~&#x2F;.ssh&#x2F;id_ecdsa.pub：用户的 ECDSA 公钥。</li><li>~&#x2F;.ssh&#x2F;id_rsa：用于 SSH 协议版本2 的 RSA 私钥。</li><li>~&#x2F;.ssh&#x2F;id_rsa.pub：用于SSH 协议版本2 的 RSA 公钥。</li><li>~&#x2F;.ssh&#x2F;identity：用于 SSH 协议版本1 的 RSA 私钥。</li><li>~&#x2F;.ssh&#x2F;identity.pub：用于 SSH 协议版本1 的 RSA 公钥。</li><li>~&#x2F;.ssh&#x2F;known_hosts：包含 SSH 服务器的公钥指纹</li></ul><p>用户个人的配置文件~&#x2F;.ssh&#x2F;config，可以按照不同服务器，列出各自的连接参数，从而不必每一次登录都输入重复的参数</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host *<br>     Port <span class="hljs-number">2222</span><br><br>Host remoteserver<br>     HostName remote.example.com<br>     <span class="hljs-keyword">User</span> <span class="hljs-title">neo</span><br>     Port <span class="hljs-number">2112</span><br></code></pre></td></tr></table></figure><p>登录remote.example.com时，只要执行ssh remoteserver命令，就会自动套用 config 文件里面指定的参数</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh remoteserver<br><span class="hljs-comment"># 等同于</span><br><span class="hljs-variable">$ </span>ssh -p <span class="hljs-number">2112</span> neo<span class="hljs-variable">@remote</span>.example.com<br></code></pre></td></tr></table></figure><h4 id="配置命令的语法"><a href="#配置命令的语法" class="headerlink" title="配置命令的语法"></a>配置命令的语法</h4><p>ssh 客户端配置文件的每一行，就是一个配置命令。配置命令与对应的值之间，可以使用空格，也可以使用等号。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Compression</span> <span class="hljs-literal">yes</span><br><span class="hljs-comment"># 等同于</span><br>Compression = <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><h4 id="主要配置命令"><a href="#主要配置命令" class="headerlink" title="主要配置命令"></a>主要配置命令</h4><ul><li>AddressFamily inet：表示只使用 IPv4 协议。如果设为inet6，表示只使用 IPv6 协议。</li><li>BindAddress 192.168.10.235：指定本机的 IP 地址（如果本机有多个 IP 地址）。</li><li>CheckHostIP yes：检查 SSH 服务器的 IP 地址是否跟公钥数据库吻合。</li><li>Ciphers blowfish,3des：指定加密算法。</li><li>Compression yes：是否压缩传输信号。</li><li>ConnectionAttempts 10：客户端进行连接时，最大的尝试次数。</li><li>ConnectTimeout 60：客户端进行连接时，服务器在指定秒数内没有回复，则中断连接尝试。</li><li>DynamicForward 1080：指定动态转发端口。</li><li>GlobalKnownHostsFile &#x2F;users&#x2F;smith&#x2F;.ssh&#x2F;my_global_hosts_file：指定全局的公钥数据库文件的位置。</li><li>Host server.example.com：指定连接的域名或 IP 地址，也可以是别名，支持通配符。Host命令后面的所有配置，都是针对该主机的，直到下一个Host命令为止。</li><li>HostKeyAlgorithms ssh-dss,ssh-rsa：指定密钥算法，优先级从高到低排列。</li><li>HostName myserver.example.com：在Host命令使用别名的情况下，HostName指定域名或 IP 地址。</li><li>IdentityFile keyfile：指定私钥文件。</li><li>LocalForward 2001 localhost:143：指定本地端口转发。</li><li>LogLevel QUIET：指定日志详细程度。如果设为QUIET，将不输出大部分的警告和提示。</li><li>MACs hmac-sha1,hmac-md5：指定数据校验算法。</li><li>NumberOfPasswordPrompts 2：密码登录时，用户输错密码的最大尝试次数。</li><li>PasswordAuthentication no：指定是否支持密码登录。不过，这里只是客户端禁止，真正的禁止需要在 SSH 服务器设置。</li><li>Port 2035：指定客户端连接的 SSH 服务器端口。</li><li>PreferredAuthentications publickey,hostbased,password：指定各种登录方法的优先级。</li><li>Protocol 2：支持的 SSH 协议版本，多个版本之间使用逗号分隔。</li><li>PubKeyAuthentication yes：是否支持密钥登录。这里只是客户端设置，还需要在 SSH 服务器进行相应设置。</li><li>RemoteForward 2001 server:143：指定远程端口转发。</li><li>SendEnv COLOR：SSH 客户端向服务器发送的环境变量名，多个环境变量之间使用空格分隔。环境变量的值从客户端当前环境中拷贝。</li><li>ServerAliveCountMax 3：如果没有收到服务器的回应，客户端连续发送多少次keepalive信号，才断开连接。该项默认值为3。</li><li>ServerAliveInterval 300：客户端建立连接后，如果在给定秒数内，没有收到服务器发来的消息，客户端向服务器发送keepalive消息。如果不希望客户端发送，这一项设为0。</li><li>StrictHostKeyChecking yes：yes表示严格检查，服务器公钥为未知或发生变化，则拒绝连接。no表示如果服务器公钥未知，则加入客户端公钥数据库，如果公钥发生变化，不改变客户端公钥数据库，输出一条警告，依然允许连接继续进行。ask（默认值）表示询问用户是否继续进行。</li><li>TCPKeepAlive yes：客户端是否定期向服务器发送keepalive信息。</li><li>User userName：指定远程登录的账户名。</li><li>UserKnownHostsFile &#x2F;users&#x2F;smith&#x2F;.ssh&#x2F;my_local_hosts_file：指定当前用户的known_hosts文件（服务器公钥指纹列表）的位置。</li><li>VerifyHostKeyDNS yes：是否通过检查 SSH 服务器的 DNS 记录，确认公钥指纹是否与known_hosts文件保存的一致。</li></ul><h3 id="SSH-密钥登录"><a href="#SSH-密钥登录" class="headerlink" title="SSH 密钥登录"></a>SSH 密钥登录</h3><p>密钥（key）是一个非常大的数字，通过加密算法得到。对称加密只需要一个密钥，非对称加密需要两个密钥成对使用，分为公钥（public key）和私钥（private key）。</p><p>SSH 密钥登录采用的是非对称加密，每个用户通过自己的密钥登录。其中，私钥必须私密保存，不能泄漏；公钥则是公开的，可以对外发送。它们的关系是，公钥和私钥是一一对应的，每一个私钥都有且仅有一个对应的公钥，反之亦然。</p><p>如果数据使用公钥加密，那么只有使用对应的私钥才能解密，其他密钥都不行；反过来，如果使用私钥加密（这个过程一般称为“签名”），也只有使用对应的公钥解密。</p><h4 id="密钥登录的过程"><a href="#密钥登录的过程" class="headerlink" title="密钥登录的过程"></a>密钥登录的过程</h4><p>SSH 密钥登录分为以下的步骤。</p><p>预备步骤，客户端通过ssh-keygen生成自己的公钥和私钥。</p><p>第一步，手动将客户端的公钥放入远程服务器的指定位置。</p><p>第二步，客户端向服务器发起 SSH 登录的请求。</p><p>第三步，服务器收到用户 SSH 登录的请求，发送一些随机数据给用户，要求用户证明自己的身份。</p><p>第四步，客户端收到服务器发来的数据，使用私钥对数据进行签名，然后再发还给服务器。</p><p>第五步，服务器收到客户端发来的加密签名后，使用对应的公钥解密，然后跟原始数据比较。如果一致，就允许用户登录。</p><h4 id="ssh-keygen命令：生成密钥"><a href="#ssh-keygen命令：生成密钥" class="headerlink" title="ssh-keygen命令：生成密钥"></a>ssh-keygen命令：生成密钥</h4><p>OpenSSH 提供了一个工具程序ssh-keygen命令，用来生成密钥</p><p>直接输入ssh-keygen，程序会询问一系列问题，然后生成密钥。</p><p>通常做法是使用-t参数，指定密钥的加密算法。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh-keygen -t dsa<br></code></pre></td></tr></table></figure><p>下面的命令可以列出用户所有的公钥。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ <span class="hljs-keyword">ls</span> -l ~<span class="hljs-string">/.ssh/id_</span>*<span class="hljs-string">.pub</span><br></code></pre></td></tr></table></figure><p>生成密钥以后，建议修改它们的权限，防止其他人读取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 600 ~/.ssh/id_rsa</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 600 ~/.ssh/id_rsa.pub</span><br></code></pre></td></tr></table></figure><h4 id="ssh-keygen的命令行配置项"><a href="#ssh-keygen的命令行配置项" class="headerlink" title="ssh-keygen的命令行配置项"></a>ssh-keygen的命令行配置项</h4><p>主要有下面这些。</p><p><strong>-b</strong> 参数指定密钥的二进制位数。这个参数值越大，密钥就越不容易破解，但是加密解密的计算开销也会加大。</p><p>一般来说，-b至少应该是1024，更安全一些可以设为2048或者更高。</p><p><strong>-C</strong> 参数可以为密钥文件指定新的注释，格式为username@host。</p><p>下面命令生成一个4096位 RSA 加密算法的密钥对，并且给出了用户名和主机名。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ ssh-keygen -t rsa -<span class="hljs-keyword">b</span> <span class="hljs-number">4096</span> -C <span class="hljs-string">&quot;your_email@domain.com&quot;</span><br></code></pre></td></tr></table></figure><p><strong>-f</strong> 参数指定生成的私钥文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> dsa <span class="hljs-operator">-f</span> mykey<br></code></pre></td></tr></table></figure><p>上面命令会在当前目录生成私钥文件mykey和公钥文件mykey.pub。</p><p><strong>-F</strong> 参数检查某个主机名是否在known_hosts文件里面。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> ssh<span class="hljs-literal">-keygen</span> <span class="hljs-operator">-F</span> example.com<br></code></pre></td></tr></table></figure><p><strong>-N</strong> 参数用于指定私钥的密码（passphrase）。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">$ ssh-keygen -<span class="hljs-built_in">t</span> dsa -<span class="hljs-built_in">N</span> secretword<br></code></pre></td></tr></table></figure><p><strong>-p</strong> 参数用于重新指定私钥的密码（passphrase）。它与-N的不同之处在于，新密码不在命令中指定，而是执行后再输入。ssh 先要求输入旧密码，然后要求输入两遍新密码。</p><p><strong>-R</strong> 参数将指定的主机公钥指纹移出known_hosts文件。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh-keygen -R example.com<br></code></pre></td></tr></table></figure><p><strong>-t</strong> 参数用于指定生成密钥的加密算法，一般为dsa或rsa</p><h4 id="手动上传公钥"><a href="#手动上传公钥" class="headerlink" title="手动上传公钥."></a>手动上传公钥.</h4><p>生成密钥以后，公钥必须上传到服务器，才能使用公钥登录。</p><p>OpenSSH 规定，用户公钥保存在服务器的<del>&#x2F;.ssh&#x2F;authorized_keys文件。你要以哪个用户的身份登录到服务器，密钥就必须保存在该用户主目录的</del>&#x2F;.ssh&#x2F;authorized_keys文件。只要把公钥添加到这个文件之中，就相当于公钥上传到服务器了。每个公钥占据一行。如果该文件不存在，可以手动创建</p><p>用户可以手动编辑该文件，把公钥粘贴进去，也可以在本机计算机上，执行下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub | ssh user@host <span class="hljs-string">&quot;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys&quot;</span></span><br></code></pre></td></tr></table></figure><p>注意，authorized_keys文件的权限要设为644，即只有文件所有者才能写。如果权限设置不对，SSH 服务器可能会拒绝读取该文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 644 ~/.ssh/authorized_keys</span><br></code></pre></td></tr></table></figure><h4 id="ssh-copy-id-命令：自动上传公钥"><a href="#ssh-copy-id-命令：自动上传公钥" class="headerlink" title="ssh-copy-id 命令：自动上传公钥"></a>ssh-copy-id 命令：自动上传公钥</h4><p>OpenSSH 自带一个ssh-copy-id命令，可以自动将公钥拷贝到远程服务器的<del>&#x2F;.ssh&#x2F;authorized_keys文件。如果</del>&#x2F;.ssh&#x2F;authorized_keys文件不存在，ssh-copy-id命令会自动创建该文件</p><p>用户在本地计算机执行下面的命令，就可以把本地的公钥拷贝到服务器。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ ssh<span class="hljs-operator">-</span><span class="hljs-keyword">copy</span><span class="hljs-operator">-</span>id <span class="hljs-operator">-</span>i key_file <span class="hljs-keyword">user</span><span class="hljs-variable">@host</span><br></code></pre></td></tr></table></figure><p>上面命令中，-i参数用来指定公钥文件，user是所要登录的账户名，host是服务器地址。如果省略用户名，默认为当前的本机用户名。执行完该命令，公钥就会拷贝到服务器。</p><p>注意，公钥文件可以不指定路径和.pub后缀名，ssh-copy-id会自动在~&#x2F;.ssh目录里面寻找。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ ssh<span class="hljs-operator">-</span><span class="hljs-keyword">copy</span><span class="hljs-operator">-</span>id <span class="hljs-operator">-</span>i id_rsa <span class="hljs-keyword">user</span><span class="hljs-variable">@host</span><br></code></pre></td></tr></table></figure><p>注意，ssh-copy-id是直接将公钥添加到authorized_keys文件的末尾。如果authorized_keys文件的末尾不是一个换行符，会导致新的公钥添加到前一个公钥的末尾，两个公钥连在一起，使得它们都无法生效。所以，如果authorized_keys文件已经存在，使用ssh-copy-id命令之前，务必保证authorized_keys文件的末尾是换行符</p><h4 id="ssh-agent-命令，ssh-add-命令"><a href="#ssh-agent-命令，ssh-add-命令" class="headerlink" title="ssh-agent 命令，ssh-add 命令"></a>ssh-agent 命令，ssh-add 命令</h4><p>私钥设置了密码以后，每次使用都必须输入密码，有时让人感觉非常麻烦。比如，连续使用scp命令远程拷贝文件时，每次都要求输入密码。</p><p>ssh-agent命令就是为了解决这个问题而设计的，它让用户在整个 Bash 对话（session）之中，只在第一次使用 SSH 命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了</p><p>第一步，使用下面的命令新建一次命令行对话。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh-agent bash<br></code></pre></td></tr></table></figure><p>如果想在当前对话启用ssh-agent，可以使用下面的命令。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>eval <span class="hljs-string">`ssh-agent`</span><br></code></pre></td></tr></table></figure><p>eval命令的作用，就是运行上面的ssh-agent命令的输出，设置环境变量。</p><p>第二步，在新建的 Shell 对话里面，使用ssh-add命令添加默认的私钥（比如<del>&#x2F;.ssh&#x2F;id_rsa，或</del>&#x2F;.ssh&#x2F;id_dsa，或<del>&#x2F;.ssh&#x2F;id_ecdsa，或</del>&#x2F;.ssh&#x2F;id_ed25519）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ ssh-add<br>Enter passphrase <span class="hljs-keyword">for</span> <span class="hljs-regexp">/home/y</span>ou<span class="hljs-regexp">/.ssh/i</span>d_dsa: ********<br>Identity added: <span class="hljs-regexp">/home/y</span>ou<span class="hljs-regexp">/.ssh/i</span>d_dsa (<span class="hljs-regexp">/home/y</span>ou<span class="hljs-regexp">/.ssh/i</span>d_dsa)<br></code></pre></td></tr></table></figure><p>上面例子中，添加私钥时，会要求输入密码。以后，在这个对话里面再使用密钥时，就不需要输入私钥的密码了，因为私钥已经加载到内存里面了。</p><p>第三步，使用 ssh 命令正常登录远程服务器。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh remoteHost<br></code></pre></td></tr></table></figure><p>最后，如果要退出ssh-agent，可以直接退出子 Shell（按下 Ctrl + d），也可以使用下面的命令。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh-agent -k<br></code></pre></td></tr></table></figure><h4 id="ssh-add命令"><a href="#ssh-add命令" class="headerlink" title="ssh-add命令"></a>ssh-add命令</h4><p><strong>-d</strong> 参数从内存中删除指定的私钥。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ ssh-<span class="hljs-keyword">add</span> -d name-of-<span class="hljs-keyword">key</span>-<span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p><strong>-D</strong> 参数从内存中删除所有已经添加的私钥。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ ssh-<span class="hljs-built_in">add</span> -D<br></code></pre></td></tr></table></figure><p><strong>-l</strong> 参数列出所有已经添加的私钥。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ ssh-<span class="hljs-built_in">add</span> -l<br></code></pre></td></tr></table></figure><p>为了安全性，启用密钥登录之后，最好关闭服务器的密码登录。</p><p>对于 OpenSSH，具体方法就是打开服务器 sshd 的配置文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config，将PasswordAuthentication这一项设为no</p><h4 id="SSH-服务器"><a href="#SSH-服务器" class="headerlink" title="SSH 服务器"></a>SSH 服务器</h4><p>SSH 的架构是服务器&#x2F;客户端模式，两端运行的软件是不一样的。OpenSSH 的客户端软件是 ssh，服务器软件是 sshd</p><p>如果没有安装 sshd，可以用下面的命令安装。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># Debian</span><br>$ sudo aptitude install openssh-<span class="hljs-keyword">server</span><br><br><span class="hljs-meta"># Red Hat</span><br>$ sudo yum install openssh-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SSH</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用kts编写gradle</title>
    <link href="/2023/06/08/gradle_kts/"/>
    <url>/2023/06/08/gradle_kts/</url>
    
    <content type="html"><![CDATA[<!-- 使用kts编写gradle --><span id="more"></span><p><a href="https://juejin.cn/post/6976825808870440996">https://juejin.cn/post/6976825808870440996</a></p><p>groovy和kotin的区别</p><table><thead><tr><th align="left">.</th><th align="left">kotlin</th><th align="left">groovy</th></tr></thead><tbody><tr><td align="left">自动代码补全</td><td align="left">√</td><td align="left">❌</td></tr><tr><td align="left">类型安全</td><td align="left">√</td><td align="left">❌</td></tr><tr><td align="left">源码快速导航</td><td align="left">√</td><td align="left">❌</td></tr><tr><td align="left">重构</td><td align="left">自动</td><td align="left">手动</td></tr></tbody></table><h3 id="着手更改项目中gradle脚本语言为kotlin"><a href="#着手更改项目中gradle脚本语言为kotlin" class="headerlink" title="着手更改项目中gradle脚本语言为kotlin"></a>着手更改项目中gradle脚本语言为kotlin</h3><p>android项目使用gradle作为构造工具,项目目录下会生成settings.gradle,build.gradle,app&#x2F;build.gradle</p><h3 id="kotlin和groovy一些简单的语法差异"><a href="#kotlin和groovy一些简单的语法差异" class="headerlink" title="kotlin和groovy一些简单的语法差异"></a>kotlin和groovy一些简单的语法差异</h3><p><strong>grrovy字符串可以使用单引号，而kotlin必须为双引号</strong><br><strong>groovy在方法调用时可以省略扩号，而kotlin不可省略</strong><br><strong>groovy分配属性时可以省略&#x3D;赋值运算符，而kotlin不可省略</strong></p><h3 id="修改settings-gradle"><a href="#修改settings-gradle" class="headerlink" title="修改settings.gradle"></a>修改settings.gradle</h3><p>修改扩展名为settings.gradle.kts,编辑器会提示你需要更改单引号为双引号，因为kotlin中字符串是使用双引号的！然后把include “:app” 更改为kotlin调用方法的形式 include(“:app”) 进行sync 这样settings.gradle就更改完成</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">include</span> (&quot;:app&quot;)<br></code></pre></td></tr></table></figure><h3 id="修改build-gradle"><a href="#修改build-gradle" class="headerlink" title="修改build.gradle"></a>修改build.gradle</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">plugins &#123;<br>    <span class="hljs-built_in">id</span> (<span class="hljs-string">&quot;com.android.application&quot;</span>) <span class="hljs-built_in">version</span> <span class="hljs-string">&quot;8.0.0&quot;</span> apply <span class="hljs-literal">false</span><br>    <span class="hljs-built_in">id</span> (<span class="hljs-string">&quot;com.android.library&quot;</span>) <span class="hljs-built_in">version</span> <span class="hljs-string">&quot;8.0.0&quot;</span> apply <span class="hljs-literal">false</span><br>    <span class="hljs-built_in">id</span> (<span class="hljs-string">&quot;org.jetbrains.kotlin.android&quot;</span>) <span class="hljs-built_in">version</span> <span class="hljs-string">&quot;1.8.0&quot;</span> apply <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改app-build-gralde"><a href="#修改app-build-gralde" class="headerlink" title="修改app&#x2F;build.gralde"></a>修改app&#x2F;build.gralde</h3><p>改扩展名为build.gradle.kts</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs stylus">plugins &#123;<br>    <span class="hljs-built_in">id</span>(<span class="hljs-string">&quot;com.android.application&quot;</span>)<br>    <span class="hljs-built_in">id</span>(<span class="hljs-string">&quot;org.jetbrains.kotlin.android&quot;</span>)<br>&#125;<br><br>android &#123;<br>    namespace = <span class="hljs-string">&quot;com.zxj.kotlin_flow_learn&quot;</span><br>    compileSdk = <span class="hljs-number">33</span><br><br>    defaultConfig &#123;<br>        applicationId = <span class="hljs-string">&quot;com.zxj.kotlin_flow_learn&quot;</span><br>        minSdk = <span class="hljs-number">24</span><br>        targetSdk = <span class="hljs-number">33</span><br>        versionCode = <span class="hljs-number">1</span><br>        versionName = <span class="hljs-string">&quot;1.0&quot;</span><br><br>        testInstrumentationRunner = <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>        vectorDrawables &#123;<br>            useSupportLibrary = true<br>        &#125;<br>    &#125;<br><br>    buildTypes &#123;<br>        <span class="hljs-built_in">named</span>(<span class="hljs-string">&quot;release&quot;</span>) &#123;<br>            isMinifyEnabled = false<br>            <span class="hljs-built_in">proguardFiles</span>(<br>                <span class="hljs-built_in">getDefaultProguardFile</span>(<span class="hljs-string">&quot;proguard-android-optimize.txt&quot;</span>),<br>                <span class="hljs-string">&quot;proguard-rules.pro&quot;</span><br>            )<br>        &#125;<br>    &#125;<br><br>    compileOptions &#123;<br>        <span class="hljs-built_in">sourceCompatibility</span>(JavaVersion.VERSION_1_8)<br>        <span class="hljs-built_in">targetCompatibility</span>(JavaVersion.VERSION_1_8)<br>    &#125;<br><br>    kotlinOptions &#123;<br>        jvmTarget = <span class="hljs-string">&quot;1.8&quot;</span><br>    &#125;<br><br>    buildFeatures &#123;<br>        compose = true<br>    &#125;<br><br>    composeOptions &#123;<br>        kotlinCompilerExtensionVersion = <span class="hljs-string">&quot;1.4.0&quot;</span><br>    &#125;<br>&#125;<br><br>dependencies &#123;<br><br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-string">&quot;androidx.core:core-ktx:1.10.1&quot;</span>)<br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-string">&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.6.1&quot;</span>)<br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-string">&quot;androidx.activity:activity-compose:1.7.2&quot;</span>)<br><br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-built_in">platform</span>(<span class="hljs-string">&quot;androidx.compose:compose-bom:2022.10.00&quot;</span>))<br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-string">&quot;androidx.compose.ui:ui&quot;</span>)<br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-string">&quot;androidx.compose.ui:ui-graphics&quot;</span>)<br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-string">&quot;androidx.compose.ui:ui-tooling-preview&quot;</span>)<br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-string">&quot;androidx.compose.material3:material3&quot;</span>)<br><br>    <span class="hljs-built_in">testImplementation</span>(<span class="hljs-string">&quot;junit:junit:4.13.2&quot;</span>)<br>    <span class="hljs-built_in">androidTestImplementation</span>(<span class="hljs-string">&quot;androidx.test.ext:junit:1.1.5&quot;</span>)<br>    <span class="hljs-built_in">androidTestImplementation</span>(<span class="hljs-string">&quot;androidx.test.espresso:espresso-core:3.5.1&quot;</span>)<br><br>    <span class="hljs-built_in">androidTestImplementation</span>(<span class="hljs-built_in">platform</span>(<span class="hljs-string">&quot;androidx.compose:compose-bom:2022.10.00&quot;</span>))<br>    <span class="hljs-built_in">androidTestImplementation</span>(<span class="hljs-string">&quot;androidx.compose.ui:ui-test-junit4&quot;</span>)<br>    <span class="hljs-built_in">debugImplementation</span>(<span class="hljs-string">&quot;androidx.compose.ui:ui-tooling&quot;</span>)<br>    <span class="hljs-built_in">debugImplementation</span>(<span class="hljs-string">&quot;androidx.compose.ui:ui-test-manifest&quot;</span>)<br><br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&quot;</span>)<br>    <span class="hljs-built_in">implementation</span>(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kotlin</tag>
      
      <tag>gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin Flow 操作符</title>
    <link href="/2023/06/08/kotlin_flow_use/"/>
    <url>/2023/06/08/kotlin_flow_use/</url>
    
    <content type="html"><![CDATA[<!-- Kotlin Flow 操作符 --><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/SA2_DsSzXmWtLHf_6so7VA">https://mp.weixin.qq.com/s/SA2_DsSzXmWtLHf_6so7VA</a></p><p>Kotlin Flow 如此受欢迎大部分归功于其丰富、简洁的操作符，巧妙使用Flow操作符可以大大简化我们的程序结构，提升可读性与可维护性</p><h3 id="最简单的Flow"><a href="#最简单的Flow" class="headerlink" title="最简单的Flow"></a>最简单的Flow</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-comment">//构造flow</span><br>        <span class="hljs-keyword">val</span> flow = flow &#123;<br>            <span class="hljs-comment">//上游</span><br>            emit(<span class="hljs-string">&quot;hello world <span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)<br>        &#125;<br>        <span class="hljs-comment">//收集flow</span><br>        flow.collect &#123;<br>            <span class="hljs-comment">//下游</span><br>            Log.e(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;collect:<span class="hljs-variable">$it</span> <span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上包含了两种操作符：构造操作符flow与末端操作符collect。</p><p>总结来说，flow调用流程简化为：<strong>两个操作符+两个闭包+emit函数</strong>：</p><ol><li>collect操作符触发调用，执行了flow的闭包</li><li>flow闭包里调用emit函数，执行了collect闭包</li></ol><h3 id="Flow返回集合"><a href="#Flow返回集合" class="headerlink" title="Flow返回集合"></a>Flow返回集合</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> result = mutableListOf&lt;String&gt;()<br>        flow &#123;<br>            <span class="hljs-comment">//上游</span><br>            emit(<span class="hljs-string">&quot;hello world <span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)<br>        &#125;.toList(result)<br>        Log.e(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;result == <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Flow变换操作符"><a href="#Flow变换操作符" class="headerlink" title="Flow变换操作符"></a>Flow变换操作符</h3><p>在Flow流到下游之前，对数据进行处理，处理完成后再发射出去。可以使用transform 操作符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span> &#123;<br>        runBlocking &#123;<br>            flow &#123;<br>                <span class="hljs-comment">//上游</span><br>                emit(<span class="hljs-string">&quot;hello world <span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)<br>            &#125;.transform &#123;<br>                emit(<span class="hljs-string">&quot;<span class="hljs-variable">$it</span> man&quot;</span>)<br>            &#125;.collect &#123;<br><span class="hljs-comment">//                println(&quot;$it&quot;)</span><br>                Log.e(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;it == <span class="hljs-variable">$it</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>transform还需要自己发射数据，有点麻烦，map可解君忧</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        flow &#123;<br>            <span class="hljs-comment">//上游</span><br>            emit(<span class="hljs-string">&quot;hello world <span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)<br>        &#125;.map &#123;<br>            <span class="hljs-string">&quot;<span class="hljs-variable">$it</span> 1&quot;</span><br>        &#125;.collect &#123;<br>            Log.e(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;it == <span class="hljs-variable">$it</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>map内部封装了transform。</p><h3 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h3><p>对上流的数据进行某种条件的筛选过滤</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        flow &#123;<br>            <span class="hljs-comment">//上游</span><br>            emit(<span class="hljs-string">&quot;hello world <span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)<br>            emit(<span class="hljs-string">&quot;fish&quot;</span>)<br>        &#125;.filter &#123;<br>            <span class="hljs-comment">//包含hello字符串才继续往下发送</span><br>            it.contains(<span class="hljs-string">&quot;hello&quot;</span>)<br>        &#125;.collect &#123;<br>            Log.e(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;it == <span class="hljs-variable">$it</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Flow里如何切换协程与线程"><a href="#Flow里如何切换协程与线程" class="headerlink" title="Flow里如何切换协程与线程"></a>Flow里如何切换协程与线程</h3><p>在主线程执行collect操作符，在flow闭包里执行耗时操作<br>需要flow闭包里的代码在子线程执行<br>使用flowOn操作符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span> &#123;<br>        runBlocking &#123;<br>            flow &#123;<br>                <span class="hljs-comment">//上游</span><br>                Log.e(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;emit <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                emit(<span class="hljs-string">&quot;hello world&quot;</span>)<br>            &#125;.flowOn(Dispatchers.IO)<span class="hljs-comment">//flowOn 之前的操作符在新协程里执行</span><br>                .collect &#123;<br><span class="hljs-comment">//                    Log.e(&quot;&quot;, &quot;it == $it&quot;)</span><br>                    Log.e(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;collect <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-number">15</span>:<span class="hljs-number">07</span>:<span class="hljs-number">48.599</span>  E  emit DefaultDispatcher-worker-<span class="hljs-number">1</span><br>    <span class="hljs-number">15</span>:<span class="hljs-number">07</span>:<span class="hljs-number">48.600</span>  E  collect main<br></code></pre></td></tr></table></figure><p>flow闭包(上游)，collect闭包(下游)分别执行在不同的协程以及不同的线程里</p><h3 id="Flow处理背压"><a href="#Flow处理背压" class="headerlink" title="Flow处理背压"></a>Flow处理背压</h3><p>上游发射数据速度高于下游，如何提升发射效率？</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fun <span class="hljs-built_in">test06</span>() &#123;<br>    runBlocking &#123;<br>        val <span class="hljs-selector-tag">time</span> = measureTimeMillis &#123;<br>            <span class="hljs-attribute">flow</span> &#123;<br>                <span class="hljs-comment">//上游</span><br>                Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;emit $&#123;Thread.currentThread().name&#125;&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>                <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;hello world2&quot;</span>)<br>            &#125;<span class="hljs-selector-class">.collect</span> &#123;<br>                <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>)<br>                Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;$it&quot;</span>)<br>                Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;collect $&#123;Thread.currentThread().name&#125;&quot;</span>)<br>            &#125;<br>        &#125;<br>        Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;use time:$time&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用buffer操作符解决背压问题</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fun <span class="hljs-built_in">test06</span>() &#123;<br>    runBlocking &#123;<br>        val <span class="hljs-selector-tag">time</span> = measureTimeMillis &#123;<br>            <span class="hljs-attribute">flow</span> &#123;<br>                <span class="hljs-comment">//上游</span><br>                Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;emit $&#123;Thread.currentThread().name&#125;&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>                <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;hello world2&quot;</span>)<br>            &#125;<span class="hljs-selector-class">.buffer</span>()<span class="hljs-selector-class">.collect</span> &#123;<br>                <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>)<br>                Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;$it&quot;</span>)<br>                Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;collect $&#123;Thread.currentThread().name&#125;&quot;</span>)<br>            &#125;<br>        &#125;<br>        Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;use time:$time&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>buffer原理简单来说：</p><blockquote><p>构造了新的协程执行flow闭包，上游数据会发送到Channel 缓冲区里，发送完成继续发送下一条。<br>collect操作符监听缓冲区是否有数据，若有则收集成功。<br>原理是基于ChannelFlow。</p></blockquote><h3 id="上游覆盖旧数据"><a href="#上游覆盖旧数据" class="headerlink" title="上游覆盖旧数据"></a>上游覆盖旧数据</h3><p>上游生产速度很快，下游消费速度慢，我们只关心最新数据，旧的数据没价值可以丢掉。使用conflate操作符处理</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fun <span class="hljs-built_in">test07</span>() &#123;<br>    runBlocking &#123;<br>        <span class="hljs-attribute">flow</span> &#123;<br>            <span class="hljs-comment">//上游</span><br>            <span class="hljs-built_in">repeat</span>(<span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;emit $it&quot;</span>)<br>                <span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>)<br>            &#125;<br>        &#125;<span class="hljs-selector-class">.conflate</span>()<span class="hljs-selector-class">.collect</span> &#123;<br>            Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;conflate&quot;</span>)<br>            <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>)<br>            Log<span class="hljs-selector-class">.e</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;$it&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中间产生的数据由于下游没有来得及消费，被上游新的数据冲刷掉了</p><blockquote><p>相当于使用了buffer操作符，该buffer只能容纳一个数据，新来的数据将会覆盖旧的数据。<br>原理是基于ChannelFlow</p></blockquote><h3 id="Flow变换取最新值"><a href="#Flow变换取最新值" class="headerlink" title="Flow变换取最新值"></a>Flow变换取最新值</h3><p>在使用transform处理数据的时候，若是它处理比较慢，当有新的值过来后就取消未处理好的值。</p><p>使用transformLatest操作符处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test08</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        flow &#123;<br>            <span class="hljs-comment">//上游，协程1</span><br>            repeat(<span class="hljs-number">5</span>) &#123;<br>                emit(<span class="hljs-string">&quot;emit <span class="hljs-variable">$it</span>&quot;</span>)<br>            &#125;<br>            Log.e(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;emit <span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)<br>        &#125;.transformLatest &#123;<br>            <span class="hljs-comment">//协程2</span><br>            delay(<span class="hljs-number">1000</span>)<br>            emit(<span class="hljs-string">&quot;<span class="hljs-variable">$it</span> fish&quot;</span>)<br>        &#125;.collect &#123;<br>            Log.e(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;collect <span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)<br>            Log.e(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;<span class="hljs-variable">$it</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>map也有类似的操作符</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">fun</span> <span class="hljs-function"><span class="hljs-title">test09</span>() &#123;</span><br><span class="hljs-function">    <span class="hljs-variable">runBlocking</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-variable">flow</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-comment">//上游</span></span><br><span class="hljs-function">            <span class="hljs-title">repeat</span>(<span class="hljs-number">5</span>) &#123;</span><br><span class="hljs-function">                <span class="hljs-title">emit</span>(<span class="hljs-string">&quot;emit $it&quot;</span>)</span><br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">println</span>(<span class="hljs-string">&quot;emit $&#123;Thread.currentThread()&#125;&quot;</span>)</span><br>        &#125;.mapLatest &#123;<br>            <span class="hljs-function"><span class="hljs-title">delay</span>(<span class="hljs-number">200</span>)</span><br>            <span class="hljs-string">&quot;$it fish&quot;</span><br>        &#125;.collect &#123;<br>            <span class="hljs-function"><span class="hljs-title">println</span>(<span class="hljs-string">&quot;collect $&#123;Thread.currentThread()&#125;&quot;</span>)</span><br>            <span class="hljs-function"><span class="hljs-title">println</span>(<span class="hljs-string">&quot;$it&quot;</span>)</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="收集最新的数据"><a href="#收集最新的数据" class="headerlink" title="收集最新的数据"></a>收集最新的数据</h3><p>监听下载进度，UI展示最新进度<br>此种场景下，我们只是关注最新的进度，没必要频繁刷新UI，因此使用Flow实现时上游发射太快了可以忽略旧的数据<br>使用collectLatest操作符实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test014</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>            <span class="hljs-keyword">val</span> flow1 = flow &#123;<br>                repeat(<span class="hljs-number">10000</span>) &#123;<br>                    emit(it + <span class="hljs-number">1</span>)<br>                &#125;<br>            &#125;<br>            flow1.collectLatest &#123;<br>                delay(<span class="hljs-number">20</span>)<br>                Log.e(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;collect progress <span class="hljs-variable">$it</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>        Log.e(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;use time:<span class="hljs-variable">$time</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="展平流"><a href="#展平流" class="headerlink" title="展平流"></a>展平流</h3><p><strong>flatMapConcat</strong><br>依照顺序</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test010</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> flow1 = flow &#123;<br>            emit(<span class="hljs-string">&quot;stuInfo&quot;</span>)<br>        &#125;<br>        flow1.flatMapConcat &#123;<br>            <span class="hljs-comment">//flow2</span><br>            flow &#123;<br>                emit(<span class="hljs-string">&quot;<span class="hljs-variable">$it</span> teachInfo&quot;</span>)<br>            &#125;<br>        &#125;.collect &#123;<br>            Log.e(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;collect <span class="hljs-variable">$it</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将两个Flow的数据拍平了输出<br>flatMapConcat 并没有涉及到多协程，使用了装饰者模式。<br>先将Flow2使用map进行变换，而后将Flow1、Flow2数据发射出来。<br>Concat顾名思义，将两个Flow连接起来。</p><p><strong>flatMapMerge</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">fun</span> <span class="hljs-function"><span class="hljs-title">test012</span>() &#123;</span><br><span class="hljs-function">    <span class="hljs-variable">runBlocking</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-variable">val</span> <span class="hljs-variable">time</span> = <span class="hljs-variable">measureTimeMillis</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-variable">val</span> <span class="hljs-variable">flow1</span> = <span class="hljs-variable">flow</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">println</span>(<span class="hljs-string">&quot;emit $&#123;Thread.currentThread()&#125;&quot;</span>)</span><br>                <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-string">&quot;stuInfo 1&quot;</span>)</span><br>                <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-string">&quot;stuInfo 2&quot;</span>)</span><br>                <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-string">&quot;stuInfo 3&quot;</span>)</span><br>            &#125;<br>            <span class="hljs-variable">flow1.flatMapMerge</span>(<span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-comment">//flow2</span><br>                <span class="hljs-variable">flow</span> &#123;<br>                    <span class="hljs-function"><span class="hljs-title">println</span>(<span class="hljs-string">&quot;flatMapMerge $&#123;Thread.currentThread()&#125;&quot;</span>)</span><br>                    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-string">&quot;$it teachInfo&quot;</span>)</span><br>                    <span class="hljs-function"><span class="hljs-title">delay</span>(<span class="hljs-number">1000</span>)</span><br>                &#125;<br>            &#125;.collect &#123;<br>                <span class="hljs-function"><span class="hljs-title">println</span>(<span class="hljs-string">&quot;collect $&#123;Thread.currentThread()&#125;&quot;</span>)</span><br>                <span class="hljs-function"><span class="hljs-title">println</span>(<span class="hljs-string">&quot;collect $it&quot;</span>)</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">println</span>(<span class="hljs-string">&quot;use time:$time&quot;</span>)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>flatMapMerge由于是并发执行，整体速度比flatMapConcat快了很多。<br>flatMapMerge可以指定并发的数量，当指定flatMapMerge(0)时，flatMapMerge退化为flatMapConcat</p><p><strong>flatMapLatest</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fun <span class="hljs-built_in">test013</span>() &#123;<br>    runBlocking &#123;<br>        val <span class="hljs-selector-tag">time</span> = measureTimeMillis &#123;<br>            val flow1 = <span class="hljs-attribute">flow</span> &#123;<br><span class="hljs-comment">//                    println(&quot;emit $&#123;Thread.currentThread()&#125;&quot;)</span><br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;stuInfo 1&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;stuInfo 2&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;stuInfo 3&quot;</span>)<br>            &#125;<br>            flow1<span class="hljs-selector-class">.flatMapLatest</span> &#123;<br>                <span class="hljs-comment">//flow2</span><br>                <span class="hljs-attribute">flow</span> &#123;<br><span class="hljs-comment">//                        println(&quot;flatMapLatest $&#123;Thread.currentThread()&#125;&quot;)</span><br>                    <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>)<br>                    <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;$it teachInfo&quot;</span>)<br>                &#125;<br>            &#125;<span class="hljs-selector-class">.collect</span> &#123;<br><span class="hljs-comment">//                    println(&quot;collect $&#123;Thread.currentThread()&#125;&quot;)</span><br>                <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;collect $it&quot;</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;use time:$time&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合流"><a href="#组合流" class="headerlink" title="组合流"></a>组合流</h3><p><strong>combine</strong></p><p>短的一方会等待长的一方结束后才结束</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test015</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>            <span class="hljs-keyword">val</span> flow1 = flow &#123;<br>                emit(<span class="hljs-string">&quot;stuSex 1&quot;</span>)<br>                emit(<span class="hljs-string">&quot;stuSex 2&quot;</span>)<br>                emit(<span class="hljs-string">&quot;stuSex 3&quot;</span>)<br>            &#125;<br>            <span class="hljs-keyword">val</span> flow2 = flow &#123;<br>                emit(<span class="hljs-string">&quot;stuSubject&quot;</span>)<br>            &#125;<br>            flow1.combine(flow2) &#123;<br>                    sex, subject-&gt;<span class="hljs-string">&quot;<span class="hljs-variable">$sex</span>--&gt;<span class="hljs-variable">$subject</span>&quot;</span><br>            &#125;.collect &#123;<br>                Log.e(<span class="hljs-string">&quot;&quot;</span>,it)<br>            &#125;<br>        &#125;<br>        Log.e(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;use time:<span class="hljs-variable">$time</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>flow1的每个emit和flow2的emit关联起来了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fun <span class="hljs-built_in">test016</span>() &#123;<br>    runBlocking &#123;<br>        val <span class="hljs-selector-tag">time</span> = measureTimeMillis &#123;<br>            val flow1 = <span class="hljs-attribute">flow</span> &#123;<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;a&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;b&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;c&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;d&quot;</span>)<br>            &#125;<br>            val flow2 = <span class="hljs-attribute">flow</span> &#123;<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;1&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;2&quot;</span>)<br>            &#125;<br>            flow1<span class="hljs-selector-class">.combine</span>(flow2) &#123;<br>                    sex, subject-&gt;<span class="hljs-string">&quot;$sex--&gt;$subject&quot;</span><br>            &#125;<span class="hljs-selector-class">.collect</span> &#123;<br>                <span class="hljs-built_in">println</span>(it)<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;use time:$time&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>a--&gt;<span class="hljs-number">1</span><br>b--&gt;<span class="hljs-number">2</span><br>c--&gt;<span class="hljs-number">2</span><br>d--&gt;<span class="hljs-number">2</span><br>use <span class="hljs-selector-tag">time</span>:<span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p><strong>zip</strong></p><p>只要某个Flow获取结束了就取消Flow</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fun <span class="hljs-built_in">test017</span>() &#123;<br>    runBlocking &#123;<br>        val <span class="hljs-selector-tag">time</span> = measureTimeMillis &#123;<br>            val flow1 = <span class="hljs-attribute">flow</span> &#123;<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;a&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;b&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;c&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;d&quot;</span>)<br>            &#125;<br>            val flow2 = <span class="hljs-attribute">flow</span> &#123;<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;1&quot;</span>)<br>                <span class="hljs-built_in">emit</span>(<span class="hljs-string">&quot;2&quot;</span>)<br>            &#125;<br>            flow1<span class="hljs-selector-class">.zip</span>(flow2) &#123;<br>                    sex, subject-&gt;<span class="hljs-string">&quot;$sex--&gt;$subject&quot;</span><br>            &#125;<span class="hljs-selector-class">.collect</span> &#123;<br>                <span class="hljs-built_in">println</span>(it)<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;use time:$time&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>a--&gt;<span class="hljs-number">1</span><br>b--&gt;<span class="hljs-number">2</span><br>use <span class="hljs-selector-tag">time</span>:<span class="hljs-number">71</span><br></code></pre></td></tr></table></figure><p>可以看出flow2先结束了，并且flow1没发送完成。<br>zip的特点：<br>短的Flow结束，另一个Flow也结束</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flow</tag>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis详解</title>
    <link href="/2023/05/04/redis_details/"/>
    <url>/2023/05/04/redis_details/</url>
    
    <content type="html"><![CDATA[<!--Redis详解 --><span id="more"></span><p>Redis详解</p><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis?"></a>什么是Redis?</h3><p>Redis是一种基于键值对（key-value）的NoSQL数据库</p><p>比一般键值对数据库强大的地方，Redis中的value支持string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、 HyperLogLog、GEO（地理信息定位）等多种数据结构</p><p>Redis会将所有数据都存放在内存中，所以它的读写性能非常出色</p><p>Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上</p><p>Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上</p><h3 id="用来干什么"><a href="#用来干什么" class="headerlink" title="用来干什么"></a>用来干什么</h3><ol><li><p>缓存<br>Redis应用最广泛地方，基本所有的Web应用都会使用Redis作为缓存，来降低数据源压力，提高响应速度</p></li><li><p>计数器<br>Redis天然支持计数功能，而且计数性能非常好，可以用来记录浏览量、点赞量等等</p></li><li><p>排行榜<br>Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。</p></li><li><p>社交网络<br>赞&#x2F;踩、粉丝、共同好友&#x2F;喜好、推送、下拉刷新</p></li><li><p>消息队列<br>Redis提供了发布订阅功能和阻塞队列的功能，可以满足一般消息队列功能</p></li><li><p>分布式锁<br>分布式环境下，利用Redis实现分布式锁，也是Redis常见的应用</p></li></ol><p>Redis的应用结合项目：</p><blockquote><p>Token存储：用户登录成功之后，使用Redis存储Token<br>登录失败次数计数：使用Redis计数，登录失败超过一定次数，锁定账号<br>地址缓存：对省市区数据的缓存<br>分布式锁：分布式环境下登录、注册等操作加分布式锁<br>…</p></blockquote><h3 id="有哪些数据结构"><a href="#有哪些数据结构" class="headerlink" title="有哪些数据结构"></a>有哪些数据结构</h3><h5 id="五种基本数据结构"><a href="#五种基本数据结构" class="headerlink" title="五种基本数据结构"></a>五种基本数据结构</h5><p><strong>string</strong></p><p>字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB</p><p><strong>hash</strong></p><p>哈希类型是指键值本身又是一个键值对结构 缓存用户信息 缓存对象</p><p><strong>list</strong></p><p>列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色</p><p><strong>set</strong></p><p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。</p><p><strong>sorted set</strong></p><p>有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。</p><h3 id="为什么快"><a href="#为什么快" class="headerlink" title="为什么快"></a>为什么快</h3><ol><li>完全基于内存操作</li><li>使⽤单线程，避免了线程切换和竞态产生的消耗</li><li>基于⾮阻塞的IO多路复⽤机制</li><li>C语⾔实现，优化过的数据结构，基于⼏种基础的数据结构，redis做了⼤量的优化，性能极⾼</li></ol><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><p>Linux系统有三种方式实现IO多路复用：select、poll和epoll。<br>例如epoll方式是将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。<br>这样，整个过程只在进行select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</p><h3 id="为什么早期选择单线程"><a href="#为什么早期选择单线程" class="headerlink" title="为什么早期选择单线程"></a>为什么早期选择单线程</h3><p>Redis 4.0 之后开始变成多线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等</p><h3 id="Redis6-0使用多线程"><a href="#Redis6-0使用多线程" class="headerlink" title="Redis6.0使用多线程"></a>Redis6.0使用多线程</h3><p>Redis6.0的多线程是用多线程来处理数据的读写和协议解析，但是Redis执行命令还是单线程的<br>这样做的⽬的是因为Redis的性能瓶颈在于⽹络IO⽽⾮CPU，使⽤多线程能提升IO读写的效率，从⽽整体提⾼Redis的性能</p><h3 id="Redis持久化⽅式"><a href="#Redis持久化⽅式" class="headerlink" title="Redis持久化⽅式"></a>Redis持久化⽅式</h3><p>Redis持久化⽅案分为RDB和AOF两种</p><p><strong>RDB</strong></p><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><p>RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。</p><p>手动触发分别对应save和bgsave命令</p><pre><code class="hljs">-  save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用-  bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</code></pre><p>以下场景会自动触发RDB持久化</p><pre><code class="hljs">- 使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。- 如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点- 执行debug reload命令重新加载Redis时，也会自动触发save操作- 默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</code></pre><p><strong>AOF</strong></p><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p><p>AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）</p><p>流程：</p><ol><li>所有的写入命令会追加到aof_buf（缓冲区）中。</li><li>AOF缓冲区根据对应的策略向硬盘做同步操作。</li><li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。</li><li>当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li></ol><h3 id="RDB-和-AOF-各自有什么优缺点"><a href="#RDB-和-AOF-各自有什么优缺点" class="headerlink" title="RDB 和 AOF 各自有什么优缺点"></a>RDB 和 AOF 各自有什么优缺点</h3><p><strong>RDB | 优点</strong></p><p>只有一个紧凑的二进制文件 dump.rdb，非常适合备份、全量复制的场景。<br>容灾性好，可以把RDB文件拷贝道远程机器或者文件系统张，用于容灾恢复。<br>恢复速度快，RDB恢复数据的速度远远快于AOF的方式</p><p><strong>RDB | 缺点</strong></p><p>实时性低，RDB 是间隔一段时间进行持久化，没法做到实时持久化&#x2F;秒级持久化。如果在这一间隔事件发生故障，数据会丢失。<br>存在兼容问题，Redis演进过程存在多个格式的RDB版本，存在老版本Redis无法兼容新版本RDB的问题。</p><p><strong>AOF | 优点</strong></p><p>实时性好，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。<br>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p><p><strong>AOF | 缺点</strong></p><p>AOF 文件比 RDB 文件大，且 恢复速度慢。<br>数据集大 的时候，比 RDB 启动效率低。</p><h3 id="RDB和AOF如何选择"><a href="#RDB和AOF如何选择" class="headerlink" title="RDB和AOF如何选择"></a>RDB和AOF如何选择</h3><ol><li>一般来说， 如果想达到足以媲美数据库的 数据安全性，应该 同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li><li>如果 可以接受数分钟以内的数据丢失，那么可以 只使用 RDB 持久化。</li><li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</li><li>如果只需要数据在服务器运行的时候存在，也可以不使用任何持久化方式</li></ol><h3 id="Redis的数据恢复"><a href="#Redis的数据恢复" class="headerlink" title="Redis的数据恢复"></a>Redis的数据恢复</h3><p>当Redis发生了故障，可以从RDB或者AOF中恢复数据。</p><p>恢复的过程也很简单，把RDB或者AOF文件拷贝到Redis的数据目录下，如果使用AOF恢复，配置文件开启AOF，然后启动redis-server即可</p><p>Redis 启动时加载数据的流程：</p><ul><li>AOF持久化开启且存在AOF文件时，优先加载AOF文件。</li><li>AOF关闭或者AOF文件不存在时，加载RDB文件。</li><li>加载AOF&#x2F;RDB文件成功后，Redis启动成功。</li><li>AOF&#x2F;RDB文件存在错误时，Redis启动失败并打印错误信息</li></ul><h3 id="Redis-4-0-的混合持久化"><a href="#Redis-4-0-的混合持久化" class="headerlink" title="Redis 4.0 的混合持久化"></a>Redis 4.0 的混合持久化</h3><p>重启 Redis 时，我们很少使用 RDB 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间</p><p>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 自持久化开始到持久化结束 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小</p><p>于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升</p><h3 id="Redis保证高可用主要有三种方式：主从、哨兵、集群"><a href="#Redis保证高可用主要有三种方式：主从、哨兵、集群" class="headerlink" title="Redis保证高可用主要有三种方式：主从、哨兵、集群"></a>Redis保证高可用主要有三种方式：主从、哨兵、集群</h3><p>主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 主节点(master)，后者称为 从节点(slave)。且数据的复制是 单向 的，只能由主节点到从节点。Redis 主从复制支持 主从同步 和 从从同步 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担</p><ul><li>数据冗余： 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复： 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 (实际上是一种服务的冗余)。</li><li>负载均衡： 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li><li>高可用基石： 除了上述作用以外，主从复制还是哨兵和集群能够实施的 基础，因此说主从复制是 Redis 高可用的基础</li></ul><h3 id="常见的拓扑结构"><a href="#常见的拓扑结构" class="headerlink" title="常见的拓扑结构"></a>常见的拓扑结构</h3><p><strong>一主一从结构</strong></p><p>一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持</p><p><strong>一主多从结构（又称为星形拓扑结构）</strong></p><p>使得应用端可以利用多个从节点实现读写分离,对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力</p><p><strong>树状主从结构（又称为树状拓扑结构）</strong></p><p>使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量</p><h3 id="Redis的主从复制原理"><a href="#Redis的主从复制原理" class="headerlink" title="Redis的主从复制原理"></a>Redis的主从复制原理</h3><ol><li>保存主节点（master）信息<br> 这一步只是保存主节点信息，保存主节点的ip和port。</li><li>主从建立连接<br> 从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。</li><li>发送ping命令<br> 连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。</li><li>权限验证<br> 如果主节点要求密码验证，从节点必须正确的密码才能通过验证。</li><li>同步数据集<br> 主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。</li><li>命令持续复制<br> 接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</li></ol><h3 id="主从数据同步的方式"><a href="#主从数据同步的方式" class="headerlink" title="主从数据同步的方式"></a>主从数据同步的方式</h3><p>Redis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制</p><p><strong>全量复制</strong> 一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销</p><ol><li>发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。</li><li>主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。</li><li>从节点接收主节点的响应数据保存运行ID和偏移量offset</li><li>主节点执行bgsave保存RDB文件到本地</li><li>主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件</li><li>对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。</li><li>从节点接收完主节点传送来的全部数据后会清空自身旧数据</li><li>从节点清空数据后开始加载RDB文件</li><li>从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。</li></ol><p><strong>部分复制</strong><br>部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性</p><ol><li>当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接</li><li>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。</li><li>当主从节点网络恢复后，从节点会再次连上主节点</li><li>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。</li><li>主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。</li><li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li></ol><h3 id="主从复制存在哪些问题"><a href="#主从复制存在哪些问题" class="headerlink" title="主从复制存在哪些问题"></a>主从复制存在哪些问题</h3><p>主从复制虽好，但也存在一些问题：</p><ul><li>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。</li><li>主节点的写能力受到单机的限制。</li><li>主节点的存储能力受到单机的限制。</li></ul><p>第一个问题是Redis的高可用问题，第二、三个问题属于Redis的分布式问题。</p><h3 id="Redis-Sentinel（哨兵）"><a href="#Redis-Sentinel（哨兵）" class="headerlink" title="Redis Sentinel（哨兵）"></a>Redis Sentinel（哨兵）</h3><p>主从复制存在一个问题，没法完成自动故障转移。所以我们需要一个方案来完成自动故障转移，它就是Redis Sentinel（哨兵）</p><p><strong>Redis Sentinel</strong> ，它由两部分组成，哨兵节点和数据节点：</p><ul><li>哨兵节点： 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进行监控。</li><li>数据节点： 主节点和从节点都是数据节点；</li></ul><p>在复制的基础上，哨兵实现了 自动化的故障恢复 功能，下面是官方对于哨兵功能的描述：</p><ul><li>监控（Monitoring）： 哨兵会不断地检查主节点和从节点是否运作正常。</li><li>自动故障转移（Automatic failover）： 当 主节点 不能正常工作时，哨兵会开始 自动故障转移操作，它会将失效主节点的其中一个 从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li>配置提供者（Configuration provider）： 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li><li>通知（Notification）： 哨兵可以将故障转移的结果发送给客户端。</li></ul><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p><h3 id="Redis-Sentinel（哨兵）实现原理"><a href="#Redis-Sentinel（哨兵）实现原理" class="headerlink" title="Redis Sentinel（哨兵）实现原理"></a>Redis Sentinel（哨兵）实现原理</h3><p>哨兵模式是通过哨兵节点完成对数据节点的监控、下线、故障转移</p><p><strong>定时监控</strong></p><p>Sentinel通过三个定时监控任务完成对各个节点发现和监控：</p><ul><li>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构</li><li>每隔2秒，每个Sentinel节点会向Redis数据节点的__sentinel__：hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息</li><li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达</li></ul><p><strong>主观下线和客观下线</strong></p><p>主观下线就是哨兵节点认为某个节点有问题，客观下线就是超过一定数量的哨兵节点认为主节点有问题</p><ul><li><p>主观下线<br> 每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过 down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。</p></li><li><p>客观下线<br> 当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel is- master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过 <quorum>个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定</p></li></ul><p><strong>领导者Sentinel节点选举</strong></p><p>Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。Redis使用了Raft算法实现领导者选举</p><p><strong>故障转移</strong></p><ol><li>在从节点列表中选出一个节点作为新的主节点，这一步是相对复杂一些的一步</li><li>Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点</li><li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点</li><li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</li></ol><h3 id="领导者Sentinel节点选举"><a href="#领导者Sentinel节点选举" class="headerlink" title="领导者Sentinel节点选举"></a>领导者Sentinel节点选举</h3><p>Redis使用了Raft算法实 现领导者选举</p><ol><li>每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观 下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令， 要求将自己设置为领导者。</li><li>收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。</li><li>如果该Sentinel节点发现自己的票数已经大于等于max（quorum， num（sentinels）&#x2F;2+1），那么它将成为领导者。</li><li>如果此过程没有选举出领导者，将进入下一次选举</li></ol><h3 id="新的主节点是怎样被挑选出来"><a href="#新的主节点是怎样被挑选出来" class="headerlink" title="新的主节点是怎样被挑选出来"></a>新的主节点是怎样被挑选出来</h3><ol><li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节 点ping响应、与主节点失联超过down-after-milliseconds*10秒。</li><li>选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最大的从节点（复制的最完整），如果存在则返 回，不存在则继续。</li><li>选择runid最小的从节点。</li></ol><h3 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h3><p>主从存在高可用和分布式的问题，哨兵解决了高可用的问题，而集群就是终极方案，一举解决高可用和分布式问题</p><p><strong>数据分区</strong></p><p>数据分区 (或称数据分片) 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，存储容量大大增加；另一方面 每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。</p><p><strong>高可用</strong></p><p> 集群支持主从复制和主节点的 自动故障转移 （与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。</p><h3 id="集群中数据如何分区"><a href="#集群中数据如何分区" class="headerlink" title="集群中数据如何分区"></a>集群中数据如何分区</h3><p>分布式的存储中，要把数据集按照分区规则映射到多个节点，常见的数据分区规则三种</p><p><strong>节点取余分区</strong></p><p>节点取余分区，非常好理解，使用特定的数据，比如Redis的键，或者用户ID之类，对响应的hash值取余：hash（key）%N，来确定数据映射到哪一个节点上。<br>不过该方案最大的问题是，当节点数量变化时，如扩容或收缩节点，数据节点映射关 系需要重新计算，会导致数据的重新迁移</p><p><strong>一致性哈希分区</strong></p><p>将整个 Hash 值空间组织成一个虚拟的圆环，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后，放置在这个圆环上。当我们需要确定某一个 Key 需 要存取到哪个节点上的时候，先对这个 Key 做同样的 Hash 取值，确定在环上的位置，然后按照顺时针方向在环上“行走”，遇到的第一个缓存节点就是要访问的节点。</p><p>这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中 相邻的节点，对其他节点无影响。<br>但它还是存在问题：</p><ul><li>缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大</li><li>当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成力。</li></ul><p><strong>虚拟槽分区</strong></p><p>这个方案 一致性哈希分区的基础上，引入了 虚拟节点 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 槽（slot）。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p><p>在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点 之间的关系，增加或删除节点对系统的影响很小</p><h3 id="Redis集群的原理"><a href="#Redis集群的原理" class="headerlink" title="Redis集群的原理"></a>Redis集群的原理</h3><p>Redis集群通过数据分区来实现数据的分布式存储，通过自动故障转移实现高可用</p><p><strong>集群创建</strong></p><ul><li>设置节点 Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下</li><li>节点握手 节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信， 达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令：cluster meet{ip}{port}。完成节点握手之后，一个个的Redis节点就组成了一个多节点的集群</li><li>分配槽（slot） Redis集群把所有的数据映射到16384个槽中。每个节点对应若干个槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽</li></ul><p><strong>故障转移</strong></p><p>Redis集群的故障转移和哨兵的故障转移类似，但是Redis集群中所有的节点都要承担状态维护的任务。</p><ul><li><p>故障发现 Redis集群内节点通过ping&#x2F;pong消息实现节点通信，集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong 消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节 点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态.当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。当 半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程</p></li><li><p>故障恢复 故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它 的从节点中选出一个替换它，从而保证集群的高可用</p><ol><li>资格检查 每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障的主节点。</li><li>准备选举时间 当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该时间后才能执行后续流程。</li><li>发起选举 当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程。</li><li>选举投票 持有槽的主节点处理故障选举消息。投票过程其实是一个领导者选举的过程，如集群内有N个持有槽的主节 点代表有N张选票。由于在每个配置纪元内持有槽的主节点只能投票给一个 从节点，因此只能有一个从节点获得N&#x2F;2+1的选票，保证能够找出唯一的从节点。</li><li>替换主节点 当从节点收集到足够的选票之后，触发替换主节点操作。</li></ol></li></ul><h3 id="部署Redis集群至少需要几个物理节点"><a href="#部署Redis集群至少需要几个物理节点" class="headerlink" title="部署Redis集群至少需要几个物理节点"></a>部署Redis集群至少需要几个物理节点</h3><p>在投票选举的环节，故障主节点也算在投票数内，假设集群内节点规模是3主3从，其中有2 个主节点部署在一台机器上，当这台机器宕机时，由于从节点无法收集到 3&#x2F;2+1个主节点选票将导致故障转移失败。这个问题也适用于故障发现环节。因此部署集群时所有主节点最少需要部署在3台物理机上才能避免单点问题。</p><h3 id="集群的伸缩"><a href="#集群的伸缩" class="headerlink" title="集群的伸缩"></a>集群的伸缩</h3><p>Redis集群提供了灵活的节点扩容和收缩方案，可以在不影响集群对外服务的情况下，为集群添加节点进行扩容也可以下线部分节点进行缩容<br>其实，集群扩容和缩容的关键点，就在于槽和节点的对应关系，扩容和缩容就是将一部分槽和数据迁移给新节点</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>一个并发访问量比较大的key在某个时间过期，导致所有的请求直接打在DB上。</p><ol><li>加锁更新，⽐如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了</li><li>将过期时间组合写在value中，通过异步的⽅式不断的刷新过期时间，防⽌此类现象</li></ol><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透指的查询缓存和数据库中都不存在的数据，这样每次请求直接打到数据库，就好像缓存不存在一样。</p><p>缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义</p><p>缓存穿透可能会使后端存储负载加大，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。</p><ul><li>自身业务代码问题</li><li>恶意攻击，爬虫造成空命中</li></ul><p><strong>缓存空值&#x2F;默认值</strong></p><p>一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。</p><p>缓存空值有两大问题<br>    1. 空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。<br>    2. 缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。<br>        例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。<br>        这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。<br>    <strong>布隆过滤器</strong> 除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>某⼀时刻发⽣⼤规模的缓存失效的情况，例如缓存服务宕机、大量key在同一时间过期，这样的后果就是⼤量的请求进来直接打到DB上，可能导致整个系统的崩溃，称为雪崩。</p><ul><li><p>提高缓存可用性</p><ol><li>集群部署：通过集群来提升缓存的可用性，可以利用Redis本身的Redis Cluster或者第三方集群方案如Codis等。</li><li>多级缓存：设置多级缓存，第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同</li></ol></li><li><p>过期时间</p><ol><li>均匀过期：为了避免大量的缓存在同一时间过期，可以把不同的 key 过期时间随机生成，避免过期时间太过集中。</li><li>热点数据永不过期。</li></ol></li><li><p>熔断降级</p><ol><li>服务熔断：当缓存服务器宕机或超时响应时，为了防止整个系统出现雪崩，暂时停止业务服务访问缓存系统。</li><li>服务降级：当出现大量缓存失效，而且处在高并发高负荷的情况下，在业务系统内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的 fallback（退路）错误处理信息</li></ol></li></ul><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器，它是一个连续的数据结构，每个存储位存储都是一个bit，即0或者1, 来标识数据是否存在。</p><p>存储数据的时时候，使用K个不同的哈希函数将这个变量映射为bit列表的的K个点，把它们置为1</p><h3 id="保证缓存和数据库数据的⼀致性"><a href="#保证缓存和数据库数据的⼀致性" class="headerlink" title="保证缓存和数据库数据的⼀致性"></a>保证缓存和数据库数据的⼀致性</h3><p>根据CAP理论，在保证可用性和分区容错性的前提下，无法保证一致性，所以缓存和数据库的绝对一致是不可能实现的，只能尽可能保存缓存和数据库的最终一致性</p><p><strong>选择合适的缓存更新策略</strong></p><ol><li>删除缓存而不是更新缓存<br> 当一个线程对缓存的key进行写操作的时候，如果其它线程进来读数据库的时候，读到的就是脏数据，产生了数据不一致问题。<br> 相比较而言，删除缓存的速度比更新缓存的速度快很多，所用时间相对也少很多，读脏数据的概率也小很多</li><li>先更数据，后删缓存<br> 更新数据，耗时可能在删除缓存的百倍以上。在缓存中不存在对应的key，数据库又没有完成更新的时候，如果有线程进来读取数据，并写入到缓存，那么在更新成功之后，这个key就是一个脏数据。<br> 毫无疑问，先删缓存，再更数据库，缓存中key不存在的时间的时间更长，有更大的概率会产生脏数据<br> 目前最流行的缓存读写策略cache-aside-pattern就是采用先更数据库，再删缓存的方式</li></ol><p><strong>缓存不一致处理</strong></p><p>如果不是并发特别高，对缓存依赖性很强，其实一定程序的不一致是可以接受的。<br>但是如果对一致性要求比较高，那就得想办法保证缓存和数据库中数据一致。<br>缓存和数据库数据不一致常见的两种原因：</p><ul><li>缓存key删除失败</li><li>并发导致写入了脏数据</li></ul><ol><li>消息队列保证key被删除 可以引入消息队列，把要删除的key或者删除失败的key丢尽消息队列，利用消息队列的重试机制，重试删除对应的key。<br> 这种方案看起来不错，缺点是对业务代码有一定的侵入性</li><li>数据库订阅+消息队列保证key被删除 可以用一个服务（比如阿里的 canal）去监听数据库的binlog，获取需要操作的数据。<br> 然后用一个公共的服务获取订阅程序传来的信息，进行缓存删除操作。<br> 这种方式降低了对业务的侵入，但其实整个系统的复杂度是提升的，适合基建完善的大厂</li><li>延时双删防止脏数据 还有一种情况，是在缓存不存在的时候，写入了脏数据，这种情况在先删缓存，再更数据库的缓存更新策略下发生的比较多，解决方案是延时双删<br> 简单说，就是在第一次删除缓存之后，过了一段时间之后，再次删除缓存。<br> 这种方式的延时时间设置需要仔细考量和测试。</li><li>设置缓存过期时间兜底 这是一个朴素但是有用的办法，给缓存设置一个合理的过期时间，即使发生了缓存数据不一致的问题，它也不会永远不一致下去，缓存过期的时候，自然又会恢复一致。</li></ol><h3 id="保证本地缓存和分布式缓存的一致"><a href="#保证本地缓存和分布式缓存的一致" class="headerlink" title="保证本地缓存和分布式缓存的一致"></a>保证本地缓存和分布式缓存的一致</h3><p>所谓本地缓存，就是对应服务器的内存缓存，比如Caffeine，分布式缓存基本就是采用Redis</p><p>Redis缓存，数据库发生更新，直接删除缓存的key即可，因为对于应用系统而言，它是一种中心化的缓存</p><p>但是本地缓存，它是非中心化的，散落在分布式服务的各个节点上，没法通过客户端的请求删除本地缓存的key，所以得想办法通知集群所有节点，删除对应的本地缓存key</p><ol><li>采用Redis本身的Pub&#x2F;Sub机制，分布式集群的所有节点订阅删除本地缓存频道，删除Redis缓存的节点，同事发布删除本地缓存消息，订阅者们订阅到消息后，删除对应的本地key。<br>但是Redis的发布订阅不是可靠的，不能保证一定删除成功。</li><li>引入专业的消息队列，比如RocketMQ，保证消息的可靠性，但是增加了系统的复杂度。</li><li>设置适当的过期时间兜底，本地缓存可以设置相对短一些的过期时间</li></ol><h3 id="处理热key"><a href="#处理热key" class="headerlink" title="处理热key"></a>处理热key</h3><p>什么是热Key？ 所谓的热key，就是访问频率比较的key。</p><p>热门新闻事件或商品，这类key通常有大流量的访问，对存储这类信息的 Redis来说，是不小的压力</p><p>假如Redis集群部署，热key可能会造成整体流量的不均衡，个别节点出现OPS过大的情况，极端情况下热点key甚至会超过 Redis本身能够承受的OPS</p><p>对热key的处理，最关键的是对热点key的监控，可以从这些端来监控热点key</p><pre><code class="hljs">- 客户端    客户端其实是距离key“最近”的地方，因为Redis命令就是从客户端发出的，例如在客户端设置全局字典（key和调用次数），每次调用Redis命令时，使用这个字典进行记录。- 代理端    像Twemproxy、Codis这些基于代理的Redis分布式架构，所有客户端的请求都是通过代理端完成的，可以在代理端进行收集统计。- Redis服务端    使用monitor命令统计热点key是很多开发和运维人员首先想到，monitor命令可以监控到Redis执行的所有命令。</code></pre><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>所谓缓存预热，就是提前把数据库里的数据刷到缓存里，通常有这些方法：</p><ol><li>直接写个缓存刷新页面或者接口，上线时手动操作</li><li>数据量不大，可以在项目启动的时候自动进行加载</li><li>定时任务刷新缓存.</li></ol><h3 id="Redis报内存不足"><a href="#Redis报内存不足" class="headerlink" title="Redis报内存不足"></a>Redis报内存不足</h3><ul><li>修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存</li><li>也可以通过命令set maxmemory动态设置内存上限</li><li>修改内存淘汰策略，及时释放内存空间</li><li>使用 Redis 集群模式，进行横向扩容。</li></ul><h3 id="Redis的过期数据回收策略"><a href="#Redis的过期数据回收策略" class="headerlink" title="Redis的过期数据回收策略"></a>Redis的过期数据回收策略</h3><p><strong>惰性删除</strong></p><p>惰性删除指的是当我们查询key的时候才对key进⾏检测，如果已经达到过期时间，则删除。显然，他有⼀个缺点就是如果这些过期的key没有被访问，那么他就⼀直⽆法被删除，⽽且⼀直占⽤内存。</p><p><strong>定期删除</strong></p><p>定期删除指的是Redis每隔⼀段时间对数据库做⼀次检查，删除⾥⾯的过期key。由于不可能对所有key去做轮询来删除，所以Redis会每次随机取⼀些key去做检查和删除。</p><h3 id="使用Redis-如何实现异步队列"><a href="#使用Redis-如何实现异步队列" class="headerlink" title="使用Redis 如何实现异步队列"></a>使用Redis 如何实现异步队列</h3><p><strong>使用list作为队列，lpush生产消息，rpop消费消息</strong></p><p>这种方式，消费者死循环rpop从队列中消费消息。但是这样，即使队列里没有消息，也会进行rpop，会导致RedisCPU的消耗。</p><p>可以通过让消费者休眠的方式的方式来处理，但是这样又会有消息的延迟问题</p><p><strong>使用list作为队列，lpush生产消息，brpop消费消息</strong></p><p>brpop是rpop的阻塞版本，list为空的时候，它会一直阻塞，直到list中有值或者超时。</p><p>这种方式只能实现一对一的消息队列</p><p><strong>使用Redis的pub&#x2F;sub来进行消息的发布&#x2F;订阅</strong></p><p>发布&#x2F;订阅模式可以1：N的消息发布&#x2F;订阅。发布者将消息发布到指定的频道频道（channel），订阅相应频道的客户端都能收到消息</p><p>但是这种方式不是可靠的，它不保证订阅者一定能收到消息，也不进行消息的存储。</p><p>所以，一般的异步队列的实现还是交给专业的消息队列。</p><h3 id="Redis-如何实现延时队列"><a href="#Redis-如何实现延时队列" class="headerlink" title="Redis 如何实现延时队列"></a>Redis 如何实现延时队列</h3><p><strong>使用zset，利用排序实现</strong></p><p>可以使用 zset这个结构，用设置好的时间戳作为score进行排序，使用 zadd score1 value1 ….命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。</p><h3 id="Redis-支持事务"><a href="#Redis-支持事务" class="headerlink" title="Redis 支持事务"></a>Redis 支持事务</h3><p>Redis提供了简单的事务，但它对事务ACID的支持并不完备</p><p>multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的：</p><p>Redis事务的原理，是所有的指令在 exec 之前不执行，而是缓存在 服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。</p><p>因为Redis执行命令是单线程的，所以这组命令顺序执行，而且不会被其它线程打断。</p><p><strong>Redis事务的注意点有哪些</strong></p><ul><li>Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；</li><li>Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。</li></ul><p><strong>Redis 事务为什么不支持回滚</strong></p><p>Redis 的事务不支持回滚。<br>如果执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。<br>这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。</p><h3 id="Redis和Lua脚本的使用"><a href="#Redis和Lua脚本的使用" class="headerlink" title="Redis和Lua脚本的使用"></a>Redis和Lua脚本的使用</h3><p>Redis的事务功能比较简单，平时的开发中，可以利用Lua脚本来增强Redis的命令。</p><p>Lua脚本能给开发人员带来这些好处：</p><ul><li>Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令。</li><li>Lua脚本可以帮助开发和运维人员创造出自己定制的命令，并可以将这些命令常驻在Redis内存中，实现复用的效果。</li><li>Lua脚本可以将多条命令一次性打包，有效地减少网络开销。</li></ul><h3 id="Redis的管道"><a href="#Redis的管道" class="headerlink" title="Redis的管道"></a>Redis的管道</h3><p>Redis 提供三种将客户端多条命令打包发送给服务端执行的方式</p><p>Pipelining(管道) 、 Transactions(事务) 和 Lua Scripts(Lua 脚本) </p><p><strong>Pipelining（管道）</strong></p><p>Redis 管道是三者之中最简单的，当客户端需要执行多条 redis 命令时，可以通过管道一次性将要执行的多条命令发送给服务端，其作用是为了降低 RTT(Round Trip Time) 对性能的影响，比如我们使用 nc 命令将两条指令发送给 redis 服务端。</p><p>Redis 服务端接收到管道发送过来的多条命令后，会一直执命令，并将命令的执行结果进行缓存，直到最后一条命令执行完成，再所有命令的执行结果一次性返回给客户端 </p><p><strong>Pipelining的优势</strong></p><p>节省了RTT：将多条命令打包一次性发送给服务端，减少了客户端与服务端之间的网络调用次数<br>减少了上下文切换：当客户端&#x2F;服务端需要从网络中读写数据时，都会产生一次系统调用，系统调用是非常耗时的操作，其中设计到程序由用户态切换到内核态，再从内核态切换回用户态的过程。当我们执行 10 条 redis 命令的时候，就会发生 10 次用户态到内核态的上下文切换，但如果我们使用 Pipeining 将多条命令打包成一条一次性发送给服务端，就只会产生一次上下文切换。</p><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis是分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p><p><strong>V1：setnx命令</strong></p><p>占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑<br>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p><p><strong>V2:锁超时释放</strong></p><p>所以在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放<br>但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。<br>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。</p><p><strong>V3:set指令</strong></p><p>这个问题在Redis 2.8 版本中得到了解决，这个版本加入了 set 指令的扩展参数，使得 setnx 和expire 指令可以一起执行<br>当然实际的开发，没人会去自己写分布式锁的命令，因为有专业的轮子——Redisson。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deepin安装docker</title>
    <link href="/2023/05/03/linux_install_docker/"/>
    <url>/2023/05/03/linux_install_docker/</url>
    
    <content type="html"><![CDATA[<!-- Linux安装docker --><span id="more"></span><p>Linux安装docker</p><h3 id="如果你的电脑上安装过旧版本的docker，先卸载掉，卸载命令"><a href="#如果你的电脑上安装过旧版本的docker，先卸载掉，卸载命令" class="headerlink" title="如果你的电脑上安装过旧版本的docker，先卸载掉，卸载命令"></a>如果你的电脑上安装过旧版本的docker，先卸载掉，卸载命令</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">sudo apt <span class="hljs-built_in">remove</span> docker.<span class="hljs-built_in">io</span> docker-engine<br></code></pre></td></tr></table></figure><h3 id="下载RSA公钥证书"><a href="#下载RSA公钥证书" class="headerlink" title="下载RSA公钥证书"></a>下载RSA公钥证书</h3><p>docker的apt源采用的https通信方式，所以你需要先获取docker源的https证书（通常都是获取RSA公钥），之后你才能通过源地址和docker服务器进行通讯，所以第二步是下载RSA公钥证书</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 安装 curl 文件传输工具和 gnupg2 非对称加密相关依赖<br>sudo apt install curl gnupg2<br> <br><span class="hljs-regexp">//</span> 中科大源（无法翻出去的人建议用国内镜像源，速度比官方源快很多）<br>curl -fsSL https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/debian/g</span>pg | sudo apt-key add -<br> <br><span class="hljs-regexp">//</span> 官方源（有能力对外网加速的人请用官方源，毕竟可以第一时间获取最新的版本）<br>curl -fsSL https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>debian/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><h3 id="添加source-list文件"><a href="#添加source-list文件" class="headerlink" title="添加source.list文件"></a>添加source.list文件</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 中科大源（无法翻出去的人建议用国内镜像源，速度比官方源快很多）<br>echo <span class="hljs-string">&#x27;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian buster stable&#x27;</span> | sudo tee <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>docker.list<br> <br><span class="hljs-regexp">//</span> 官方源（有能力对外网加速的人请用官方源，毕竟可以第一时间获取最新的版本）<br>echo <span class="hljs-string">&#x27;deb [arch=amd64] https://download.docker.com/linux/debian buster stable&#x27;</span> | sudo tee <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>docker.list<br></code></pre></td></tr></table></figure><h3 id="更新源并安装docker-ce"><a href="#更新源并安装docker-ce" class="headerlink" title="更新源并安装docker-ce"></a>更新源并安装docker-ce</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">sudo apt <span class="hljs-keyword">update</span> <span class="hljs-variable">&amp;&amp;</span> sudo apt install docker-ce -y<br></code></pre></td></tr></table></figure><h3 id="查看安装的docker版本"><a href="#查看安装的docker版本" class="headerlink" title="查看安装的docker版本"></a>查看安装的docker版本</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">sudo docker <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CocoaPods安装</title>
    <link href="/2023/04/01/cocoapos_install/"/>
    <url>/2023/04/01/cocoapos_install/</url>
    
    <content type="html"><![CDATA[<!-- CocoaPods安装 --><span id="more"></span><p>CocoaPods安装</p><h3 id="使用brew安装"><a href="#使用brew安装" class="headerlink" title="使用brew安装"></a>使用brew安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>cocoapods<br></code></pre></td></tr></table></figure><h3 id="安装本地库"><a href="#安装本地库" class="headerlink" title="安装本地库"></a>安装本地库</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/// 这个命令是官方提供的，貌似在新系统上面无效</span><br>pod setup<br></code></pre></td></tr></table></figure><p>根据经验发现在MacOS Catalina 及以后的系统命令行执行pod setup命令后直接就直接结束了</p><h3 id="手动安装本地库"><a href="#手动安装本地库" class="headerlink" title="手动安装本地库"></a>手动安装本地库</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CocoaPods/</span>Specs.git ~<span class="hljs-regexp">/.cocoapods/</span>repos/trunk<br>git clone https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/git/</span>CocoaPods<span class="hljs-regexp">/Specs.git  ~/</span>.cocoapods<span class="hljs-regexp">/repos/</span>trunk<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pod search AFNetworking</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Homebrew</tag>
      
      <tag>Pod</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旧手机搭建Linux服务器</title>
    <link href="/2023/04/01/old_phone_linux/"/>
    <url>/2023/04/01/old_phone_linux/</url>
    
    <content type="html"><![CDATA[<!-- 旧手机搭建Linux服务器 --><span id="more"></span><p>旧手机搭建Linux服务器</p><h3 id="准备一台旧手机"><a href="#准备一台旧手机" class="headerlink" title="准备一台旧手机"></a>准备一台旧手机</h3><p>准备一台可以联网手机，Android版本不低于4.3</p><h3 id="将手机获取root权限"><a href="#将手机获取root权限" class="headerlink" title="将手机获取root权限"></a>将手机获取root权限</h3><p>需要root才能写入命令</p><h3 id="下载安装BusyBox"><a href="#下载安装BusyBox" class="headerlink" title="下载安装BusyBox"></a>下载安装BusyBox</h3><p>BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件。BusyBox 包含了一些简单的工，它集成压缩了 Linux 的许多工具和命令。</p><blockquote><p><a href="https://github.com/meefik/busybox/releases">https://github.com/meefik/busybox/releases</a></p></blockquote><h3 id="安装配置BusyBox"><a href="#安装配置BusyBox" class="headerlink" title="安装配置BusyBox"></a>安装配置BusyBox</h3><p>打开BusyBox，点击INSTALL进行安装。</p><p>然后在 APP左上角 - settings - install path，这是环境路径，一般为“&#x2F;system&#x2F;xbin”，不要修改这个路径，并将其牢记，以后会用到。</p><h3 id="下载安装Linux-Deploy"><a href="#下载安装Linux-Deploy" class="headerlink" title="下载安装Linux Deploy"></a>下载安装Linux Deploy</h3><blockquote><p><a href="https://github.com/meefik/linuxdeploy/releases">https://github.com/meefik/linuxdeploy/releases</a></p></blockquote><p>修改设置、关联BusyBox</p><p>点击左上角三条短线-设置，将屏幕常亮、锁定WIFI、CPU唤醒打开。</p><p>同样在设置中，找到“PATH 变量”，将其更改为“&#x2F;system&#x2F;xbin”，与上文BusyBox的环境路径保持一致。</p><h3 id="配置Linux-Deploy"><a href="#配置Linux-Deploy" class="headerlink" title="配置Linux Deploy"></a>配置Linux Deploy</h3><p>回到 Linux deploy 主界面，点击右下角按钮开始配置。本文以安装Ubuntu系统为例。</p><ul><li>发行版GNU&#x2F;Linux：Ubuntu</li><li>架构armhf（这个需要你自己查询自己手机的CPU架构是什么，因人而异）</li><li>发行版GNU&#x2F;Linux版本：bionic（即Ubuntu 18.04）</li><li>源地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</a></li><li>安装类型：镜像文件</li><li>安装路径：${EXTERNAL_STORAGE}&#x2F;ubuntu&#x2F;linux.img</li><li>镜像大小：5120MB</li><li>文件系统：ext4</li><li>用户名：root</li><li>用户密码：自己设定（ssh远程连接时使用）</li><li>特权用户：root</li><li>本地化：zh_CN.UTF-8</li><li>允许使用初始化系统</li><li>允许挂载Android上的资源<br> 增加挂载点列表：第一行：&#x2F;sdcard，第二行：&#x2F;mnt</li><li>启用ssh服务器</li><li>由于我们做服务器使用，不用安装图形界面与音频输出。</li></ul><p>配置完成后，回到初始界面，点击右上角三个小点 - 配置。</p><p>点击右上角三个小点 - 安装。</p><p>正常情况下，系统会开始自动安装Linux系统，屏幕上不断滚出下载信息，在使用国内源的情况下，下载过程将会持续10-30分钟，直到出现以下代码，则安装完成。</p><p><code>&lt;&lt;&lt; deploy</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装私有仓库Nexus</title>
    <link href="/2023/04/01/docker_install_neuxs/"/>
    <url>/2023/04/01/docker_install_neuxs/</url>
    
    <content type="html"><![CDATA[<!-- Docker安装私有仓库Nexus --><span id="more"></span><p>Nexus是一种特殊的远程仓库，它是架在局域网内的仓库服务。可以用于局域网中搭建docker、maven私有仓库。</p><h3 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta">#创建挂载目录</span><br><span class="hljs-title">mkdir</span> -p ./<span class="hljs-class"><span class="hljs-keyword">data</span>/nexus/<span class="hljs-keyword">data</span> &amp;&amp; chmod 777 ./<span class="hljs-keyword">data</span>/nexus/<span class="hljs-keyword">data</span></span><br></code></pre></td></tr></table></figure><h3 id="docker-compose-yml文件编写"><a href="#docker-compose-yml文件编写" class="headerlink" title="docker-compose.yml文件编写"></a>docker-compose.yml文件编写</h3><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">nexus</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">sonatype/nexus3</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">my_nexus</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/nexus/data:/nexus-data</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8081:8081&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8082:8082&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8083:8083&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8084:8084&quot;</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;INSTALL4J_ADD_VM_PARAMS=-Xms128m -Xmx512m -XX:MaxDirectMemorySize=512m -Djava.util.prefs.userRoot=/nexus-data/javaprefs&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br><br><span class="hljs-comment"># 安装，需要2-3分钟</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><h3 id="浏览器访问-http-ip-8081"><a href="#浏览器访问-http-ip-8081" class="headerlink" title="浏览器访问 http://ip:8081/"></a>浏览器访问 <a href="http://ip:8081/">http://ip:8081/</a></h3><p>登录docker容器查看密码</p><blockquote><p>docker exec -it nexus3 cat &#x2F;nexus-data&#x2F;admin.password &amp;&amp; echo</p></blockquote><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>仓库有3种类型</p><pre><code class="hljs">- hosted类型：即我们自己的宿主仓库，专门存储我们自己的aar或jar，上传aar也是上传到这种仓库。- proxy类型：即用来代理中央仓库的，中央仓库就是maven或google或jcenter或其它组织公开的仓库，创建这种仓库的时候，需要填写一个中央仓库的url即可。为什么要加proxy仓库呢，因为你的aar中可能依赖了maven central或jcenter或google的aar，它会去代理仓库中去找这些aar，找到后会下载到你的maven仓库中。- group类型：仓库组，即我们自己对外的仓库。它是一个仓库组，我们可以将hosted类型和proxy类型的仓库按照指定顺序加到这个仓库组中。在Android Studio的root project的build.gradle中填写仓库地址就是这个。在依赖aar或jar的时候，就是在group仓库组中按照仓库顺序寻找aar。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gradle</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stable-diffusion-webui使用</title>
    <link href="/2023/04/01/stable-diffusion-webui_use/"/>
    <url>/2023/04/01/stable-diffusion-webui_use/</url>
    
    <content type="html"><![CDATA[<!-- stable-diffusion-webui使用 --><span id="more"></span><p>内容来源于[<a href="https://www.tjsky.net/tutorial/457]">https://www.tjsky.net/tutorial/457]</a><br>本地部署stable-diffusion-webui前端+替换默认的模型，实现生成高质量的二次元图像，并且可以不受限制的生成图片（在线版一般会阻止NSFW内容生成）</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p><strong>安装 Python 3.10 与 pip</strong></p><p><strong>安装 Git</strong></p><p><strong>下载stable-diffusion-webui</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载项目源代码</span><br>git <span class="hljs-built_in">clone</span> https://github.com/AUTOMATIC1111/stable-diffusion-webui.git<br><span class="hljs-comment"># 切换到项目根目录</span><br><span class="hljs-built_in">cd</span> stable-diffusion-webui<br></code></pre></td></tr></table></figure><p><strong>下载模型文件</strong><br>stable-diffusion-webui只是个工具，他需要后端的训练模型来让AI参考建模。</p><pre><code class="hljs">- stable-diffusion：偏真人（一般简称为 SD 模型， SDwebui 模型）- waifu-diffusion：偏向二次元（一般简称 Waifu 模型，WD模型）- Novel-AI-Leaks：更加偏向二次元（一般简称 Naifu 模型）</code></pre><p><strong>下载stable-diffusion</strong><br>官网下载：<a href="https://huggingface.co/CompVis/stable-diffusion-v-1-4-original">https://huggingface.co/CompVis/stable-diffusion-v-1-4-original</a></p><p>将解压出.ckpt文件放在\stable-diffusion-webui\models\Stable-diffusion\ 下<br>文件名可以是任何你喜欢的英文名。比如stable-diffusion .ckpt</p><p><strong>下载 waifu-diffusion</strong><br>官网下载：<a href="https://huggingface.co/hakurei/waifu-diffusion-v1-3/tree/main">https://huggingface.co/hakurei/waifu-diffusion-v1-3/tree/main</a></p><p>将解压出.ckpt文件放在\stable-diffusion-webui\models\Stable-diffusion\ 下<br>文件名可以是任何你喜欢的英文名.比如waifu-diffusion-16.ckpt</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><pre><code class="hljs">1. 双击运行\stable-diffusion-webui\webui-user.bat（mac使用webui.sh）2. 耐心等待，脚本会自己检查依赖，会下载大约几个G的东西，解压安装到文件夹内（视网速不同，可能需要20分钟~2小时不等）无论看起来是不是半天没变化，感觉像卡住了，或者你发现电脑也没下载东西，窗口也没变化。（使用代理加速）3. 等待出现http://127.0.0.1:7860， 复制到浏览器访问即可（默认是 http://127.0.0.1:7860 ）（注意不要关闭这个窗口，关闭就退出了）</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code class="hljs">1.Prompt 里填写想要的特征点2.Negative prompt 里填不想要的特征点3.Sampling Steps 你可以理解让AI推演多少步，一般来说超过17基本就能看了，步数越多，画面中的细节就越多，但需要的时间也就越久，一般20~30是一个比较稳妥的设定。这个数不会改变画面内容，只会让内容更加精细，比如20的项链就是一个心形钻石，而50的项链还是同样的心形钻石，只是钻石上会有更加复杂的线条4.Sampling method 你可以理解成AI推演的算法，一般Euler a，Euler ，DDIM，都是不错的，任选一个就行。图片分辨率 这个就是拼显卡显存的，自己调吧，低于512X512可能画面就不会有太多细节了，越大的分辨率AI能发挥的地方就越多。5.下边是3个扩展选项，一般不需要勾选。Restore faces：勾选后可以生成更真实的脸，第一次勾选使用时，需要先下载几个G的运行库。Tiling：让图片可以平铺（类似瓷砖，生成的图案左右上下都可以无缝衔接上自己）Highres. fix：超分辨率，让AI用更高的分辨率填充内容，但生成的最终尺寸还是你上边设定的尺寸。6.生成几次，每次多少张Batch count：是一次运行几次Batch size： 是同时生成多少张比如：Batch count设置为4,用时N分钟*4，生成4张图；Batch count设置为4,用时N分钟，生成4张图，但是同时需要的显存也是4倍。512X512大概需要3.75GB显存，4倍就是15GB显存了。7.CFG Scale AI有多参考你的Prompt与Negative prompt开得越高，AI越严格按照你的设定走，但也会有越少的创意开的越低，AI就越放飞自我，随心所欲的画。一般7左右就行。8.Seed 随机数种子，AI作画从原理上其实就是用一个随机的噪声图，反推回图像。但因为计算机里也没有真随机嘛，所以实际上，AI作画的起始噪声，是可以量化为一个种子数的。9.Generate 开始干活按钮，这个就不用说了吧，点了AI就开始干活了。10.Stable Diffusion checkpoint 在最左上角，是选择模型的，前边让你下载了三个，请根据自己需求和体验自行选择使用。</code></pre><h3 id="stable-diffusion-webui-（SD-webui）界面介绍"><a href="#stable-diffusion-webui-（SD-webui）界面介绍" class="headerlink" title="stable diffusion webui （SD webui）界面介绍"></a>stable diffusion webui （SD webui）界面介绍</h3><pre><code class="hljs">- txt2img 文生图：顾名思义就是用文字生成图片- img2img 图生图：顾名思义就是用图片生成图片- Extras 更多：这里其实是“无损”放大图片用的- PNG info 图片信息：从图片exif里获取图片的信息，如果是SD原始生成的png图片，图片的exif信息里会写入图片生成参数的，所以你在网上看到大佬生成的美图，可以用这个功能帮你查看- Checkpoint Merger 模型（ckpt）合并：合并不同的模型，生成新的模型- Train 训练：自己炼 embedding 或者 hypernetwork- Settings 设置：顾名思义就是设置页面- Extensions 扩展：顾名思义这里是扩展的管理页面。</code></pre><h5 id="提示词-Prompt"><a href="#提示词-Prompt" class="headerlink" title="提示词 Prompt"></a>提示词 Prompt</h5><pre><code class="hljs">- 用文字描述你想要生成的东西- 支持的输入语言为英语（不用担心英语不好的问题，目前网上有很多tag生成器供你使用），SD支持用自然语言描述，不过还是推荐使用用逗号分隔的一个个的关键词来写，当然表情符号，emoji，甚至一些日语都是可以用的</code></pre><h5 id="tag语法"><a href="#tag语法" class="headerlink" title="tag语法"></a>tag语法</h5><pre><code class="hljs">- 分隔：不同的关键词tag之间，需要使用英文逗号,分隔，逗号前后有空格或者换行是不碍事的ex：1girl,loli,long hair,low twintails（1个女孩，loli，长发，低双马尾）- 混合：WebUi 使用 | 分隔多个关键词，实现混合多个要素，注意混合是同等比例混合，同时混。ex: 1girl,red|blue hair, long hair（1个女孩，红色与蓝色头发混合，长发）- 增强/减弱：有两种写法第一种 (提示词:权重数值)：数值从0.1~100，默认状态是1,低于1就是减弱，大于1就是加强ex: ,(loli:1.21),(one girl:1.21),(cat ears:1.1),(flower hairpin:0.9)第二种 (((提示词)))，每套一层()括号增强1.1倍,每套一层[]减弱1.1倍。也就是套两层是1.1*1.1=1.21倍，套三层是1.331倍，套4层是1.4641倍ex: ((loli)),((one girl)),(cat ears),[flower hairpin]和第一种写法等价所以还是建议使用第一种方式，因为清晰而准确- 渐变：比较简单的理解时，先按某种关键词生成，然后再此基础上向某个方向变化[关键词1:关键词2:数字]，数字大于1理解为第X步前为关键词1，第X步后变成关键词2，数字小于1理解为总步数的百分之X前为关键词1，之后变成关键词2ex：a girl with very long [white:yellow:16] hair 等价为 a girl with very long white hair- 交替：轮流使用关键词ex：[cow|horse] in a field比如这就是个牛马的混合物，如果你写的更长比如[cow|horse|cat|dog] in a field就是先朝着像牛努力，再朝着像马努力，再向着猫努力，再向着狗努力，再向着马努力</code></pre><h5 id="tag书写示例"><a href="#tag书写示例" class="headerlink" title="tag书写示例"></a>tag书写示例</h5><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">画质词&gt;&gt;<br>这个一般比较固定，无非是，杰作，最高画质，分辨率超级大之类的<br><br>风格词艺术风格词&gt;&gt;<br>比如是照片还是插画还是动画<br><br>图片的主题&gt;&gt;<br>比如这个画的主体是一个女孩，还是一只猫，是儿童还是少女，是猫还是狗，是白领还是学生<br><br>他们的外表&gt;&gt;<br>注意整体和细节都是从上到下描述，比如<br>发型（呆毛，耳后有头发，盖住眼睛的刘海，低双马尾，大波浪卷发），<br>发色（顶发金色，末端挑染彩色），<br>衣服（长裙，<span class="hljs-string">...</span>,室内鞋），<br>头部（红色眼睛），<br>颈部（项链），<br>手臂（露肩），<br>腹部（可看到肚脐），<br>腿部（长腿），<br>脚步（裸足）<br><br>他们的情绪&gt;&gt;<br>表述表情<br><br>他们的姿势&gt;&gt;<br>基础动作（站，坐，跑，走，蹲，趴，跪），<br>头动作（歪头，仰头，低头），<br>手动作（手在拢头发，放在胸前 ，举手），<br>腰动作（弯腰，跨坐，鸭子坐，鞠躬），<br>腿动作（交叉站，二郎腿，盘腿，跪坐），<br>复合动作（战斗姿态，JOJO立，背对背站）<br><br>图片的背景&gt;&gt;<br>室内，室外，树林，沙滩，星空下，太阳下，天气如何<br><br>杂项&gt;&gt;<br>比如眼睛描绘详细<br></code></pre></td></tr></table></figure><h5 id="tag书写要点"><a href="#tag书写要点" class="headerlink" title="tag书写要点"></a>tag书写要点</h5><pre><code class="hljs">- 虽然大家都管这个叫释放魔法，但真不是越长的魔咒（提示词）生成的图片越厉害，请尽量将关键词控制在75个（100个）以内。- 越关键的词，越往前放。- 相似的同类，放在一起。- 只写必要的关键词。</code></pre><h5 id="反向提示词-Negative-prompt"><a href="#反向提示词-Negative-prompt" class="headerlink" title="反向提示词 Negative prompt"></a>反向提示词 Negative prompt</h5><pre><code class="hljs">用文字描述你不想在图像中出现的东西AI大致做法就是    1. 对图片进行去噪处理，使其看起来更像你的提示词。    2. 对图片进行去噪处理，使其看起来更像你的反向提示词（无条件条件）。    3. 观察这两者之间的差异，并利用它来产生一组对噪声图片的改变    4. 尝试将最终结果移向前者而远离后者    5. 一个相对比较通用的负面提示词设置</code></pre><h5 id="采样迭代步数-Sampling-Steps"><a href="#采样迭代步数-Sampling-Steps" class="headerlink" title="采样迭代步数 Sampling Steps"></a>采样迭代步数 Sampling Steps</h5><pre><code class="hljs">AI绘画的原理用人话说就是，先随机出一个噪声图片然后一步步的调整图片，向你的 提示词 Prompt 靠拢Sampling Steps就是告诉AI，这样的步骤应该进行多少次。步骤越多，每一步移动也就越小越精确。同时也成比例增加生成图像所需要的时间。大部分采样器超过50步后意义就不大了</code></pre><h5 id="采样方法-Sampling-method"><a href="#采样方法-Sampling-method" class="headerlink" title="采样方法 Sampling method"></a>采样方法 Sampling method</h5><p>使用哪种采样器，人话就是让AI用什么算法。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Euler</span> a ：富有创造力，不同步数可以生产出不同的图片。 超过<span class="hljs-number">30</span>~<span class="hljs-number">40</span>步基本就没什么增益了。<br><span class="hljs-attribute">Euler</span>：最最常见基础的算法，最简单的，也是最快的。<br><span class="hljs-attribute">DDIM</span>：收敛快，一般<span class="hljs-number">20</span>步就差不多了。<br><span class="hljs-attribute">LMS</span>：eular的延伸算法，相对更稳定一点，<span class="hljs-number">30</span>步就比较稳定了<br><span class="hljs-attribute">PLMS</span>：再改进一点LMS<br><span class="hljs-attribute">DPM2</span>：DDIM的一种改进版，它的速度大约是 DDIM 的两倍<br></code></pre></td></tr></table></figure><h5 id="提示词相关性-CFG-Scale"><a href="#提示词相关性-CFG-Scale" class="headerlink" title="提示词相关性 CFG Scale"></a>提示词相关性 CFG Scale</h5><p>图像与你的提示的匹配程度。<br>增加这个值将导致图像更接近你的提示,但过高会让图像色彩过于饱和（你可以自己试试看）<br>太高后在一定程度上降低了图像质量。可以适当增加采样步骤来抵消画质的劣化。<br>一般在5~15之间为好，7，9，12是3个常见的设置值。</p><h5 id="宽度-X-高度-Width-X-Height"><a href="#宽度-X-高度-Width-X-Height" class="headerlink" title="宽度 X 高度 Width X Height"></a>宽度 X 高度 Width X Height</h5><p>单位是像素，适当增加尺寸，AI会试图填充更多的细节进来。<br>非常小的尺寸（低于256X256），会让AI没地方发挥，会导致图像质量下降。<br>非常高的尺寸（大于1024X1024），会让AI乱发挥，会导致图像质量下降。<br>增加尺寸需要更大的显存。4GB显存最大应该是1280X1280（极限）</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">因为常见的模型基本都是在<span class="hljs-number">512×512</span>和<span class="hljs-number">768X768</span>的基础上训练<br>分辨率过高，图片质量会随着分辨率的提高而变差<br>一般<span class="hljs-number">1024X1024</span>以上尺寸AI就会搞出搞各种鬼畜图。<br>如果模型明确某些分辨率最优，请遵照模型的要求<br>比如<span class="hljs-number">3</span>DKX系列模型就是明确推荐图片分辨率为<span class="hljs-number">1152</span> x <span class="hljs-number">768</span>。<br></code></pre></td></tr></table></figure><h5 id="随机种子-Seed"><a href="#随机种子-Seed" class="headerlink" title="随机种子 Seed"></a>随机种子 Seed</h5><p>AI绘画的原理是，先随机出一个噪声图片<br>因为计算机世界里不存在真随机<br>保持种子不变，同一模型和后端，保持所有参数一致的情况下，<br>相同的种子可以多次生成（几乎）相同的图像。<br>如果你用某个种子在某tag下生成了很棒的图，<br>保持种子数不变，而稍微改一点点tag，增减一点细节，一般得到的图也会不错。</p><h3 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h3><p>主要 stable diffusion webui 用大模型（ckpt与safetensors）包括了常见的模型比如的Waifu Diffusion、anything、f222、basil mix、urpm 、chillout mix等模型。</p><p>Lora（人物卡模型）和hypernetworks（embedding和hypernetwork）太多没有列出</p><h5 id="Stable-Diffusion"><a href="#Stable-Diffusion" class="headerlink" title="Stable Diffusion"></a>Stable Diffusion</h5><p>可以认为它是本文所有其他模型的底稿，几乎所有模型都是在这个模型的基础上再次训练得到的。</p><p>Stable Diffusion v2.1</p><ul><li>SDv2.1提升了人物生成能力，因为SDv2.0大量增加了风景、建筑物和动物的数据集，减少了人物的学习量。</li><li>SDv2.1提高了NSFW过滤器准确度，因为SDv2.0的成人过滤器过滤的太狠，错误判定很多</li><li>即使是极端长宽比的图像也能顺利生成。</li><li>解剖学的身体和手（特别是手掌）的描写精度提高。</li></ul><h5 id="Waifu-Diffusion"><a href="#Waifu-Diffusion" class="headerlink" title="Waifu Diffusion"></a>Waifu Diffusion</h5><p>基于Stable Diffusion 系列模型，增加动漫及人物训练得到的模型，缩写是WD。<br>它比NovelAI模型更安全，不是商用泄漏模型，但WD也使用 Danbooru 进行学习，所以如果你关心这个的话要注意</p><h5 id="NovelAI"><a href="#NovelAI" class="headerlink" title="NovelAI"></a>NovelAI</h5><p>绘图网站NovelAI的商用泄漏模型，模型经过人在回路精细微调，可以生成高质量的二次元图像<br>注意这是个商用模型的泄漏，所以部分使用方式下会有一定的法律风险，请注意这一点</p><h5 id="Elysium-Anime"><a href="#Elysium-Anime" class="headerlink" title="Elysium Anime"></a>Elysium Anime</h5><p>生成偏真实风格的动漫图片，风格比较偏向西式，光影还不错。<br>模型推荐写这些负面提示lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry可有效提升质量。</p><h5 id="Elysium-V1"><a href="#Elysium-V1" class="headerlink" title="Elysium_V1"></a>Elysium_V1</h5><p>偏真实风的模型，手画的还不错，模型底稿基本是以西方人为主，所以生成的脸也偏西方人。</p><h5 id="SD-Elysium-Kuro-Model"><a href="#SD-Elysium-Kuro-Model" class="headerlink" title="SD_Elysium_Kuro_Model"></a>SD_Elysium_Kuro_Model</h5><p>与Anything 4.0、WD 1.4等合并后经过微调的二次元用模型。<br>已经包含 WD 的“kl-f8-anime2”VAE 文件，因此无需使用额外的 VAE 文件</p><h5 id="Elysium-Anime-V3"><a href="#Elysium-Anime-V3" class="headerlink" title="Elysium_Anime_V3"></a>Elysium_Anime_V3</h5><p>动漫的附加学习模型，NSFW化相当严重，有更清晰的轮廓和轻微的三维效果。基于Elysium_V1</p><h5 id="3DKX"><a href="#3DKX" class="headerlink" title="3DKX"></a>3DKX</h5><p>因为Zeipher官方已经GG，这是热心网友创建的衍生3DKX模型<br>如果你想让你的 3D 角色有一张更“二次元”的脸，提示词最开始写 “3d cartoon of”，或者如果你想要经典的 3D 渲染外观，写“a 3d render of”<br>高分辨率模型，推荐分辨率为 1152 x 768 或更高</p><h5 id="R34"><a href="#R34" class="headerlink" title="R34"></a>R34</h5><p>从网站“rule34.xxx”的 150,000 张图像中进行训练。rule34.xxx几乎全是NSFW图片，所以你懂的</p><h5 id="EVT-pixiv排行榜模型"><a href="#EVT-pixiv排行榜模型" class="headerlink" title="EVT pixiv排行榜模型"></a>EVT pixiv排行榜模型</h5><p>基于pixiv排行图片训练，夹杂有部分R18排行图片</p><h5 id="Basil-mix"><a href="#Basil-mix" class="headerlink" title="Basil_mix"></a>Basil_mix</h5><p>逼真的真人模型，基于亚洲风格训练，支持Danbur标签提示词<br>需要加载VAE，不然画面色彩浓度和边缘会很淡<br>提示词应尽可能简单<br>不要堆砌大量质量标签和负面提示，不然会适得其反。</p><h5 id="Chillout-Mix"><a href="#Chillout-Mix" class="headerlink" title="Chillout Mix"></a>Chillout Mix</h5><p>逼真的真人模型，基于亚洲风格训练，支持Danbur标签提示词</p><h5 id="Uber-Realistic-Porn-Merge"><a href="#Uber-Realistic-Porn-Merge" class="headerlink" title="Uber Realistic Porn Merge"></a>Uber Realistic Porn Merge</h5><p>如名字所说，逼真的真人Porn模型，简称 URPM 模型，这是个融合模型。</p>]]></content>
    
    
    <categories>
      
      <category>Ai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven-publish使用</title>
    <link href="/2023/04/01/maven-publish_use/"/>
    <url>/2023/04/01/maven-publish_use/</url>
    
    <content type="html"><![CDATA[<!--  Maven-publish使用 --><span id="more"></span><h3 id="Gradle-使用-maven-publish-上传-aar-包到-Nexus-私服"><a href="#Gradle-使用-maven-publish-上传-aar-包到-Nexus-私服" class="headerlink" title="Gradle 使用 maven-publish 上传 aar 包到 Nexus 私服"></a>Gradle 使用 maven-publish 上传 aar 包到 Nexus 私服</h3><blockquote><p>在组件化项目架构中每个组件管理我们一般使用分仓库管理，每个组件分别打包成aar包引入项目依赖。老版本 gradle 我们一般使用 maven 插件来上传aar包，而 新版本更新了上传插件为 maven-publish</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 低版本使用</span><br><span class="hljs-attribute">apply</span> plugin: <span class="hljs-string">&#x27;maven&#x27;</span><br><br><span class="hljs-comment"># 6.X 以上版本变化</span><br>apply plugin: <span class="hljs-string">&#x27;maven-publish&#x27;</span><br><br><br>plugins &#123;<br>    <span class="hljs-attribute">id</span> <span class="hljs-string">&#x27;maven-publish&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="如何生成-aar-包"><a href="#如何生成-aar-包" class="headerlink" title="如何生成 aar 包"></a>如何生成 aar 包</h4><p>可以在 library 组件下执行 assemble 来生成 aar 包，输出目录为 ++build&#x2F;outputs&#x2F;aar++</p><h4 id="使用maven-publish-插件"><a href="#使用maven-publish-插件" class="headerlink" title="使用maven-publish 插件"></a>使用maven-publish 插件</h4><p>在module下gradle文件加入</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-keyword">def</span> GroupId = <span class="hljs-string">&#x27;com.zxj.lib&#x27;</span><br><span class="hljs-keyword">def</span> ArtifactId = <span class="hljs-string">&#x27;custom_lib&#x27;</span><br><span class="hljs-keyword">def</span> Version = <span class="hljs-string">&#x27;1.0.1&#x27;</span><br><br><span class="hljs-keyword">def</span> userName = <span class="hljs-string">&quot;admin&quot;</span><br><span class="hljs-keyword">def</span> passWord = <span class="hljs-string">&quot;123456&quot;</span><br><br><br><span class="hljs-keyword">def</span> releasesRepoUrl = <span class="hljs-string">&quot;http://172.18.15.140:8081/repository/custom_host/&quot;</span><br><br><br><span class="hljs-keyword">task</span> generateSourcesJar(type:Jar)&#123;<br>    <span class="hljs-keyword">from</span> android.<span class="hljs-keyword">sourceSets</span>.main.java.srcDirs<br>    classifier <span class="hljs-string">&quot;sources&quot;</span><br>&#125;<br><br><br><br>afterEvaluate &#123;<br>    publishing &#123;<br>        <span class="hljs-comment">//发布的 arr 包配置</span><br>        publications&#123;<br>            <span class="hljs-comment">//名字可以自己指定，如果有多渠道，整段多复制一个</span><br>            release(MavenPublication)&#123;<br><br>                groupId = GroupId<span class="hljs-comment">//公司域名</span><br>                artifactId = ArtifactId<span class="hljs-comment">//该aar包的名称</span><br>                version = Version<span class="hljs-comment">//版本号</span><br><br>                <span class="hljs-comment">// 必须有这个 否则不会上传AAR包</span><br>                afterEvaluate &#123; artifact(tasks.getByName(<span class="hljs-string">&quot;bundleReleaseAar&quot;</span>)) &#125;<br>                <span class="hljs-comment">// 多渠道，可以自行指定aar路径</span><br>                <span class="hljs-comment">// def projectName = project.getName()</span><br>                <span class="hljs-comment">// artifact &quot;build/outputs/aar/$&#123;projectName&#125;-release.aar&quot;</span><br>                <span class="hljs-comment">// 上传source，这样使用方可以看到方法注释</span><br>                artifact generateSourcesJar<br>                <span class="hljs-comment">//依赖关系</span><br>                pom.withXml&#123;<br>                    <span class="hljs-keyword">def</span> dependenciesNode = asNode().appendNode(<span class="hljs-string">&quot;dependencies&quot;</span>)<br>                    <span class="hljs-keyword">configurations</span>.implementation.allDependencies.forEach()&#123;<br>                        Dependency dependency -&gt;<br>                            <span class="hljs-keyword">if</span> (dependency.version != <span class="hljs-string">&quot;unspecified&quot;</span> &amp;&amp; dependency.name != <span class="hljs-string">&quot;unspecified&quot;</span>)&#123;<br>                                <span class="hljs-keyword">def</span> dependencyNode = dependenciesNode.appendNode(<span class="hljs-string">&#x27;dependency&#x27;</span>)<br>                                dependencyNode.appendNode(<span class="hljs-string">&#x27;groupId&#x27;</span>, dependency.<span class="hljs-keyword">group</span>)<br>                                dependencyNode.appendNode(<span class="hljs-string">&#x27;artifactId&#x27;</span>, dependency.name)<br>                                dependencyNode.appendNode(<span class="hljs-string">&#x27;version&#x27;</span>, dependency.version)<br>                            &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//仓库地址配置</span><br>        <span class="hljs-keyword">repositories</span> &#123;<br>            maven &#123;<br>                <span class="hljs-comment">//允许使用 http</span><br>                allowInsecureProtocol = <span class="hljs-keyword">true</span><br>                url = releasesRepoUrl<br>                credentials &#123;<br>                    username = userName<br>                    password = passWord<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行 <strong>gradle push</strong> 发布</p>]]></content>
    
    
    <categories>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift基础语法</title>
    <link href="/2023/02/04/swift_base/"/>
    <url>/2023/02/04/swift_base/</url>
    
    <content type="html"><![CDATA[<!-- Swift基础语法 --><span id="more"></span><p>Swift基础语法</p><p>Swift 通过采用现代编程模式来避免大量常见编程错误：</p><ul><li>变量始终在使用前初始化。</li><li>检查数组索引超出范围的错误。</li><li>检查整数是否溢出。</li><li>可选值确保明确处理 nil 值。</li><li>内存被自动管理。</li><li>错误处理允许从意外故障控制恢复。</li></ul><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h3><p>声明常量和变量， 常量和变量必须在使用前声明，使用 let 来声明常量，使用 var 来声明变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> maximumNumberOfLoginAttempts = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> currentLoginAttempt = <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 类型注解</span><br><span class="hljs-keyword">var</span> <span class="hljs-attr">welcomeMessage</span>: <span class="hljs-title class_">String</span><br></code></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释双正斜杠（&#x2F;&#x2F;）， 多行注释（&#x2F;* 多行的 *&#x2F;）。 Swift 的多行注释可以嵌套在其它的多行注释之中</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">// 这是一个注释</span><br><br><span class="hljs-comment">/* 这也是一个注释，</span><br><span class="hljs-comment">但是是多行的 */</span><br><br><span class="hljs-comment">/* 这是第一个多行注释的开头</span><br><span class="hljs-comment"><span class="hljs-comment">/* 这是第二个被嵌套的多行注释 */</span></span><br><span class="hljs-comment">这是第一个多行注释的结尾 */</span><br></code></pre></td></tr></table></figure><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>Swift 并不强制要求你在每条语句的结尾处使用分号（;）。<br>同一行内写多条独立的语句必须用分号分隔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> <span class="hljs-built_in">cat</span> = <span class="hljs-string">&quot;🐱&quot;</span>; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">cat</span>)<br>// 输出“🐱”<br></code></pre></td></tr></table></figure><h3 id="整数、浮点数"><a href="#整数、浮点数" class="headerlink" title="整数、浮点数"></a>整数、浮点数</h3><p>统一使用 Int 可以提高代码的可复用性，避免不同类型数字之间的转换， 并且匹配数字的类型推断。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">let</span> minValue = <span class="hljs-built_in">UInt8</span>.min  // minValue 为 <span class="hljs-number">0</span>，是 <span class="hljs-built_in">UInt8</span> 类型<br><span class="hljs-keyword">let</span> maxValue = <span class="hljs-built_in">UInt8</span>.max  // maxValue 为 <span class="hljs-number">255</span>，是 <span class="hljs-built_in">UInt8</span> 类型<br></code></pre></td></tr></table></figure><h3 id="类型安全和类型推断"><a href="#类型安全和类型推断" class="headerlink" title="类型安全和类型推断"></a>类型安全和类型推断</h3><p>Swift 是一门类型安全的语言，这意味着 Swift 可以让你清楚地知道值的类型。<br>如果你没有显式指定类型，Swift 会使用类型推断来选择合适的类型。（int、double）。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">let</span> meaningOfLife = <span class="hljs-number">42</span><br>// meaningOfLife 会被推测为 <span class="hljs-built_in">Int</span> 类型<br><br><span class="hljs-keyword">let</span> <span class="hljs-literal">pi</span> = <span class="hljs-number">3.14159</span><br>// <span class="hljs-literal">pi</span> 会被推测为 Double 类型<br></code></pre></td></tr></table></figure><h3 id="数值型字面量、数值型类型转换"><a href="#数值型字面量、数值型类型转换" class="headerlink" title="数值型字面量、数值型类型转换"></a>数值型字面量、数值型类型转换</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> decimalInteger = <span class="hljs-number">17</span><br><span class="hljs-built_in">let</span> binaryInteger = <span class="hljs-number">0b10001</span>       // 二进制的<span class="hljs-number">17</span><br><span class="hljs-built_in">let</span> octalInteger = <span class="hljs-number">0o21</span>           // 八进制的<span class="hljs-number">17</span><br><span class="hljs-built_in">let</span> hexadecimalInteger = <span class="hljs-number">0x11</span>     // 十六进制的<span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用 typealias 关键字来定义类型别名。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">AudioSample</span> <span class="hljs-operator">=</span> <span class="hljs-type">UInt16</span><br><span class="hljs-keyword">var</span> maxAmplitudeFound <span class="hljs-operator">=</span> <span class="hljs-type">AudioSample</span>.min<br><span class="hljs-comment">// maxAmplitudeFound 现在是 0</span><br></code></pre></td></tr></table></figure><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">orangesAreOrange</span> = <span class="hljs-literal">true</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">turnipsAreDelicious</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">let http404Error = (<span class="hljs-number">404</span>, <span class="hljs-string">&quot;Not Found&quot;</span>)<br>// http404Error的类型是（<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">String</span>）, 值是（<span class="hljs-number">404</span>, <span class="hljs-string">&quot;Not Found&quot;</span>）<br></code></pre></td></tr></table></figure><h3 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h3><p>使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能： 或者有值， 你可以解析可选类型访问这个值， 或者根本没有值</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> serverResponseCode: Int? = <span class="hljs-number">404</span><br><span class="hljs-comment">// serverResponseCode 包含一个可选的 Int 值 404</span><br>serverResponseCode = <span class="hljs-keyword">nil</span><br><span class="hljs-comment">// serverResponseCode 现在不包含值</span><br></code></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理，应对程序执行中可能会遇到的错误条件。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-built_in">makeASandwich</span>() throws &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>do &#123;<br>    try <span class="hljs-built_in">makeASandwich</span>()<br>    <span class="hljs-built_in">eatASandwich</span>()<br>&#125; catch SandwichError<span class="hljs-selector-class">.outOfCleanDishes</span> &#123;<br>    <span class="hljs-built_in">washDishes</span>()<br>&#125; catch SandwichError<span class="hljs-selector-class">.missingIngredients</span>(let ingredients) &#123;<br>    <span class="hljs-built_in">buyGroceries</span>(ingredients)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="断言和先决条件"><a href="#断言和先决条件" class="headerlink" title="断言和先决条件"></a>断言和先决条件</h3><p>断言和先决条件，是在运行时所做的检查。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let age = -<span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-title">assert</span><span class="hljs-params">(age &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">&quot;A person&#x27;s age cannot be less than zero&quot;</span>)</span></span><br><span class="hljs-comment">// 因为 age &lt; 0，所以断言会触发</span><br></code></pre></td></tr></table></figure><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p>赋值运算符，算术运算符，组合赋值运算符，比较运算符，三元运算符，空合运算符，区间运算符，逻辑运算符<br>运算符分为一元、二元和三元运算符。<br>闭区间运算符（a…b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。<br>半开区间运算符（a..&lt;b）定义一个从 a 到 b 但不包括 b 的区间。<br>闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间，(a…，…b)。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> names = [<span class="hljs-string">&quot;Anna&quot;</span>, <span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-string">&quot;Brian&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>]<br><span class="hljs-keyword">let</span> <span class="hljs-built_in">count</span> = names.<span class="hljs-built_in">count</span><br><span class="hljs-keyword">for</span> i in <span class="hljs-number">0</span>..&lt;<span class="hljs-built_in">count</span> &#123;<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;第 \(i + 1) 个人叫 \(names[i])&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h3><p>字符串字面量，字符串插值，计算字符数量，访问和修改字符串，子字符串，比较字符串<br>初始化空字符串，字符串可变性，字符串是值类型，连接字符串和字符(+，+&#x3D;)。<br>使用字符，可通过 for-in 循环来遍历字符串，获取字符串中每一个字符的值。<br>字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。可以在已有字符串中插入常量、变量、字面量和表达式从而形成更长的字符串。<br>Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pony"><span class="hljs-comment">/// 多行字符串字面量</span><br><span class="hljs-keyword">let</span> quotation = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">The White Rabbit put on his spectacles.  &quot;Where shall I begin,</span><br><span class="hljs-string">please your Majesty?&quot; he asked.</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on</span><br><span class="hljs-string">till you come to the end; then stop.&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment">// 下面两个字符串其实是一样的</span><br><span class="hljs-keyword">let</span> singleLineString = <span class="hljs-string">&quot;These are the same.&quot;</span><br><span class="hljs-keyword">let</span> multilineString = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">These are the same.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment">// 字符串插值</span><br><span class="hljs-keyword">let</span> multiplier = <span class="hljs-number">3</span><br><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;</span><br><span class="hljs-comment">// message 是 &quot;3 times 2.5 is 7.5&quot;</span><br><br><span class="hljs-comment">// 计算字符数量</span><br><span class="hljs-keyword">var</span> word = <span class="hljs-string">&quot;cafe&quot;</span><br>print(<span class="hljs-string">&quot;the number of characters in \(word) is \(word.count)&quot;</span>)<br><span class="hljs-comment">// 打印输出“the number of characters in cafe is 4”</span><br><br><span class="hljs-keyword">var</span> emptyString = <span class="hljs-string">&quot;&quot;</span>               <span class="hljs-comment">// 空字符串字面量</span><br><span class="hljs-keyword">var</span> anotherEmptyString = <span class="hljs-type">String</span>()  <span class="hljs-comment">// 初始化方法</span><br><span class="hljs-comment">// 两个字符串均为空并等价。</span><br><br><span class="hljs-keyword">let</span> catCharacters: [<span class="hljs-type">Character</span>] = [<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>]<br><span class="hljs-keyword">let</span> catString = <span class="hljs-type">String</span>(catCharacters)<br>print(catString)<br><span class="hljs-comment">// 打印输出：“Cat!”</span><br></code></pre></td></tr></table></figure><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p>Swift 语言提供数组（Array）、集合（Set）和字典（Dictionary）三种基本的集合类型用来存储集合数据。数组是有序数据的集。集合是无序无重复数据的集。字典是无序的键值对的集。</p><h4 id="集合的可变性，数组（Arrays），集合（Sets），集合操作，字典"><a href="#集合的可变性，数组（Arrays），集合（Sets），集合操作，字典" class="headerlink" title="集合的可变性，数组（Arrays），集合（Sets），集合操作，字典"></a>集合的可变性，数组（Arrays），集合（Sets），集合操作，字典</h4><p>数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。<br>集合用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。<br>集合操作，可以高效地完成集合的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。<br>字典是一种无序的集合，它存储的是键值对之间的关系，其所有键的值需要是相同的类型，所有值的类型也需要相同。每个值（value）都关联唯一的键（key），键作为字典中这个值数据的标识符。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 集合</span><br><span class="hljs-selector-tag">var</span> someInts = <span class="hljs-selector-attr">[Int]</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;someInts is of type [Int] with \(someInts.count) items.&quot;</span>)</span></span><br><span class="hljs-comment">// 打印“someInts is of type [Int] with 0 items.”</span><br><br><span class="hljs-selector-tag">var</span> threeDoubles = <span class="hljs-built_in">Array</span>(repeating: <span class="hljs-number">0.0</span>, count: <span class="hljs-number">3</span>)<br><span class="hljs-comment">// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</span><br><br><span class="hljs-selector-tag">var</span> anotherThreeDoubles = <span class="hljs-built_in">Array</span>(repeating: <span class="hljs-number">2.5</span>, count: <span class="hljs-number">3</span>)<br><span class="hljs-comment">// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]</span><br><span class="hljs-selector-tag">var</span> sixDoubles = threeDoubles + anotherThreeDoubles<br><span class="hljs-comment">// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span><br><br><span class="hljs-comment">// enumerated() 方法遍历数组</span><br><span class="hljs-selector-tag">var</span> shoppingList: <span class="hljs-selector-attr">[String]</span> = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;Eggs&quot;</span>, <span class="hljs-string">&quot;Milk&quot;</span>]</span><br><span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> shoppingList<span class="hljs-selector-class">.enumerated</span>() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Item \(String(index + 1)): \(value)&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>For-In 循环，While 循环（Repeat-While），条件语句，控制转移语句，提前退出（guard），检测 API 可用性</p><p>像 if 语句一样，guard 的执行取决于一个表达式的布尔值。我们可以使用 guard 语句来要求条件必须为真时，以执行 guard 语句后的代码。不同于 if 语句，一个 guard 语句总是有一个 else 从句，如果条件不为真则执行 else 从句中的代码。<br>Swift 内置支持检查 API 可用性，编译器使用 SDK 中的可用信息来验证我们的代码中使用的所有 API 在项目指定的部署目标上是否可用。如果我们尝试使用一个不可用的 API，Swift 会在编译时报错。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> names <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Anna&quot;</span>, <span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-string">&quot;Brian&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>]<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, <span class="hljs-subst">\(name)</span>!&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> numberOfLegs <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;spider&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&quot;ant&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&quot;cat&quot;</span>: <span class="hljs-number">4</span>]<br><span class="hljs-keyword">for</span> (animalName, legCount) <span class="hljs-keyword">in</span> numberOfLegs &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(animalName)</span>s have <span class="hljs-subst">\(legCount)</span> legs&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//repeat &#123;</span><br><span class="hljs-comment">//    statements</span><br><span class="hljs-comment">//&#125; while condition</span><br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">person</span>: [<span class="hljs-params">String</span>: <span class="hljs-type">String</span>]) &#123;<br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> person[<span class="hljs-string">&quot;name&quot;</span>] <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello <span class="hljs-subst">\(name)</span>!&quot;</span>)<br>    <br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> location <span class="hljs-operator">=</span> person[<span class="hljs-string">&quot;location&quot;</span>] <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I hope the weather is nice near you.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I hope the weather is nice in <span class="hljs-subst">\(location)</span>.&quot;</span>)<br>&#125;<br><br>greet(person: [<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>])<br><br>greet(person: [<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;location&quot;</span>: <span class="hljs-string">&quot;Cupertino&quot;</span>])<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的定义与调用，函数参数与返回值，函数参数标签和参数名称，函数类型，嵌套函数</p><p>可选元组返回类型。<br>定义一个输入输出参数时，在参数定义前加 inout 关键字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 函数</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">person</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> greeting <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span> <span class="hljs-operator">+</span> person <span class="hljs-operator">+</span> <span class="hljs-string">&quot;!&quot;</span><br>    <span class="hljs-keyword">return</span> greeting<br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">person</span>: <span class="hljs-type">String</span>, <span class="hljs-params">from</span> <span class="hljs-params">hometown</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello <span class="hljs-subst">\(person)</span>!  Glad you could visit from <span class="hljs-subst">\(hometown)</span>.&quot;</span><br>&#125;<br><span class="hljs-built_in">print</span>(greet(person: <span class="hljs-string">&quot;Bill&quot;</span>, from: <span class="hljs-string">&quot;Cupertino&quot;</span>))<br><span class="hljs-comment">// 打印“Hello Bill!  Glad you could visit from Cupertino.”</span><br><br><span class="hljs-comment">// 可选元组返回类型</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">minMax</span>(<span class="hljs-params">array</span>: [<span class="hljs-type">Int</span>]) -&gt; (min: <span class="hljs-type">Int</span>, max: <span class="hljs-type">Int</span>)<span class="hljs-operator">?</span> &#123;<br>    <span class="hljs-keyword">if</span> array.isEmpty &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    <span class="hljs-keyword">var</span> currentMin <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">var</span> currentMax <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>array.count] &#123;<br>        <span class="hljs-keyword">if</span> value <span class="hljs-operator">&lt;</span> currentMin &#123;<br>            currentMin <span class="hljs-operator">=</span> value<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> value <span class="hljs-operator">&gt;</span> currentMax &#123;<br>            currentMax <span class="hljs-operator">=</span> value<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (currentMin, currentMax)<br>&#125;<br><br><span class="hljs-comment">// 隐式返回的函数</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">greeting</span>(<span class="hljs-params">for</span> <span class="hljs-params">person</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-string">&quot;Hello, &quot;</span> <span class="hljs-operator">+</span> person <span class="hljs-operator">+</span> <span class="hljs-string">&quot;!&quot;</span><br>&#125;<br><span class="hljs-built_in">print</span>(greeting(for: <span class="hljs-string">&quot;Dave&quot;</span>))<br><span class="hljs-comment">// 打印 &quot;Hello, Dave!</span><br><br><span class="hljs-comment">// 参数标签</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">person</span>: <span class="hljs-type">String</span>, <span class="hljs-params">from</span> <span class="hljs-params">hometown</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello <span class="hljs-subst">\(person)</span>!  Glad you could visit from <span class="hljs-subst">\(hometown)</span>.&quot;</span><br>&#125;<br><span class="hljs-built_in">print</span>(greet(person: <span class="hljs-string">&quot;Bill&quot;</span>, from: <span class="hljs-string">&quot;Cupertino&quot;</span>))<br><span class="hljs-comment">// 打印“Hello Bill!  Glad you could visit from Cupertino.”</span><br></code></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是自包含的函数代码块，可以在代码中被传递和使用。与一些编程语言中的匿名函数（Lambdas）比较相似。</p><p>闭包表达式，尾随闭包，值捕获，闭包是引用类型，逃逸闭包（@escaping），自动闭包</p><p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。</p><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 闭包表达式语法</span><br>&#123; (parameters) -&gt; <span class="hljs-keyword">return</span> type <span class="hljs-keyword">in</span><br>    statements<br>&#125;<br><br><span class="hljs-comment">// 尾随闭包</span><br><span class="hljs-keyword">let</span> digitNames <span class="hljs-operator">=</span> [<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Zero&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;Two&quot;</span>,   <span class="hljs-number">3</span>: <span class="hljs-string">&quot;Three&quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;Four&quot;</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-string">&quot;Five&quot;</span>, <span class="hljs-number">6</span>: <span class="hljs-string">&quot;Six&quot;</span>, <span class="hljs-number">7</span>: <span class="hljs-string">&quot;Seven&quot;</span>, <span class="hljs-number">8</span>: <span class="hljs-string">&quot;Eight&quot;</span>, <span class="hljs-number">9</span>: <span class="hljs-string">&quot;Nine&quot;</span><br>]<br><span class="hljs-keyword">let</span> numbers <span class="hljs-operator">=</span> [<span class="hljs-number">16</span>, <span class="hljs-number">58</span>, <span class="hljs-number">510</span>]<br><span class="hljs-keyword">let</span> strings <span class="hljs-operator">=</span> numbers.map &#123;<br>    (number) -&gt; <span class="hljs-type">String</span> <span class="hljs-keyword">in</span><br>    <span class="hljs-keyword">var</span> number <span class="hljs-operator">=</span> number<br>    <span class="hljs-keyword">var</span> output <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">repeat</span> &#123;<br>        output <span class="hljs-operator">=</span> digitNames[number <span class="hljs-operator">%</span> <span class="hljs-number">10</span>]<span class="hljs-operator">!</span> <span class="hljs-operator">+</span> output<br>        number <span class="hljs-operator">/=</span> <span class="hljs-number">10</span><br>    &#125; <span class="hljs-keyword">while</span> number <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> output<br>&#125;<br><span class="hljs-comment">// strings 常量被推断为字符串类型数组，即 [String]</span><br><span class="hljs-comment">// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</span><br><br><span class="hljs-comment">// 值捕获</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIncrementer</span>(<span class="hljs-params">forIncrement</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Int</span>) -&gt; () -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">incrementer</span>() -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> amount<br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-comment">// 自动闭包，延迟求值</span><br><span class="hljs-keyword">var</span> customersInLine <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Chris&quot;</span>, <span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-string">&quot;Ewa&quot;</span>, <span class="hljs-string">&quot;Barry&quot;</span>, <span class="hljs-string">&quot;Daniella&quot;</span>]<br><span class="hljs-built_in">print</span>(customersInLine.count)<br><span class="hljs-comment">// 打印出“5”</span><br><br><span class="hljs-keyword">let</span> customerProvider <span class="hljs-operator">=</span> &#123; customersInLine.remove(at: <span class="hljs-number">0</span>) &#125;<br><span class="hljs-built_in">print</span>(customersInLine.count)<br><span class="hljs-comment">// 打印出“5”</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Now serving <span class="hljs-subst">\(customerProvider())</span>!&quot;</span>)<br><span class="hljs-comment">// Prints &quot;Now serving Chris!&quot;</span><br><span class="hljs-built_in">print</span>(customersInLine.count)<br><span class="hljs-comment">// 打印出“4”</span><br></code></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用 enum 关键词来创建枚举并且把它们的整个定义放在一对大括号内。</p><p>枚举语法，使用 Switch 语句匹配枚举值，枚举成员的遍历，关联值，原始值（默认值），递归枚举（indirect）</p><p>可以定义 Swift 枚举来存储任意类型的关联值，每个枚举成员的关联值类型可以各不相同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 枚举语法</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SomeEnumeration</span> &#123;<br>    <span class="hljs-comment">// 枚举定义放在这里</span><br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CompassPoint</span> &#123;<br>    <span class="hljs-keyword">case</span> north<br>    <span class="hljs-keyword">case</span> south<br>    <span class="hljs-keyword">case</span> east<br>    <span class="hljs-keyword">case</span> west<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Planet</span> &#123;<br>    <span class="hljs-keyword">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune<br>&#125;<br><br><span class="hljs-keyword">let</span> somePlanet <span class="hljs-operator">=</span> <span class="hljs-type">Planet</span>.earth<br><span class="hljs-keyword">switch</span> somePlanet &#123;<br><span class="hljs-keyword">case</span> .earth:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Mostly harmless&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Not a safe place for humans&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 打印“Mostly harmless”</span><br><br><span class="hljs-comment">// 关联值</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Barcode</span> &#123;<br>    <span class="hljs-keyword">case</span> upc(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> qrCode(<span class="hljs-type">String</span>)<br>&#125;<br><span class="hljs-keyword">var</span> productBarcode <span class="hljs-operator">=</span> <span class="hljs-type">Barcode</span>.upc(<span class="hljs-number">8</span>, <span class="hljs-number">85909</span>, <span class="hljs-number">51226</span>, <span class="hljs-number">3</span>)<br>productBarcode <span class="hljs-operator">=</span> .qrCode(<span class="hljs-string">&quot;ABCDEFGHIJKLMNOP&quot;</span>)<br><br><span class="hljs-keyword">switch</span> productBarcode &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .upc(numberSystem, manufacturer, product, check):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;UPC: <span class="hljs-subst">\(numberSystem)</span>, <span class="hljs-subst">\(manufacturer)</span>, <span class="hljs-subst">\(product)</span>, <span class="hljs-subst">\(check)</span>.&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .qrCode(productCode):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;QR code: <span class="hljs-subst">\(productCode)</span>.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 打印“QR code: ABCDEFGHIJKLMNOP.”</span><br><br><span class="hljs-comment">// 递归枚举</span><br><span class="hljs-keyword">indirect</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ArithmeticExpression</span> &#123;<br>    <span class="hljs-keyword">case</span> number(<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> addition(<span class="hljs-type">ArithmeticExpression</span>, <span class="hljs-type">ArithmeticExpression</span>)<br>    <span class="hljs-keyword">case</span> multiplication(<span class="hljs-type">ArithmeticExpression</span>, <span class="hljs-type">ArithmeticExpression</span>)<br>&#125;<br><span class="hljs-keyword">let</span> five <span class="hljs-operator">=</span> <span class="hljs-type">ArithmeticExpression</span>.number(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">let</span> four <span class="hljs-operator">=</span> <span class="hljs-type">ArithmeticExpression</span>.number(<span class="hljs-number">4</span>)<br><span class="hljs-keyword">let</span> sum <span class="hljs-operator">=</span> <span class="hljs-type">ArithmeticExpression</span>.addition(five, four)<br><span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> <span class="hljs-type">ArithmeticExpression</span>.multiplication(sum, <span class="hljs-type">ArithmeticExpression</span>.number(<span class="hljs-number">2</span>))<br><span class="hljs-comment">// (5 + 4) * 2</span><br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">ArithmeticExpression</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">switch</span> expression &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .number(value):<br>        <span class="hljs-keyword">return</span> value<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .addition(left, right):<br>        <span class="hljs-keyword">return</span> evaluate(left) <span class="hljs-operator">+</span> evaluate(right)<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .multiplication(left, right):<br>        <span class="hljs-keyword">return</span> evaluate(left) <span class="hljs-operator">*</span> evaluate(right)<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">print</span>(evaluate(product))<br><span class="hljs-comment">// 打印“18”</span><br></code></pre></td></tr></table></figure><h3 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h3><h5 id="结构体和类对比，结构体和枚举是值类型，类是引用类型"><a href="#结构体和类对比，结构体和枚举是值类型，类是引用类型" class="headerlink" title="结构体和类对比，结构体和枚举是值类型，类是引用类型"></a>结构体和类对比，结构体和枚举是值类型，类是引用类型</h5><p>结构体和类作为一种通用而又灵活的结构，成为了人们构建代码的基础。你可以使用定义常量、变量和函数的语法，为你的结构体和类定义属性、添加方法。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">// 类和结构体</span><br><span class="hljs-variable">struct</span> <span class="hljs-title class_">SomeStructure</span> &#123;<br>    <span class="hljs-comment">// 在这里定义结构体</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span> &#123;<br>    <span class="hljs-comment">// 在这里定义类</span><br>&#125;<br><br><span class="hljs-variable">struct</span> <span class="hljs-title class_">Resolution</span> &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoMode</span> &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">resolution</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">Resolution</span>()<br>    <span class="hljs-keyword">var</span> interlaced <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">frameRate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">name</span>: <span class="hljs-title class_">String</span>?<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h5 id="存储属性，计算属性，属性观察器，属性包装器，全局变量和局部变量，类型属性（static）"><a href="#存储属性，计算属性，属性观察器，属性包装器，全局变量和局部变量，类型属性（static）" class="headerlink" title="存储属性，计算属性，属性观察器，属性包装器，全局变量和局部变量，类型属性（static）"></a>存储属性，计算属性，属性观察器，属性包装器，全局变量和局部变量，类型属性（static）</h5><p>属性将值与特定的类、结构体或枚举关联。存储属性会将常量和变量存储为实例的一部分，而计算属性则是直接计算（而不是存储）值。计算属性可以用于类、结构体和枚举，而存储属性只能用于类和结构体。<br>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外</p><p>willSet 在新的值被设置之前调用<br>didSet 在新的值被设置之后调用</p><p>属性包装器在管理属性如何存储和定义属性的代码之间添加了一个分隔层。<br>类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 属性</span><br>struct Point &#123;<br>    <span class="hljs-selector-tag">var</span> x = <span class="hljs-number">0.0</span>, y = <span class="hljs-number">0.0</span><br>&#125;<br>struct Size &#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-attribute">width</span> = <span class="hljs-number">0.0</span>, height = <span class="hljs-number">0.0</span><br>&#125;<br>struct Rect &#123;<br>    <span class="hljs-selector-tag">var</span> origin = <span class="hljs-built_in">Point</span>()<br>    <span class="hljs-selector-tag">var</span> size = <span class="hljs-built_in">Size</span>()       <span class="hljs-comment">//存储属性</span><br>    <span class="hljs-selector-tag">var</span> center: Point &#123;     <span class="hljs-comment">//计算型属性</span><br>        get &#123;<br>            let centerX = origin<span class="hljs-selector-class">.x</span> + (size<span class="hljs-selector-class">.width</span> / <span class="hljs-number">2</span>)<br>            let centerY = origin<span class="hljs-selector-class">.y</span> + (size<span class="hljs-selector-class">.height</span> / <span class="hljs-number">2</span>)<br>            return <span class="hljs-built_in">Point</span>(x: centerX, y: centerY)<br>        &#125;<br>        <span class="hljs-built_in">set</span>(newCenter) &#123;<br>            origin<span class="hljs-selector-class">.x</span> = newCenter<span class="hljs-selector-class">.x</span> - (size<span class="hljs-selector-class">.width</span> / <span class="hljs-number">2</span>)<br>            origin<span class="hljs-selector-class">.y</span> = newCenter<span class="hljs-selector-class">.y</span> - (size<span class="hljs-selector-class">.height</span> / <span class="hljs-number">2</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-selector-tag">var</span> square = <span class="hljs-built_in">Rect</span>(origin: <span class="hljs-built_in">Point</span>(x: <span class="hljs-number">0.0</span>, y: <span class="hljs-number">0.0</span>),<br>    size: <span class="hljs-built_in">Size</span>(<span class="hljs-attribute">width</span>: <span class="hljs-number">10.0</span>, height: <span class="hljs-number">10.0</span>))<br>let initialSquareCenter = square<span class="hljs-selector-class">.center</span><br>square<span class="hljs-selector-class">.center</span> = <span class="hljs-built_in">Point</span>(x: <span class="hljs-number">15.0</span>, y: <span class="hljs-number">15.0</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;square.origin is now at (\(square.origin.x), \(square.origin.y))&quot;</span>)</span></span><br><span class="hljs-comment">// 打印“square.origin is now at (10.0, 10.0)”</span><br><br><span class="hljs-comment">// 属性包装器</span><br>@propertyWrapper<br>struct TwelveOrLess &#123;<br>    private <span class="hljs-selector-tag">var</span> number = <span class="hljs-number">0</span><br>    <span class="hljs-selector-tag">var</span> wrappedValue: Int &#123;<br>        get &#123; return number &#125;<br>        set &#123; number = <span class="hljs-built_in">min</span>(newValue, <span class="hljs-number">12</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>实例方法（Instance Methods），类型方法（static）</p><p>方法是与某些特定类型相关联的函数。<br>类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。<br>类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">var</span> count <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">increment</span>() &#123;<br>        count <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">by</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Int</span>) &#123;<br>        count <span class="hljs-operator">+=</span> amount<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">reset</span>() &#123;<br>        count <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>下标可以定义在类、结构体和枚举中，是访问集合、列表或序列中元素的快捷方式</p><p>下标语法（subscript），下标用法，下标选项，类型下标（static）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">subscript</span>(<span class="hljs-params">index</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">get</span> &#123;<br>      <span class="hljs-comment">// 返回一个适当的 Int 类型的值</span><br>    &#125;<br>    <span class="hljs-keyword">set</span>(newValue) &#123;<br>      <span class="hljs-comment">// 执行适当的赋值操作</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 示例</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TimesTable</span> &#123;<br>    <span class="hljs-keyword">let</span> multiplier: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">index</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> multiplier <span class="hljs-operator">*</span> index<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> threeTimesTable <span class="hljs-operator">=</span> <span class="hljs-type">TimesTable</span>(multiplier: <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;six times three is <span class="hljs-subst">\(threeTimesTable[<span class="hljs-number">6</span>])</span>&quot;</span>)<br><span class="hljs-comment">// 打印“six times three is 18”</span><br><br><span class="hljs-keyword">var</span> numberOfLegs <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;spider&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&quot;ant&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&quot;cat&quot;</span>: <span class="hljs-number">4</span>]<br>numberOfLegs[<span class="hljs-string">&quot;bird&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><br><span class="hljs-comment">// 类型下标</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Planet</span>: <span class="hljs-title class_">Int</span> &#123;<br>    <span class="hljs-keyword">case</span> mercury <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-params">n</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Planet</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Planet</span>(rawValue: n)<span class="hljs-operator">!</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> mars <span class="hljs-operator">=</span> <span class="hljs-type">Planet</span>[<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(mars)<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>定义一个基类，子类生成，重写(override)，防止重写(final)<br>不继承于其它类的类，称之为基类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>: <span class="hljs-type">SomeSuperclass</span> &#123;<br>    <span class="hljs-comment">// 这里是子类的定义</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">var</span> currentSpeed = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">var</span> description: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;traveling at \(currentSpeed) miles per hour&quot;</span><br>    &#125;<br>    func makeNoise() &#123;<br>        <span class="hljs-comment">// 什么也不做——因为车辆不一定会有噪音</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>: <span class="hljs-type">Vehicle</span> &#123;<br>    <span class="hljs-keyword">var</span> gear = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> description: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.description + <span class="hljs-string">&quot; in gear \(gear)&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutomaticCar</span>: <span class="hljs-type">Car</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> currentSpeed: <span class="hljs-built_in">Double</span> &#123;<br>        didSet &#123;<br>            gear = <span class="hljs-built_in">Int</span>(currentSpeed / <span class="hljs-number">10.0</span>) + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h3><p>构造过程是使用类、结构体或枚举类型的实例之前的准备过程。<br>存储属性的初始赋值，自定义构造过程，默认构造器，值类型的构造器代理，类的继承和构造过程，可失败构造器，必要构造器（required）</p><p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能避免多个构造器间的代码重复。<br>Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们被称为指定构造器和便利构造器。<br>可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 init 关键字后面添加问号（init?）。<br>必要构造器，在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 构造过程</span><br><span class="hljs-keyword">init</span>() &#123;<br>    <span class="hljs-comment">// 在此处执行构造过程</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fahrenheit</span> &#123;<br>    <span class="hljs-keyword">var</span> temperature: <span class="hljs-type">Double</span><br>    <span class="hljs-keyword">init</span>() &#123;<br>        temperature <span class="hljs-operator">=</span> <span class="hljs-number">32.0</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> f <span class="hljs-operator">=</span> <span class="hljs-type">Fahrenheit</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The default temperature is <span class="hljs-subst">\(f.temperature)</span>° Fahrenheit&quot;</span>)<br><span class="hljs-comment">// 打印“The default temperature is 32.0° Fahrenheit”</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span> &#123;<br>    <span class="hljs-keyword">let</span> red, green, blue: <span class="hljs-type">Double</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">red</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">green</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">blue</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.red   <span class="hljs-operator">=</span> red<br>        <span class="hljs-keyword">self</span>.green <span class="hljs-operator">=</span> green<br>        <span class="hljs-keyword">self</span>.blue  <span class="hljs-operator">=</span> blue<br>    &#125;<br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">white</span>: <span class="hljs-type">Double</span>) &#123;<br>        red   <span class="hljs-operator">=</span> white<br>        green <span class="hljs-operator">=</span> white<br>        blue  <span class="hljs-operator">=</span> white<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h3><p>析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字 deinit 来标示，类似于构造器要用 init 来标示。<br>Swift 会自动释放不再需要的实例以释放资源。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 析构过程</span><br><span class="hljs-keyword">deinit</span> &#123;<br>    <span class="hljs-comment">// 执行析构过程</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> coinsInBank <span class="hljs-operator">=</span> <span class="hljs-number">10_000</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">distribute</span>(<span class="hljs-params">coins</span> <span class="hljs-params">numberOfCoinsRequested</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">let</span> numberOfCoinsToVend <span class="hljs-operator">=</span> <span class="hljs-built_in">min</span>(numberOfCoinsRequested, coinsInBank)<br>        coinsInBank <span class="hljs-operator">-=</span> numberOfCoinsToVend<br>        <span class="hljs-keyword">return</span> numberOfCoinsToVend<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">receive</span>(<span class="hljs-params">coins</span>: <span class="hljs-type">Int</span>) &#123;<br>        coinsInBank <span class="hljs-operator">+=</span> coins<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-keyword">var</span> coinsInPurse: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">coins</span>: <span class="hljs-type">Int</span>) &#123;<br>        coinsInPurse <span class="hljs-operator">=</span> <span class="hljs-type">Bank</span>.distribute(coins: coins)<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">win</span>(<span class="hljs-params">coins</span>: <span class="hljs-type">Int</span>) &#123;<br>        coinsInPurse <span class="hljs-operator">+=</span> <span class="hljs-type">Bank</span>.distribute(coins: coins)<br>    &#125;<br>    <span class="hljs-keyword">deinit</span> &#123;<br>        <span class="hljs-type">Bank</span>.receive(coins: coinsInPurse)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可选链式调用"><a href="#可选链式调用" class="headerlink" title="可选链式调用"></a>可选链式调用</h3><p>可选链式调用是一种可以在当前值可能为 nil 的可选值上请求和调用属性、方法及下标的方法。<br>通过在想调用的属性、方法，或下标的可选值后面放一个问号（?），可以定义一个可选链。类似在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> residence: <span class="hljs-type">Residence</span>?<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Residence</span> &#123;<br>    <span class="hljs-keyword">var</span> numberOfRooms <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">let</span> john <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br><span class="hljs-keyword">let</span> roomCount <span class="hljs-operator">=</span> john.residence<span class="hljs-operator">!</span>.numberOfRooms<br><span class="hljs-comment">// 这会引发运行时错误</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> roomCount <span class="hljs-operator">=</span> john.residence<span class="hljs-operator">?</span>.numberOfRooms &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;John&#x27;s residence has <span class="hljs-subst">\(roomCount)</span> room(s).&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Unable to retrieve the number of rooms.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 打印“Unable to retrieve the number of rooms.”</span><br><br>john.residence <span class="hljs-operator">=</span> <span class="hljs-type">Residence</span>()<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> roomCount <span class="hljs-operator">=</span> john.residence<span class="hljs-operator">?</span>.numberOfRooms &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;John&#x27;s residence has <span class="hljs-subst">\(roomCount)</span> room(s).&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Unable to retrieve the number of rooms.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 打印“John&#x27;s residence has 1 room(s).”</span><br></code></pre></td></tr></table></figure><h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理（Error handling） 是响应错误以及从错误中恢复的过程。Swift 在运行时提供了抛出、捕获、传递和操作可恢复错误（recoverable errors）的一等支持。</p><p>表示与抛出错误，处理错误，指定清理操作</p><p>在 Swift 中，错误用遵循 Error 协议的类型的值来表示。<br>Swift 中有 4 种处理错误的方式。可以把函数抛出的错误传递给调用此函数的代码（throws）、用 do-catch 语句处理错误、将错误作为可选类型处理（try?）、或者断言此错误根本不会发生（try!）。<br>defer 语句将代码的执行延迟到当前的作用域退出之前。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 错误处理</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">VendingMachineError</span>: <span class="hljs-title class_">Error</span> &#123;<br>    <span class="hljs-keyword">case</span> invalidSelection                     <span class="hljs-comment">//选择无效</span><br>    <span class="hljs-keyword">case</span> insufficientFunds(coinsNeeded: <span class="hljs-type">Int</span>) <span class="hljs-comment">//金额不足</span><br>    <span class="hljs-keyword">case</span> outOfStock                             <span class="hljs-comment">//缺货</span><br>&#125;<br><span class="hljs-keyword">throw</span> <span class="hljs-type">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">var</span> vendingMachine <span class="hljs-operator">=</span> <span class="hljs-type">VendingMachine</span>()<br>vendingMachine.coinsDeposited <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">try</span> buyFavoriteSnack(person: <span class="hljs-string">&quot;Alice&quot;</span>, vendingMachine: vendingMachine)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Success! Yum.&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span> <span class="hljs-type">VendingMachineError</span>.invalidSelection &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid Selection.&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span> <span class="hljs-type">VendingMachineError</span>.outOfStock &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Out of Stock.&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span> <span class="hljs-type">VendingMachineError</span>.insufficientFunds(<span class="hljs-keyword">let</span> coinsNeeded) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Insufficient funds. Please insert an additional <span class="hljs-subst">\(coinsNeeded)</span> coins.&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Unexpected error: <span class="hljs-subst">\(error)</span>.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 打印“Insufficient funds. Please insert an additional 2 coins.”</span><br><br><span class="hljs-comment">// 指定清理操作</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">processFile</span>(<span class="hljs-params">filename</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">throws</span> &#123;<br>    <span class="hljs-keyword">if</span> exists(filename) &#123;<br>        <span class="hljs-keyword">let</span> file <span class="hljs-operator">=</span> <span class="hljs-keyword">open</span>(filename)<br>        <span class="hljs-keyword">defer</span> &#123;<br>            close(file)<br>        &#125;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> line <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> file.readline() &#123;<br>            <span class="hljs-comment">// 处理文件。</span><br>        &#125;<br>        <span class="hljs-comment">// close(file) 会在这里被调用，即作用域的最后。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型转换在 Swift 中使用 is 和 as 操作符实现。这两个操作符分别提供了一种简单达意的方式去检查值的类型或者转换它的类型。</p><p>为类型转换定义类层次，检查类型（is），向下转型（as? 或 as!），Any 和 AnyObject 的类型转换<br>可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。<br>Swift 为不确定类型提供了两种特殊的类型别名：<br>Any 可以表示任何类型，包括函数类型。<br>AnyObject 可以表示任何类类型的实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 类型转换</span><br><span class="hljs-comment">// 一个基类 MediaItem</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MediaItem</span> &#123;<br> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br> <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>  <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Movie</span>: <span class="hljs-title class_">MediaItem</span> &#123;<br> <span class="hljs-keyword">var</span> director: <span class="hljs-type">String</span><br> <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">director</span>: <span class="hljs-type">String</span>) &#123;<br>  <span class="hljs-keyword">self</span>.director <span class="hljs-operator">=</span> director<br>  <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(name: name)<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Song</span>: <span class="hljs-title class_">MediaItem</span> &#123;<br> <span class="hljs-keyword">var</span> artist: <span class="hljs-type">String</span><br> <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">artist</span>: <span class="hljs-type">String</span>) &#123;<br>  <span class="hljs-keyword">self</span>.srtist <span class="hljs-operator">=</span> artist<br>  <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(name: name)<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> library <span class="hljs-operator">=</span> [<br> <span class="hljs-type">Movie</span>(name: <span class="hljs-string">&quot;Casablanca&quot;</span>, director: <span class="hljs-string">&quot;Micheal Curtiz&quot;</span>),<br> <span class="hljs-type">Song</span>(name: <span class="hljs-string">&quot;Blue Suede Shose&quot;</span>, artist: <span class="hljs-string">&quot;Elvis Presley&quot;</span>),<br> <span class="hljs-type">Movie</span>(name: <span class="hljs-string">&quot;Citizen Kane&quot;</span>, director: <span class="hljs-string">&quot;Orson Wells&quot;</span>),<br> <span class="hljs-type">Song</span>(name: <span class="hljs-string">&quot;The One And Only&quot;</span>, artist: <span class="hljs-string">&quot;Chesney Hawkes&quot;</span>),<br> <span class="hljs-type">Song</span>(name: <span class="hljs-string">&quot;Never Gonna Give You Up&quot;</span>, artist: <span class="hljs-string">&quot;Rick Astley&quot;</span>)<br>]<br><span class="hljs-keyword">var</span> movieCount <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> songCount <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> library &#123;<br> <span class="hljs-keyword">if</span> item <span class="hljs-keyword">is</span> <span class="hljs-type">Movie</span> &#123;<br>  movieCount <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> item <span class="hljs-keyword">is</span> <span class="hljs-type">Song</span> &#123;<br>  songCount <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br> &#125;<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Media library contains <span class="hljs-subst">\(movieCount)</span> movies and <span class="hljs-subst">\(songCount)</span>&quot;</span>)<br><span class="hljs-comment">// 打印“Media library contains 2 movies and 3 songs”</span><br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> library &#123;<br> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> movie <span class="hljs-operator">=</span> item <span class="hljs-keyword">as?</span> <span class="hljs-type">Movie</span> &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Movie: <span class="hljs-subst">\(movie.name)</span>, dir. <span class="hljs-subst">\(movie.director)</span>&quot;</span>)<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> song <span class="hljs-operator">=</span> item <span class="hljs-keyword">as?</span> <span class="hljs-type">Song</span> &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Song: <span class="hljs-subst">\(song.name)</span>, by <span class="hljs-subst">\(song.artist)</span>&quot;</span>)<br> &#125;<br>&#125;<br><span class="hljs-comment">// Movie: Casablanca, dir. Michael Curtiz</span><br><span class="hljs-comment">// Song: Blue Suede Shoes, by Elvis Presley</span><br><span class="hljs-comment">// Movie: Citizen Kane, dir. Orson Welles</span><br><span class="hljs-comment">// Song: The One And Only, by Chesney Hawkes</span><br><span class="hljs-comment">// Song: Never Gonna Give You Up, by Rick Astley</span><br></code></pre></td></tr></table></figure><h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>Swift 允许定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。</p><p>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的 {} 内，而且可以根据需要定义多级嵌套。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 嵌套类型</span><br>stuct <span class="hljs-type">BlackjackCard</span> &#123;<br> <span class="hljs-comment">// 嵌套的 Suit 枚举</span><br> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Suit</span>: <span class="hljs-title class_">Character</span> &#123;<br>  <span class="hljs-keyword">case</span> spades <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>, hearts <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2&quot;</span>, diamonds <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3&quot;</span>, clubs <span class="hljs-operator">=</span> <span class="hljs-string">&quot;4&quot;</span><br> &#125;<br> <br> <span class="hljs-comment">// 嵌套的 Rank 枚举</span><br> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Rank</span>: <span class="hljs-title class_">Int</span> &#123;<br>  <span class="hljs-keyword">case</span> two <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, three, four, five, six, seven, eight, nine, ten<br>  <span class="hljs-keyword">case</span> jack, queen, king, ace<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Values</span> &#123;<br>   <span class="hljs-keyword">let</span> first: <span class="hljs-type">Int</span>, second: <span class="hljs-type">Int</span>?<br>  &#125;<br>  <span class="hljs-keyword">var</span> values: <span class="hljs-type">Values</span> &#123;<br>   <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> &#123;<br>   <span class="hljs-keyword">case</span> .ace:<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Values</span>(first: <span class="hljs-number">1</span>, second: <span class="hljs-number">11</span>)<br>   <span class="hljs-keyword">case</span> .jack, .queen, .king:<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Values</span>(first: <span class="hljs-number">10</span>, second: <span class="hljs-literal">nil</span>)<br>   <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Values</span>(first: <span class="hljs-keyword">self</span>.rawValue, second: <span class="hljs-literal">nil</span>)<br>   &#125;<br>  &#125;<br> &#125;<br> <br> <span class="hljs-comment">// BlackjackCard 的属性和方法</span><br> <span class="hljs-keyword">let</span> rank: <span class="hljs-type">Rank</span>, suit: <span class="hljs-type">Suit</span><br> <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;<br>  <span class="hljs-keyword">var</span> output <span class="hljs-operator">=</span> <span class="hljs-string">&quot;suit is <span class="hljs-subst">\(suit.rawValue)</span>,&quot;</span><br>  output <span class="hljs-operator">+=</span> <span class="hljs-string">&quot; value is <span class="hljs-subst">\(rank.values.first)</span>&quot;</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> second <span class="hljs-operator">=</span> rank.values.second &#123;<br>   output <span class="hljs-operator">+=</span> <span class="hljs-string">&quot; or <span class="hljs-subst">\(second)</span>&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> output<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> theAceOfSpades <span class="hljs-operator">=</span> <span class="hljs-type">BlackjackCard</span>(rank: .ace, suit: .spades)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;theAceOfSpades: <span class="hljs-subst">\(theAceOfSpades.description)</span>&quot;</span>)<br><span class="hljs-comment">// 打印“theAceOfSpades: suit is 1, value is 1 or 11”</span><br><br><span class="hljs-keyword">let</span> heartsSymbol <span class="hljs-operator">=</span> <span class="hljs-type">BlackjackCard</span>.<span class="hljs-type">Suit</span>.hearts.rawValue<br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>扩展可以给一个现有的类，结构体，枚举，还有协议添加新的功能。<br>扩展的语法，计算型属性，构造器，方法，下标，嵌套类型</p><p>Swift 中的扩展可以：<br>添加计算型实例属性和计算型类属性<br>定义实例方法和类方法<br>提供新的构造器<br>定义下标<br>定义和使用新的嵌套类型<br>使已经存在的类型遵循（conform）一个协议</p><p>扩展可以给现有类型添加计算型实例属性和计算型类属性。<br>扩展可以给现有的类型添加新的构造器。<br>扩展可以给现有类型添加新的实例方法和类方法。<br>扩展可以给现有的类型添加新的下标。<br>扩展可以给现有的类，结构体，还有枚举添加新的嵌套类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 扩展的语法</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SomeType</span> &#123;<br>  <span class="hljs-comment">// 在这里给 SomeType 添加新的功能</span><br>&#125;<br><span class="hljs-comment">// 添加一个或多个协议</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SomeType</span>: <span class="hljs-title class_">SomeProtocol</span>, <span class="hljs-title class_">AnotherProtocol</span> &#123;<br>  <span class="hljs-comment">// 协议所需要的实现写在这里</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Size</span> &#123;<br> <span class="hljs-keyword">var</span> width <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>, height <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span><br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br> <span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>, y <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span><br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rect</span> &#123;<br> <span class="hljs-keyword">var</span> origin <span class="hljs-operator">=</span> <span class="hljs-type">Point</span>()<br> <span class="hljs-keyword">var</span> size <span class="hljs-operator">=</span> <span class="hljs-type">Size</span>()<br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Rect</span> &#123;<br> <span class="hljs-keyword">init</span>(<span class="hljs-params">center</span>: <span class="hljs-type">Point</span>, <span class="hljs-params">size</span>: <span class="hljs-type">Size</span>) &#123;<br>  <span class="hljs-keyword">let</span> originX <span class="hljs-operator">=</span> center.x <span class="hljs-operator">-</span> (size.width <span class="hljs-operator">/</span> <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">let</span> originY <span class="hljs-operator">=</span> center.y <span class="hljs-operator">-</span> (size.height <span class="hljs-operator">/</span> <span class="hljs-number">3</span>)<br>  <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(origin: <span class="hljs-type">Point</span>(x: originX, y: originY), size: size)<br> &#125;<br>&#125;<br><span class="hljs-keyword">let</span> centerRect <span class="hljs-operator">=</span> <span class="hljs-type">Rect</span>(center: <span class="hljs-type">Point</span>(x: <span class="hljs-number">4.0</span>, y: <span class="hljs-number">4.0</span>), <br> size: <span class="hljs-type">Size</span>(width: <span class="hljs-number">3.0</span>, height: <span class="hljs-number">3.0</span>))<br><span class="hljs-comment">// centerRect 的 origin 是 (2.5, 2.5) 并且它的 size 是 (3.0, 3.0)</span><br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span> &#123;<br> <span class="hljs-keyword">func</span> <span class="hljs-title function_">repetitions</span>(<span class="hljs-params">task</span>: () -&gt; <span class="hljs-type">Void</span>) &#123;<br>  <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-keyword">self</span> &#123;<br>   task()<br>  &#125;<br> &#125;<br>&#125;<br><span class="hljs-number">3</span>.repetitions &#123;<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Hello!</span><br><span class="hljs-comment">// Hello!</span><br><span class="hljs-comment">// Hello!</span><br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span> &#123;<br> <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">square</span>() &#123;<br>  <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">self</span><br> &#125;<br>&#125;<br><span class="hljs-keyword">var</span> somtInt <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>someInt.square()<br><span class="hljs-comment">// someInt 现在是9</span><br></code></pre></td></tr></table></figure><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。<br>类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现</p><p>协议语法，属性要求，方法要求，异变方法要求，构造器要求，协议作为类型，委托，协议类型的集合，协议的继承，类专属的协议，协议合成，检查协议一致性，可选的协议要求，协议扩展，</p><p>协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。<br>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。<br>在值类型（即结构体和枚举）的实例方法中，将 mutating 关键字作为方法的前缀，写在 func 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。<br>协议可以要求遵循协议的类型实现指定的构造器。<br>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 协议语法</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-comment">// 这里是协议的定义部分</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SomeStructure</span>: <span class="hljs-title class_">FirstProtocol</span>, <span class="hljs-title class_">AnotherProtocol</span> &#123;<br> <span class="hljs-comment">// 这里是结构体的定义部分</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>: <span class="hljs-title class_">SomeSuperClass</span>, <span class="hljs-title class_">FirstProtocol</span>, <span class="hljs-title class_">AnotherProtocol</span> &#123;<br> <span class="hljs-comment">// 这里是类的定义部分</span><br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br> <span class="hljs-keyword">var</span> mustBeSettable: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br> <span class="hljs-keyword">var</span> doesNotNeedToBeSettable: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AnotherProtocol</span> &#123;<br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> someTypeProperty: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">FullyNamed</span> &#123;<br> <span class="hljs-keyword">var</span> fullName: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">person</span>: <span class="hljs-title class_">FullyNamed</span> &#123;<br> <span class="hljs-keyword">var</span> fullName: <span class="hljs-type">String</span><br>&#125;<br><span class="hljs-keyword">let</span> john <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>(fullName: <span class="hljs-string">&quot;John Appleseed&quot;</span>)<br><span class="hljs-comment">// john.fullName 为 &quot;John Appleseed&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Starship</span>: <span class="hljs-title class_">FullyNamed</span> &#123;<br> <span class="hljs-keyword">var</span> <span class="hljs-keyword">prefix</span>: <span class="hljs-type">String</span>?<br> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br> <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">prefix</span>: <span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) &#123;<br>  <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>  <span class="hljs-keyword">self</span>.prefix <span class="hljs-operator">=</span> <span class="hljs-keyword">prefix</span><br> &#125;<br> <br> <span class="hljs-keyword">var</span> fullName: <span class="hljs-type">String</span> &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">prefix</span> <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">?</span> <span class="hljs-keyword">prefix</span><span class="hljs-operator">!</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-operator">+</span> name<br> &#125;<br>&#125;<br><span class="hljs-keyword">var</span> ncc1701 <span class="hljs-operator">=</span> <span class="hljs-type">Starship</span>(name: <span class="hljs-string">&quot;Enterprise&quot;</span>, prefix: <span class="hljs-string">&quot;USS&quot;</span>)<br><span class="hljs-comment">// ncc1701.fullName 为 &quot;USS Enterprise&quot;</span><br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型代码让你能根据自定义的需求，编写出适用于任意类型的、灵活可复用的函数及类型。<br>你可避免编写重复的代码，而是用一种清晰抽象的方式来表达代码的意图。<br>泛型函数，类型参数，命名类型参数，泛型类型，泛型扩展，类型约束，关联类型</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">func swapTwoInts(_ a: <span class="hljs-keyword">inout</span> Int, _ b: <span class="hljs-keyword">inout</span> Int) &#123;<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>&#125;<br><br>func swapTwoValues&lt;T&gt;(_ a: <span class="hljs-keyword">inout</span> T, _ b: <span class="hljs-keyword">inout</span> T) &#123;<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>&#125;<br><br>func swapTwoInts(_ a: <span class="hljs-keyword">inout</span> Int, _ b: <span class="hljs-keyword">inout</span> Int)<br>func swapTwoValues&lt;T&gt;(_ a: <span class="hljs-keyword">inout</span> T, _ b: <span class="hljs-keyword">inout</span> T)<br><br>var someInt = <span class="hljs-number">3</span><br>var anotherInt = <span class="hljs-number">107</span><br>swapTwoValues(&amp;someInt, &amp;anotherInt)<br><span class="hljs-comment">// someInt 现在是 107，anotherInt 现在是 3</span><br><br>var someString = <span class="hljs-string">&quot;hello&quot;</span><br>var anotherString = <span class="hljs-string">&quot;world&quot;</span><br>swapTwoValues(&amp;someString, &amp;anotherString)<br><span class="hljs-comment">// someString 现在是“world”，anotherString 现在是“hello”</span><br></code></pre></td></tr></table></figure><h3 id="不透明类型"><a href="#不透明类型" class="headerlink" title="不透明类型"></a>不透明类型</h3><p>具有不透明返回类型的函数或方法会隐藏返回值的类型信息。<br>函数不再提供具体的类型作为返回类型，而是根据它支持的协议来描述返回值。</p><p>不透明类型解决的问题，返回不透明类型，不透明类型和协议类型的区别<br>在处理模块和调用代码之间的关系时，隐藏类型信息非常有用，因为返回的底层数据类型仍然可以保持私有。<br>不透明类型和泛型相反。不透明类型允许函数实现时，选择一个与调用代码无关的返回类型。<br>如果函数中有多个地方返回了不透明类型，那么所有可能的返回值都必须是同一类型。<br>返回不透明类型和返回协议类型主要区别，就在于是否需要保证类型一致性。<br>一个不透明类型只能对应一个具体的类型，即便函数调用者并不能知道是哪一种类型；协议类型可以同时对应多个类型，只要它们都遵循同一协议。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs stylus">protocol Shape &#123;<br>    func <span class="hljs-built_in">draw</span>() -&gt; String<br>&#125;<br><br>struct Triangle: Shape &#123;<br>    <span class="hljs-selector-tag">var</span> size: Int<br>    func <span class="hljs-built_in">draw</span>() -&gt; String &#123;<br>        <span class="hljs-selector-tag">var</span> result = <span class="hljs-selector-attr">[String]</span>()<br>        <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-selector-class">.size</span> &#123;<br>            result<span class="hljs-selector-class">.append</span>(<span class="hljs-built_in">String</span>(repeating: <span class="hljs-string">&quot;*&quot;</span>, count: length))<br>        &#125;<br>        return result<span class="hljs-selector-class">.joined</span>(separator: <span class="hljs-string">&quot;\n&quot;</span>)<br>    &#125;<br>&#125;<br>let smallTriangle = <span class="hljs-built_in">Triangle</span>(size: <span class="hljs-number">3</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(smallTriangle.draw()</span></span>)<br><span class="hljs-comment">// *</span><br><span class="hljs-comment">// **</span><br><span class="hljs-comment">// ***</span><br><br>struct FlippedShape&lt;T: Shape&gt;: Shape &#123;<br>    <span class="hljs-selector-tag">var</span> shape: T<br>    func <span class="hljs-built_in">draw</span>() -&gt; String &#123;<br>        let lines = shape<span class="hljs-selector-class">.draw</span>()<span class="hljs-selector-class">.split</span>(separator: <span class="hljs-string">&quot;\n&quot;</span>)<br>        return lines<span class="hljs-selector-class">.reversed</span>()<span class="hljs-selector-class">.joined</span>(separator: <span class="hljs-string">&quot;\n&quot;</span>)<br>    &#125;<br>&#125;<br>let flippedTriangle = <span class="hljs-built_in">FlippedShape</span>(shape: smallTriangle)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(flippedTriangle.draw()</span></span>)<br><span class="hljs-comment">// ***</span><br><span class="hljs-comment">// **</span><br><span class="hljs-comment">// *</span><br></code></pre></td></tr></table></figure><h3 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h3><p>Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。<br>如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。<br>Swift提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。<br>声明属性或者变量时，在前面加上 weak 关键字表明这是一个弱引用<br>声明属性或者变量时，在前面加上关键字 unowned 表示这是一个无主引用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 自动引用计数实践</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(name)</span> is being initialized&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">deinit</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(name)</span> is being deinitialized&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> reference1: <span class="hljs-type">Person</span>?<br><span class="hljs-keyword">var</span> reference2: <span class="hljs-type">Person</span>?<br><span class="hljs-keyword">var</span> reference3: <span class="hljs-type">Person</span>?<br>reference1 <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>(name: <span class="hljs-string">&quot;John Appleseed&quot;</span>)<br><span class="hljs-comment">// 打印“John Appleseed is being initialized”</span><br>reference2 <span class="hljs-operator">=</span> reference1<br>reference3 <span class="hljs-operator">=</span> reference1<br>reference1 <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>reference2 <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>reference3 <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><span class="hljs-comment">// 打印“John Appleseed is being deinitialized”</span><br><br><span class="hljs-comment">// 循环强引用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123; <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name &#125;<br>    <span class="hljs-keyword">var</span> apartment: <span class="hljs-type">Apartment</span>?<br>    <span class="hljs-keyword">deinit</span> &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(name)</span> is being deinitialized&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apartment</span> &#123;<br>    <span class="hljs-keyword">let</span> unit: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">unit</span>: <span class="hljs-type">String</span>) &#123; <span class="hljs-keyword">self</span>.unit <span class="hljs-operator">=</span> unit &#125;<br>    <span class="hljs-keyword">var</span> tenant: <span class="hljs-type">Person</span>?<br>    <span class="hljs-keyword">deinit</span> &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Apartment <span class="hljs-subst">\(unit)</span> is being deinitialized&quot;</span>) &#125;<br>&#125;<br><span class="hljs-keyword">var</span> john: <span class="hljs-type">Person</span>?<br><span class="hljs-keyword">var</span> unit4A: <span class="hljs-type">Apartment</span>?<br>john <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>(name: <span class="hljs-string">&quot;John Appleseed&quot;</span>)<br>unit4A <span class="hljs-operator">=</span> <span class="hljs-type">Apartment</span>(unit: <span class="hljs-string">&quot;4A&quot;</span>)<br><br>john <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>unit4A <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><br><span class="hljs-comment">// 弱引用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123; <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name &#125;<br>    <span class="hljs-keyword">var</span> apartment: <span class="hljs-type">Apartment</span>?<br>    <span class="hljs-keyword">deinit</span> &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(name)</span> is being deinitialized&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apartment</span> &#123;<br>    <span class="hljs-keyword">let</span> unit: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">unit</span>: <span class="hljs-type">String</span>) &#123; <span class="hljs-keyword">self</span>.unit <span class="hljs-operator">=</span> unit &#125;<br>    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> tenant: <span class="hljs-type">Person</span>?<br>    <span class="hljs-keyword">deinit</span> &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Apartment <span class="hljs-subst">\(unit)</span> is being deinitialized&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> john: <span class="hljs-type">Person</span>?<br><span class="hljs-keyword">var</span> unit4A: <span class="hljs-type">Apartment</span>?<br><br>john <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>(name: <span class="hljs-string">&quot;John Appleseed&quot;</span>)<br>unit4A <span class="hljs-operator">=</span> <span class="hljs-type">Apartment</span>(unit: <span class="hljs-string">&quot;4A&quot;</span>)<br><br>john<span class="hljs-operator">!</span>.apartment <span class="hljs-operator">=</span> unit4A<br>unit4A<span class="hljs-operator">!</span>.tenant <span class="hljs-operator">=</span> john<br><br>john <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><span class="hljs-comment">// 打印“John Appleseed is being deinitialized”</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github下搭建Hexo博客</title>
    <link href="/2022/10/28/create_github_hexo/"/>
    <url>/2022/10/28/create_github_hexo/</url>
    
    <content type="html"><![CDATA[<!-- Github下搭建Hexo博客 --><span id="more"></span><p>GitHub Pages + Hexo搭建个人博客网站</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>GitHub账号</li><li>安装Git</li><li>安装NodeJS</li><li>创建仓库，格式必须为&lt;用户名&gt;.github.io</li></ul><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>-g hexo-cli<br><br>hexo -v<br><br>hexo init hexo-<span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span><br>cd hexo-<span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span><br>npm <span class="hljs-keyword">install</span><br><span class="hljs-keyword"></span><br>hexo g<br><br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">https://github.com/fluid-dev/hexo-theme-fluid/releases</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd hexo-blog<br><br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/iissnan/</span>hexo-theme-<span class="hljs-keyword">next</span> themes/<span class="hljs-keyword">next</span><br><br><span class="hljs-regexp">//</span> 打开 _config.yml 文件 将主题修改为 <span class="hljs-keyword">next</span><br>theme: <span class="hljs-keyword">next</span><br></code></pre></td></tr></table></figure><h3 id="发布到GitHub-Pages"><a href="#发布到GitHub-Pages" class="headerlink" title="发布到GitHub Pages"></a>发布到GitHub Pages</h3><p>安装hexo-deployer-git</p><p><code>npm install hexo-deployer-git --save</code></p><p>修改根目录下的 _config.yml，配置 GitHub 相关信息</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:xxx/xxx.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>部署到GitHub</p><p><code>hexo g -d</code></p><h3 id="部署到nginx"><a href="#部署到nginx" class="headerlink" title="部署到nginx"></a>部署到nginx</h3><ul><li>hexo g 生成静态文件</li><li>上传到nginx服务器</li><li>配置nginx访问地址</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  <span class="hljs-number">127.0.0.1</span>;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>  /data/www/blog;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos安装Docker</title>
    <link href="/2022/10/28/linux_install_docker/"/>
    <url>/2022/10/28/linux_install_docker/</url>
    
    <content type="html"><![CDATA[<!-- Linux安装Docker --><span id="more"></span><p>Linux安装Docker</p><h3 id="卸载旧版本（如果之前安装过的话）"><a href="#卸载旧版本（如果之前安装过的话）" class="headerlink" title="卸载旧版本（如果之前安装过的话）"></a>卸载旧版本（如果之前安装过的话）</h3><p><code>yum remove docker  docker-common docker-selinux docker-engine</code></p><h3 id="安卓所需依赖"><a href="#安卓所需依赖" class="headerlink" title="安卓所需依赖"></a>安卓所需依赖</h3><p><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p><h3 id="设置-yum-源"><a href="#设置-yum-源" class="headerlink" title="设置 yum 源"></a>设置 yum 源</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">yum-config-manager --<span class="hljs-built_in">add</span>-repo http://download.docker.<span class="hljs-keyword">com</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo（中央仓库）<br><br>yum-config-manager --<span class="hljs-built_in">add</span>-repo http://mirrors.aliyun.<span class="hljs-keyword">com</span>/docker-<span class="hljs-keyword">ce</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo（阿里仓库）<br></code></pre></td></tr></table></figure><h3 id="选择docker版本并安装"><a href="#选择docker版本并安装" class="headerlink" title="选择docker版本并安装"></a>选择docker版本并安装</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">yum <span class="hljs-keyword">list</span> docker-<span class="hljs-keyword">ce</span> --showduplicates | <span class="hljs-keyword">sort</span> -r<br><br>yum -<span class="hljs-keyword">y</span> install docker-<span class="hljs-keyword">ce</span>-<span class="hljs-number">18.03</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">ce</span><br></code></pre></td></tr></table></figure><h3 id="设置启动"><a href="#设置启动" class="headerlink" title="设置启动"></a>设置启动</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start docker<br><br><span class="hljs-params">system</span>ctl enable docker<br></code></pre></td></tr></table></figure><h3 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h3><p>仓库 <a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p><p>下载完成后，使用chmod修改docker-compose文件可执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose<br><br>sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br>docker-compose --version<br></code></pre></td></tr></table></figure><p>要卸载Docker-compose，只需要删除可docker-compose二进制文件即可。命令sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose将会删除docker-compose</p><h3 id="Docker-换源"><a href="#Docker-换源" class="headerlink" title="Docker 换源"></a>Docker 换源</h3><p>在&#x2F;etc&#x2F;docker文件夹下 修改daemon.json ,如果不存在这样的文件 新建一个即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/docker<br> <br>vim daemon.json<br><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://ghcr.io&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>重启docker</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下免密远程开发</title>
    <link href="/2022/10/28/linnx_no_passwd_dev/"/>
    <url>/2022/10/28/linnx_no_passwd_dev/</url>
    
    <content type="html"><![CDATA[<!-- Linux下免密远程开发 --><span id="more"></span><p>Linux下免密远程开发</p><h3 id="生成RSA密钥对"><a href="#生成RSA密钥对" class="headerlink" title="生成RSA密钥对"></a>生成RSA密钥对</h3><p>输入ssh-keygen -t rsa -C “这里任意输入”命令</p><p>.ssh文件夹下可以查看到刚生成的RSA密钥对</p><h3 id="服务器操作"><a href="#服务器操作" class="headerlink" title="服务器操作"></a>服务器操作</h3><ul><li>把 id_rsa.pub 传入到服务器</li><li>执行cat ~&#x2F;id_rsa.pub &gt;&gt; .&#x2F;.ssh&#x2F;authorized_keys命令</li><li>将公钥文件信息写入authorized_keys文件</li><li>重启 sshd 服务</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下使用Clash方法</title>
    <link href="/2022/10/28/linux_use_clash/"/>
    <url>/2022/10/28/linux_use_clash/</url>
    
    <content type="html"><![CDATA[<!-- Linux下使用Clash方法 --><span id="more"></span><p>Linux使用Clash For Linux网络代理工具</p><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><ul><li><p>客户端 可执行程序 <strong>clash</strong><br>项目下载地址:<a href="https://github.com/Dreamacro/clash/releases">https://github.com/Dreamacro/clash/releases</a></p></li><li><p>配置文件:~&#x2F;.config&#x2F;clash&#x2F;config.yaml或者在您当前clash目录下的 config.yaml<br>里面放着clash的借口,控制参数，链接信息等</p></li><li><p>ip数据库~&#x2F;.config&#x2F;clash&#x2F;Country.mmdb 启动程序后会自动下载,或者在您当前clash目录下</p></li></ul><h3 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a>下载客户端</h3><p>下载适合的 Clash 二进制文件并解压重命名为 clash</p><h3 id="下载配置文件config-yaml"><a href="#下载配置文件config-yaml" class="headerlink" title="下载配置文件config.yaml"></a>下载配置文件config.yaml</h3><p>在终端 cd 到 Clash 二进制文件所在的目录，执行 wget -O config.yaml 配置文件的url 下载 Clash 配置文件,订阅地址需要转链接</p><p><code>wget -O config.yaml http://xxxxxx</code> </p><p>可使用win先下载好配置文件后拷贝</p><h3 id="初始化程序"><a href="#初始化程序" class="headerlink" title="初始化程序"></a>初始化程序</h3><p>执行 .&#x2F;clash -d . 即可启动 Clash，同时会自动下载Country.mmdb文件<br>如果是执行.&#x2F;clash则会到~&#x2F;.config&#x2F;clash下读取config.yaml和Country.mmdb文件</p><h3 id="临时启动-HTTP-代理和-Socks5-代理"><a href="#临时启动-HTTP-代理和-Socks5-代理" class="headerlink" title="临时启动 HTTP 代理和 Socks5 代理"></a>临时启动 HTTP 代理和 Socks5 代理</h3><p>手动执行export http_proxy&#x3D;<a href="http://127.0.0.1:7890和export">http://127.0.0.1:7890和export</a> https_proxy&#x3D;<a href="http://127.0.0.1:7891临时启动">http://127.0.0.1:7891临时启动</a> HTTP 代理和 Socks5 代理</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Clash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装Nodejs</title>
    <link href="/2022/10/28/linux_install_nodejs/"/>
    <url>/2022/10/28/linux_install_nodejs/</url>
    
    <content type="html"><![CDATA[<!-- Linux安装Nodejs --><span id="more"></span><h3 id="NodeSource-安装Node-js"><a href="#NodeSource-安装Node-js" class="headerlink" title="NodeSource 安装Node.js"></a>NodeSource 安装Node.js</h3><p><a href="https://github.com/nodesource/distributions">https://github.com/nodesource/distributions</a> </p><p>目前centos7 支持 node16</p><p>安装后 包括了 nodejs 与 npm</p><h3 id="npm-换源"><a href="#npm-换源" class="headerlink" title="npm 换源"></a>npm 换源</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino">临时使用<br>npm --registry  https:<span class="hljs-comment">//registry.npm.taobao.org install express</span><br><br>持久使用<br>npm config set registry  https:<span class="hljs-comment">//registry.npm.taobao.org</span><br><br>通过cnpm<br>npm install -g cnpm --registry= https:<span class="hljs-comment">//registry.npm.taobao.org</span><br><br>使用官方镜像<br>npm config set registry  https:<span class="hljs-comment">//registry.npmjs.org/</span><br><br>查看npm源地址<br>npm config get registry<br><br></code></pre></td></tr></table></figure><h3 id="npm-手动安装"><a href="#npm-手动安装" class="headerlink" title="npm 手动安装"></a>npm 手动安装</h3><ol><li>官网下载 进入Node最新版下载 &lt;<a href="https://nodejs.org/en/download/current/">https://nodejs.org/en/download/current/</a></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://nodejs.org/dist/v18.<span class="hljs-number">16</span>.<span class="hljs-number">0</span>/node-v18.<span class="hljs-number">16</span>.<span class="hljs-number">0</span>-linux-x64.tar.xz<br></code></pre></td></tr></table></figure><ol start="2"><li>解压</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">tar -xvf <span class="hljs-keyword">node</span><span class="hljs-title">-v18</span>.<span class="hljs-number">16.0</span>-linux-x64.tar.xz<br></code></pre></td></tr></table></figure><ol start="3"><li>配置</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># node</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">NODEROOT</span>=/usr/local/lib/node18.15<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$NODEROOT</span>/bin:$PATH<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装Golang</title>
    <link href="/2022/10/27/linux_install_golang/"/>
    <url>/2022/10/27/linux_install_golang/</url>
    
    <content type="html"><![CDATA[<!-- linux系统下安装go方法 --><span id="more"></span><p>linux系统下安装go方法</p><h3 id="各版本linux安装"><a href="#各版本linux安装" class="headerlink" title="各版本linux安装"></a>各版本linux安装</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">Install on CentOS: <br>Current <span class="hljs-keyword">version</span>: 1.11<br>rpm <span class="hljs-params">--import</span> https:<span class="hljs-string">//mirror.go-repo.io/centos/RPM-GPG-KEY-GO-REPO</span><br>curl -s https:<span class="hljs-string">//mirror.go-repo.io/centos/go-repo.repo</span> | tee <span class="hljs-string">/etc/yum.repos.d/go-repo.repo</span><br>yum install golang<br>        <br><br><br>Install on Fedora: <br>Current <span class="hljs-keyword">version</span>: 1.11<br>rpm <span class="hljs-params">--import</span> https:<span class="hljs-string">//mirror.go-repo.io/fedora/RPM-GPG-KEY-GO-REPO</span><br>curl -s https:<span class="hljs-string">//mirror.go-repo.io/fedora/go-repo.repo</span> | tee <span class="hljs-string">/etc/yum.repos.d/go-repo.repo</span><br>yum install golang<br>        <br><br><br>Example $GOPATH setup:<br>mkdir -p ~<span class="hljs-string">/go/</span>&#123;bin,pkg,src&#125;<br><span class="hljs-keyword">echo</span> &#x27;export GOPATH=<span class="hljs-string">&quot;$HOME/go&quot;</span>&#x27; &gt;&gt; ~<span class="hljs-string">/.bashrc</span><br><span class="hljs-keyword">echo</span> &#x27;export PATH=<span class="hljs-string">&quot;$PATH:$&#123;GOPATH//://bin:&#125;/bin&quot;</span>&#x27; &gt;&gt; ~<span class="hljs-string">/.bashrc</span><br>        <br><br><br>Unstable <span class="hljs-params">(Pre-release)</span> Packages<br>Current <span class="hljs-keyword">version</span>: 1.11rc2 <br><br>CentOS:<br>rpm <span class="hljs-params">--import</span> https:<span class="hljs-string">//mirror.go-repo.io/centos-unstable/RPM-GPG-KEY-GO-REPO</span><br>curl -s https:<span class="hljs-string">//mirror.go-repo.io/centos-unstable/go-repo-unstable.repo</span> | tee <span class="hljs-string">/etc/yum.repos.d/go-repo-unstable.repo</span><br>yum install golang<br>        <br><br>Fedora:<br>rpm <span class="hljs-params">--import</span> https:<span class="hljs-string">//mirror.go-repo.io/fedora-unstable/RPM-GPG-KEY-GO-REPO</span><br>curl -s https:<span class="hljs-string">//mirror.go-repo.io/fedora-unstable/go-repo-unstable.repo</span> | tee <span class="hljs-string">/etc/yum.repos.d/go-repo-unstable.repo</span><br>yum install golang<br></code></pre></td></tr></table></figure><h3 id="手动安装-配置Go环境"><a href="#手动安装-配置Go环境" class="headerlink" title="手动安装 配置Go环境"></a>手动安装 配置Go环境</h3><ol><li>访问官网 <a href="https://go.dev/dl/">https://go.dev/dl/</a></li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">wget https://<span class="hljs-keyword">dl</span>.google.<span class="hljs-keyword">com</span>/<span class="hljs-keyword">go</span>/go1.<span class="hljs-number">20.5</span>.linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><ol start="2"><li>使用命令解压下载好的软件包</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> tar -C /usr/local/lib -xzf go1.<span class="hljs-number">20</span>.<span class="hljs-number">5</span>.linux-amd64.tar.gz<br><span class="hljs-attribute">cd</span> /usr/local/lib <br><span class="hljs-attribute">mv</span> go go1.<span class="hljs-number">20</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><ol start="3"><li>配置</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOROOT</span>=/usr/local/lib/go1.20.5<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOPROXY</span>=https://goproxy.cn,direct<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOCACHE</span>=/root/go_env/go_cache<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOPATH</span>=/root/go_env/go_mod<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$GOROOT</span>/bin:$GOPATH/bin:$PATH<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux升级Git</title>
    <link href="/2022/10/27/linux_update_git/"/>
    <url>/2022/10/27/linux_update_git/</url>
    
    <content type="html"><![CDATA[<!-- Linux升级Git2.0版本 --><span id="more"></span><p>Linux升级Git2.0版本</p><p>使用 <a href="https://packages.endpointdev.com/">https://packages.endpointdev.com/</a> 升级</p><h3 id="下载秘钥"><a href="#下载秘钥" class="headerlink" title="下载秘钥"></a>下载秘钥</h3><p><code># yum install https://packages.endpointdev.com/rhel/7/os/x86_64/endpoint-repo.x86_64.rpm</code></p><h3 id="更新git"><a href="#更新git" class="headerlink" title="更新git"></a>更新git</h3><p><code>yum update</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设置静态IP</title>
    <link href="/2022/10/27/linux_change_static_ip/"/>
    <url>/2022/10/27/linux_change_static_ip/</url>
    
    <content type="html"><![CDATA[<!-- Linux设置静态IP --><span id="more"></span><p>Linux设置静态IP</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p><h3 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">BOOTPROTO</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;static&quot;</span><br><br><span class="hljs-attribute">IPADDR</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;192.168.230.101&quot;</span><br><span class="hljs-attribute">NETMASK</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;255.255.255.0&quot;</span><br><span class="hljs-attribute">GATEWAY</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;192.168.230.2&quot;</span><br><span class="hljs-attribute">DNS1</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;192.168.230.2&quot;</span><br></code></pre></td></tr></table></figure><h3 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h3><p><code>reboot</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓sdkmanager使用</title>
    <link href="/2022/10/27/adb_sdkmanager_use/"/>
    <url>/2022/10/27/adb_sdkmanager_use/</url>
    
    <content type="html"><![CDATA[<!-- 安卓sdkmanager使用 --><span id="more"></span><p>安卓sdkmanager使用工具在 Android SDK Tools（25.2.3+版本）包中提供，可以查看、安装、更新、卸载 Android SDK 的软件包。<br>sdkmanager命令在 SDK 中的位置: {Android_SDK}&#x2F;tools&#x2F;bin&#x2F;</p><h3 id="查看-已安装的包-和-有效的包"><a href="#查看-已安装的包-和-有效的包" class="headerlink" title="查看 已安装的包 和 有效的包"></a>查看 已安装的包 和 有效的包</h3><p><code>sdkmanager --list       // 列出所有 已安装的包、有效的包 和 可以更新包</code></p><h3 id="安装-软件包"><a href="#安装-软件包" class="headerlink" title="安装 软件包"></a>安装 软件包</h3><p>安装命令: <code>sdkmanager &lt;packages&gt;</code></p><p>其中packages参数为软件包的Path名称，即通过sdkmanager –list命令查看的列表中的Path名称，packages参数 必需要使用引号引起来，可同时添加多个packages参数同时安装多个包（多个包之间用空格隔开，并各自使用引号引起来）。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 安装平台工具包（adb 和 fastboot 命令的包）</span><br>sdkmanager <span class="hljs-string">&quot;platform-tools&quot;</span><br><br><span class="hljs-comment">// 同时安装多个包</span><br>sdkmanager <span class="hljs-string">&quot;platform-tools&quot;</span> <span class="hljs-string">&quot;build-tools;28.0.3&quot;</span> <span class="hljs-string">&quot;platforms;android-28&quot;</span><br></code></pre></td></tr></table></figure><h3 id="更新-已安装的包"><a href="#更新-已安装的包" class="headerlink" title="更新 已安装的包"></a>更新 已安装的包</h3><p><code>sdkmanager --update         // 更新所有已安装的软件包</code></p><h3 id="卸载-已安装的包"><a href="#卸载-已安装的包" class="headerlink" title="卸载 已安装的包"></a>卸载 已安装的包</h3><p><code>sdkmanager --uninstall &lt;packages&gt;</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 卸载单个软件包<br>sdkmanager <span class="hljs-params">--uninstall</span> <span class="hljs-string">&quot;build-tools;28.0.0&quot;</span><br><br><span class="hljs-string">//</span> 同时卸载多个包<br>sdkmanager <span class="hljs-params">--uninstall</span> <span class="hljs-string">&quot;build-tools;28.0.0&quot;</span> <span class="hljs-string">&quot;platforms;android-26&quot;</span><br></code></pre></td></tr></table></figure><h3 id="额外参数"><a href="#额外参数" class="headerlink" title="额外参数"></a>额外参数</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-params">--sdk_root=</span>&lt;path&gt;       <span class="hljs-string">//</span> 使用指定的 SDK 路径, 而不是当前 sdkmanager 命令<br>                        <span class="hljs-string">//</span> 的 tools 包所在的 SDK 路径<br><br><span class="hljs-params">--channel=</span>&lt;channel_id&gt;  <span class="hljs-string">//</span> 包含软件包的更新渠道, channel_id: 0 <span class="hljs-params">(Stable)</span>, <br>                        <span class="hljs-string">//</span> 1 <span class="hljs-params">(Beta)</span>, 2 <span class="hljs-params">(Dev)</span>, 3 <span class="hljs-params">(Canary)</span><br><br><span class="hljs-params">--include_obsolete</span>      <span class="hljs-string">//</span> 包含过时的软件包, 只对 <span class="hljs-params">--list</span> 和 <span class="hljs-params">--update</span> 命令有效<br><span class="hljs-params">--no_https</span>              <span class="hljs-string">//</span> 所有链接强制使用 HTTP, 而不是 HTTPS<br><span class="hljs-params">--verbose</span>               <span class="hljs-string">//</span> 详细输出模式, 输出 Error, Warn, Info 级别的消息<br><br><span class="hljs-params">--proxy=</span>&lt;http|socks&gt;                        <span class="hljs-string">//</span> 指定代理的 协议<br><span class="hljs-params">--proxy_host=</span>&lt;IP_address|DNS_address&gt;       <span class="hljs-string">//</span> 指定代理的 IP地址 或 DNS地址<br><span class="hljs-params">--proxy_port=</span>&lt;port_number&gt;                  <span class="hljs-string">//</span> 指定代理的 端口号<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 列出所有已安装和有效的包, 并且包含过时的包, 并且详细输出日志<br>sdkmanager <span class="hljs-params">--list</span> <span class="hljs-params">--include_obsolete</span> <span class="hljs-params">--verbose</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux健康状态观测</title>
    <link href="/2022/09/28/linux_healthy_look/"/>
    <url>/2022/09/28/linux_healthy_look/</url>
    
    <content type="html"><![CDATA[<!-- 介绍CPU、内存、I/O的一些基本知识，以及评估它们性能的命令 --><span id="more"></span><p>介绍CPU、内存、I&#x2F;O的一些基本知识，以及评估它们性能的命令</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>首先介绍计算机中最重要的计算组件：中央处理器。一般我们可以通过top命令来观测它的性能。</p><h5 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h5><p>top命令可用于观测CPU的一些运行指标。如图，进入top命令之后，按1键即可看到每核CPU的详细状况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs tap">top - 10:11:08 up<span class="hljs-number"> 53 </span>min, <span class="hljs-number"> 0 </span>users,  load average: 0.02, 0.40, 0.60<br>Tasks: <span class="hljs-number"> 22 </span>total,  <span class="hljs-number"> 1 </span>running, <span class="hljs-number"> 21 </span>sleeping,  <span class="hljs-number"> 0 </span>stopped,  <span class="hljs-number"> 0 </span>zombie<br>%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>%Cpu4  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>%Cpu5  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>%Cpu6  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>%Cpu7  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>MiB Mem :  12674.5 total,  10289.8 free,    799.1 used,   1585.6 buff/cache<br>MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  11596.8 avail Mem<br><br>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND<br><span class="hljs-number"> 1212 </span>chris    <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span><span class="hljs-number"> 796216 </span>125936 <span class="hljs-number"> 35944 </span>S   0.3   1.0   0:14.95 node<br>   <span class="hljs-number"> 1 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 908 </span>  <span class="hljs-number"> 532 </span>  <span class="hljs-number"> 468 </span>S   0.0   0.0   0:00.03 init<br>   <span class="hljs-number"> 8 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 896 </span>   <span class="hljs-number"> 88 </span>   <span class="hljs-number"> 20 </span>S   0.0   0.0   0:00.00 init<br>   <span class="hljs-number"> 9 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 896 </span>   <span class="hljs-number"> 88 </span>   <span class="hljs-number"> 20 </span>S   0.0   0.0   0:00.63 init<br>  <span class="hljs-number"> 10 </span>chris    <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 17108 </span> <span class="hljs-number"> 8972 </span> <span class="hljs-number"> 5324 </span>S   0.0   0.1   0:06.44 zsh<br> <span class="hljs-number"> 845 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 1256 </span>  <span class="hljs-number"> 380 </span>   <span class="hljs-number"> 20 </span>S   0.0   0.0   0:00.00 init<br> <span class="hljs-number"> 846 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 1256 </span>  <span class="hljs-number"> 380 </span>   <span class="hljs-number"> 20 </span>S   0.0   0.0   0:00.00 init<br> <span class="hljs-number"> 847 </span>chris    <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 2612 </span>  <span class="hljs-number"> 592 </span>  <span class="hljs-number"> 524 </span>S   0.0   0.0   0:00.00 sh<br> <span class="hljs-number"> 848 </span>chris    <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 2612 </span>  <span class="hljs-number"> 596 </span>  <span class="hljs-number"> 528 </span>S   0.0   0.0   0:00.00 sh<br> <span class="hljs-number"> 853 </span>chris    <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 2612 </span>  <span class="hljs-number"> 532 </span>  <span class="hljs-number"> 464 </span>S   0.0   0.0   0:00.00 sh<br> <span class="hljs-number"> 857 </span>chris    <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span><span class="hljs-number"> 944412 </span><span class="hljs-number"> 84200 </span><span class="hljs-number"> 35016 </span>S   0.0   0.6   0:07.16 node<br> <span class="hljs-number"> 868 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 1264 </span>  <span class="hljs-number"> 380 </span>   <span class="hljs-number"> 20 </span>S   0.0   0.0   0:00.00 init<br></code></pre></td></tr></table></figure><p>CPU的使用有多个维度的指标，以下分别说明一下：</p><ul><li><p><strong>us</strong> 用户态所占用的CPU百分比。</p></li><li><p><strong>sy</strong> 内核态所占用的CPU百分比。如果这个值过高，需要配合vmstat命令，查看是否是上下文切换是否频繁。</p></li><li><p><strong>ni</strong> 高优先级应用所占用的CPU百分比。</p></li><li><p><strong>wa</strong> 等待I&#x2F;O设备所占用的CPU百分比。如果这个值非常高，输入输出设备可能存在非常明显的瓶颈。</p></li><li><p><strong>hi</strong> 硬件中断所占用的CPU百分比。</p></li><li><p><strong>si</strong> 软中断所占用的CPU百分比。</p></li><li><p><strong>st</strong> 这个一般发生在虚拟机上，指的是虚拟CPU等待实际CPU时间的百分比。如果这个值过大，则你的宿主机压力可能过大。如果你是云主机，则你的服务商可能存在超卖。</p></li><li><p><strong>id</strong>  空闲CPU百分比。</p></li></ul><p>一般的，我们比较关注空闲CPU的百分比，它可以从整体上体现CPU的利用情况。</p><h5 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h5><p>我们还要评估CPU任务执行的排队情况，这些值就是负载(load)。top命令，显示的CPU负载，分别是最近1分钟、5分钟、15分钟的数值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">top</span> <span class="hljs-bullet">-</span> <span class="hljs-number">10</span><span class="hljs-string">:15:34</span> <span class="hljs-string">up</span> <span class="hljs-number">58</span> <span class="hljs-string">min,</span>  <span class="hljs-number">0</span> <span class="hljs-string">users,</span>  <span class="hljs-attr">load average:</span> <span class="hljs-number">0.00</span><span class="hljs-string">,</span> <span class="hljs-number">0.15</span><span class="hljs-string">,</span> <span class="hljs-number">0.44</span><br><span class="hljs-attr">Tasks:</span>  <span class="hljs-number">22</span> <span class="hljs-string">total,</span>   <span class="hljs-number">1</span> <span class="hljs-string">running,</span>  <span class="hljs-number">21</span> <span class="hljs-string">sleeping,</span>   <span class="hljs-number">0</span> <span class="hljs-string">stopped,</span>   <span class="hljs-number">0</span> <span class="hljs-string">zombie</span><br><span class="hljs-string">%Cpu(s):</span>  <span class="hljs-number">0.0</span> <span class="hljs-string">us,</span>  <span class="hljs-number">0.0</span> <span class="hljs-string">sy,</span>  <span class="hljs-number">0.0</span> <span class="hljs-string">ni,</span> <span class="hljs-number">99.9</span> <span class="hljs-string">id,</span>  <span class="hljs-number">0.0</span> <span class="hljs-string">wa,</span>  <span class="hljs-number">0.0</span> <span class="hljs-string">hi,</span>  <span class="hljs-number">0.0</span> <span class="hljs-string">si,</span>  <span class="hljs-number">0.0</span> <span class="hljs-string">st</span><br><span class="hljs-attr">MiB Mem :</span>  <span class="hljs-number">12674.5</span> <span class="hljs-string">total,</span>  <span class="hljs-number">10282.0</span> <span class="hljs-string">free,</span>    <span class="hljs-number">802.3</span> <span class="hljs-string">used,</span>   <span class="hljs-number">1590.2 </span><span class="hljs-string">buff/cache</span><br><span class="hljs-attr">MiB Swap:</span>   <span class="hljs-number">4096.0 </span><span class="hljs-string">total,</span>   <span class="hljs-number">4096.0 </span><span class="hljs-string">free,</span>      <span class="hljs-number">0.0</span> <span class="hljs-string">used.</span>  <span class="hljs-number">11593.6</span> <span class="hljs-string">avail</span> <span class="hljs-string">Mem</span><br></code></pre></td></tr></table></figure><p>以单核操作系统为例，将CPU资源抽象成一条单向行驶的马路。则会发生三种情况：</p><ul><li><p>马路上的车只有4辆，车辆畅通无阻，load大约是0.5。</p></li><li><p>马路上的车有8辆，正好能首尾相接安全通过，此时load大约为1。</p></li><li><p>马路上的车有12辆，除了在马路上的8辆车，还有4辆等在马路外面，需要排队。此时load大约为1.5。</p></li></ul><p>那load为1代表的是啥？针对这个问题，误解还是比较多的。</p><p>很多同学认为，load达到1，系统就到了瓶颈，这不完全正确。load的值和cpu核数息息相关。举例如下：</p><ul><li><p>单核的负载达到1，总load的值约1。</p></li><li><p>双核的每核负载都达到1，总load约2。</p></li><li><p>四核的每核负载都达到1，总load约为4。</p></li></ul><p>所以，对于一个load到了10，却是16核的机器，你的系统还远没有达到负载极限。通过uptime命令，同样能够看到负载情况。</p><h5 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h5><p>要看CPU的繁忙程度，还可以通过vmstat命令。下面是vmstat命令的一些输出信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">procs</span> -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----<br> <span class="hljs-attribute">r</span>  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st<br> <span class="hljs-attribute">1</span>  <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">10528708</span> <span class="hljs-number">125908</span> <span class="hljs-number">1502728</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">18</span>   <span class="hljs-number">227</span>   <span class="hljs-number">14</span>   <span class="hljs-number">46</span>  <span class="hljs-number">4</span>  <span class="hljs-number">0</span> <span class="hljs-number">96</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们比较关注的有下面几列：</p><ul><li><p><strong>b</strong> 存在于等待队列的内核线程数目，比如等待I&#x2F;O等。数字过大则cpu太忙。</p></li><li><p><strong>cs</strong> 代表上下文切换的数量。如果频繁的进行上下文切换，就需要考虑是否是线程数开的过多。</p></li><li><p><strong>si&#x2F;so</strong> 显示了交换分区的一些使用情况，交换分区对性能的影响比较大，需要格外关注。</p></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h5 id="top命令可以看到几列数据"><a href="#top命令可以看到几列数据" class="headerlink" title="top命令可以看到几列数据"></a>top命令可以看到几列数据</h5><ul><li><p><strong>VIRT</strong> 这里就是虚拟内存，一般比较大，不用做过多关注。</p></li><li><p><strong>RES</strong>  我们平常关注的就是这一列的数值，它代表了进程实际占用的内存。平常在做监控时，也主要是监控这个数值。</p></li><li><p><strong>SHR</strong> 指的是共享内存，比如可以复用的一些so文件等</p></li></ul><h5 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h5><p> 由于CPU核内存之间的速度差异是非常大的，解决方式就是加入高速缓存。其实，这些高速缓存，往往会有多层</p><p> ava有大部分知识点是围绕多线程的，那是因为，如果一个线程的时间片跨越了多个CPU，那么就会存在同步问题。</p><p>在Java中，最典型的和CPU缓存相关的知识点，就是并发编程中，针对Cache line的伪共享（false sharing）问题。</p><p>伪共享是指：在这些高速缓存中，是以缓存行为单位进行存储的。哪怕你修改了缓存行中一个很小很小的数据，它都会整个的刷新。所以，当多线程修改一些变量的值时，如果这些变量在同一个缓存行里，就会造成频繁刷新，无意中影响彼此的性能。</p><h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p>kafka比较快的一个原因就是使用了zero copy。所谓的Zero copy，就是在操作数据时, 不需要将数据buffer从一个内存区域拷贝到另一个内存区域。因为少了一次内存的拷贝, CPU的效率就得到提升</p><p>要想将一个文件的内容通过socket发送出去，传统的方式需要经过以下步骤：</p><ul><li><p>将文件内容拷贝到内核空间。</p></li><li><p>将内核空间的内容拷贝到用户空间内存，比如Java应用。</p></li><li><p>用户空间将内容写入到内核空间的缓存中。</p></li><li><p>socket读取内核缓存中的内容，发送出去。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下安装Protobuf</title>
    <link href="/2022/09/28/linux_install_protoc/"/>
    <url>/2022/09/28/linux_install_protoc/</url>
    
    <content type="html"><![CDATA[<!-- 在 Linux 上安装 Protobuf 3 的教程 --><span id="more"></span><p>在 Linux 上安装 Protobuf 3 的教程</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>使用bazel安装，首先需要安装bazel，<a href="https://bazel.build/">https://bazel.build/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install g++ git<br><br>git <span class="hljs-built_in">clone</span> https://github.com/protocolbuffers/protobuf.git<br><span class="hljs-built_in">cd</span> protobuf<br>git submodule update --init --recursive<br><br>bazel build :protoc :protobuf<br><br><span class="hljs-built_in">cp</span> bazel-bin/protoc /usr/local/bin<br></code></pre></td></tr></table></figure><h3 id="安装验证"><a href="#安装验证" class="headerlink" title="安装验证"></a>安装验证</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">protoc <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Protoc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2022/09/27/linux_common_order/"/>
    <url>/2022/09/27/linux_common_order/</url>
    
    <content type="html"><![CDATA[<!-- Linux常用命令整理 --><span id="more"></span><p>Linux常用命令整理</p><h3 id="查看-Linux-系统信息"><a href="#查看-Linux-系统信息" class="headerlink" title="查看 Linux 系统信息"></a>查看 Linux 系统信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">arch</span>      <span class="hljs-comment">#显示机器的处理器架构(1)</span><br><span class="hljs-built_in">uname</span> -m  <span class="hljs-comment">#显示机器的处理器架构(2)</span><br><span class="hljs-built_in">uname</span> -r  <span class="hljs-comment">#显示正在使用的内核版本</span><br>dmidecode -q          <span class="hljs-comment">#显示硬件系统部件 - (SMBIOS / DMI)</span><br><span class="hljs-built_in">cat</span> /proc/cpuinfo     <span class="hljs-comment">#显示CPU info的信息</span><br><span class="hljs-built_in">cat</span> /proc/interrupts  <span class="hljs-comment">#显示中断</span><br><span class="hljs-built_in">cat</span> /proc/meminfo     <span class="hljs-comment">#校验内存使用</span><br><span class="hljs-built_in">cat</span> /proc/swaps       <span class="hljs-comment">#显示哪些swap被使用</span><br><span class="hljs-built_in">cat</span> /proc/version     <span class="hljs-comment">#显示内核的版本</span><br><span class="hljs-built_in">cat</span> /proc/net/dev     <span class="hljs-comment">#显示网络适配器及统计</span><br><span class="hljs-built_in">cat</span> /proc/mounts      <span class="hljs-comment">#显示已加载的文件系统</span><br>lspci -tv   <span class="hljs-comment">#罗列PCI设备</span><br>lsusb -tv   <span class="hljs-comment">#显示USB设备</span><br></code></pre></td></tr></table></figure><h3 id="date-显示系统日期"><a href="#date-显示系统日期" class="headerlink" title="date 显示系统日期"></a>date 显示系统日期</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cal</span> <span class="hljs-number">2007</span>              #显示<span class="hljs-number">2007</span>年的日历表<br><span class="hljs-attribute">date</span> <span class="hljs-number">041217002007</span>.<span class="hljs-number">00</span>   #设置日期和时间 - 月日时分年.秒<br><span class="hljs-attribute">clock</span> -w              #将时间修改保存到 BIOS<br></code></pre></td></tr></table></figure><h3 id="关机（关机、重启、登出）"><a href="#关机（关机、重启、登出）" class="headerlink" title="关机（关机、重启、登出）"></a>关机（关机、重启、登出）</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">shutdown</span> -h now    <span class="hljs-meta">#关闭系统(1)</span><br>init <span class="hljs-number">0</span>            <span class="hljs-meta">#关闭系统(2)</span><br>telinit <span class="hljs-number">0</span>         <span class="hljs-meta">#关闭系统(3)</span><br><span class="hljs-built_in">shutdown</span> -h hours:minutes &amp;   <span class="hljs-meta">#按预定时间关闭系统</span><br><span class="hljs-built_in">shutdown</span> -c       <span class="hljs-meta">#取消按预定时间关闭系统</span><br><span class="hljs-built_in">shutdown</span> -r now   <span class="hljs-meta">#重启(1)</span><br>reboot   <span class="hljs-meta">#重启(2)</span><br>logout   <span class="hljs-meta">#注销</span><br></code></pre></td></tr></table></figure><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home    <span class="hljs-comment">#进入 &#x27;/ home&#x27; 目录&#x27;</span><br><span class="hljs-built_in">cd</span> ..       <span class="hljs-comment">#返回上一级目录</span><br><span class="hljs-built_in">cd</span> ../..    <span class="hljs-comment">#返回上两级目录</span><br><span class="hljs-built_in">cd</span>          <span class="hljs-comment">#进入个人的主目录</span><br><span class="hljs-built_in">cd</span> ~user1   <span class="hljs-comment">#进入个人的主目录</span><br><span class="hljs-built_in">cd</span> -       <span class="hljs-comment">#返回上次所在的目录</span><br><span class="hljs-built_in">pwd</span>        <span class="hljs-comment">#显示工作路径</span><br><br><span class="hljs-built_in">ls</span>      <span class="hljs-comment">#查看目录中的文件</span><br><span class="hljs-built_in">ls</span> -F   <span class="hljs-comment">#查看目录中的文件</span><br><span class="hljs-built_in">ls</span> -l   <span class="hljs-comment">#显示文件和目录的详细资料</span><br><span class="hljs-built_in">ls</span> -a   <span class="hljs-comment">#显示隐藏文件</span><br><span class="hljs-built_in">ls</span> *[0-9]*   <span class="hljs-comment">#显示包含数字的文件名和目录名</span><br>tree         <span class="hljs-comment">#显示文件和目录由根目录开始的树形结构(1)</span><br>lstree       <span class="hljs-comment">#显示文件和目录由根目录开始的树形结构(2)</span><br><br><span class="hljs-built_in">mkdir</span> dir1         <span class="hljs-comment">#创建一个叫做 &#x27;dir1&#x27; 的目录&#x27;</span><br><span class="hljs-built_in">mkdir</span> dir1 dir2    <span class="hljs-comment">#同时创建两个目录</span><br><span class="hljs-built_in">mkdir</span> -p /tmp/dir1/dir2   <span class="hljs-comment">#创建一个目录树</span><br><span class="hljs-built_in">rm</span> -f file1    <span class="hljs-comment">#删除一个叫做 &#x27;file1&#x27; 的文件&#x27;</span><br><span class="hljs-built_in">rmdir</span> dir1     <span class="hljs-comment">#删除一个叫做 &#x27;dir1&#x27; 的目录&#x27;</span><br><span class="hljs-built_in">rm</span> -rf dir1    <span class="hljs-comment">#删除一个叫做 &#x27;dir1&#x27; 的目录并同时删除其内容</span><br><span class="hljs-built_in">rm</span> -rf dir1 dir2    <span class="hljs-comment">#同时删除两个目录及它们的内容</span><br><span class="hljs-built_in">mv</span> dir1 new_dir     <span class="hljs-comment">#重命名/移动 一个目录</span><br><br><span class="hljs-built_in">cp</span> file1 file2     <span class="hljs-comment">#复制一个文件</span><br><span class="hljs-built_in">cp</span> <span class="hljs-built_in">dir</span>/* .         <span class="hljs-comment">#复制一个目录下的所有文件到当前工作目录</span><br><span class="hljs-built_in">cp</span> -a /tmp/dir1 .   <span class="hljs-comment">#复制一个目录到当前工作目录</span><br><span class="hljs-built_in">cp</span> -a dir1 dir2     <span class="hljs-comment">#复制一个目录</span><br><br><span class="hljs-built_in">ln</span> -s file1 lnk1  <span class="hljs-comment">#创建一个指向文件或目录的软链接</span><br><span class="hljs-built_in">ln</span> file1 lnk1     <span class="hljs-comment">#创建一个指向文件或目录的物理链接</span><br></code></pre></td></tr></table></figure><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> / -<span class="hljs-built_in">name</span> file1     #从 <span class="hljs-string">&#x27;/&#x27;</span> 开始进入根文件系统搜索文件和目录<br><span class="hljs-built_in">find</span> / -user user1     #搜索属于用户 <span class="hljs-string">&#x27;user1&#x27;</span> 的文件和目录<br><span class="hljs-built_in">find</span> /home/user1 -<span class="hljs-built_in">name</span> *.bin        #在目录 <span class="hljs-string">&#x27;/ home/user1&#x27;</span> 中搜索带有<span class="hljs-string">&#x27;.bin&#x27;</span> 结尾的文件<br><span class="hljs-built_in">find</span> /usr/bin -<span class="hljs-built_in">type</span> f -atime +<span class="hljs-number">100</span>    #搜索在过去<span class="hljs-number">100</span>天内未被使用过的执行文件<br><span class="hljs-built_in">find</span> /usr/bin -<span class="hljs-built_in">type</span> f -mtime -<span class="hljs-number">10</span>     #搜索在<span class="hljs-number">10</span>天内被创建或者修改过的文件<br><span class="hljs-built_in">find</span> / -<span class="hljs-built_in">name</span> *.rpm -<span class="hljs-built_in">exec</span> chmod <span class="hljs-number">755</span> <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> ;      #搜索以 <span class="hljs-string">&#x27;.rpm&#x27;</span> 结尾的文件并定义其权限<br><span class="hljs-built_in">find</span> / -xdev -<span class="hljs-built_in">name</span> *.rpm        #搜索以 <span class="hljs-string">&#x27;.rpm&#x27;</span> 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps       #寻找以 <span class="hljs-string">&#x27;.ps&#x27;</span> 结尾的文件 - 先运行 <span class="hljs-string">&#x27;updatedb&#x27;</span> 命令<br>whereis <span class="hljs-built_in">halt</span>       #显示一个二进制文件、源码或man的位置<br>which <span class="hljs-built_in">halt</span>         #显示一个二进制文件或可执行文件的完整路径<br></code></pre></td></tr></table></figure><h3 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">mount <span class="hljs-regexp">/dev/</span>hda2 <span class="hljs-regexp">/mnt/</span>hda2    <span class="hljs-comment">#挂载一个叫做hda2的盘 - 确定目录 &#x27;/ mnt/hda2&#x27; 已经存在</span><br>umount <span class="hljs-regexp">/dev/</span>hda2            <span class="hljs-comment">#卸载一个叫做hda2的盘 - 先从挂载点 &#x27;/ mnt/hda2&#x27; 退出</span><br>fuser -km <span class="hljs-regexp">/mnt/</span>hda2         <span class="hljs-comment">#当设备繁忙时强制卸载</span><br>umount -n <span class="hljs-regexp">/mnt/</span>hda2         <span class="hljs-comment">#运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用</span><br>mount <span class="hljs-regexp">/dev/</span>fd0 <span class="hljs-regexp">/mnt/</span>floppy        <span class="hljs-comment">#挂载一个软盘</span><br>mount <span class="hljs-regexp">/dev/</span>cdrom <span class="hljs-regexp">/mnt/</span>cdrom       <span class="hljs-comment">#挂载一个cdrom或dvdrom</span><br>mount <span class="hljs-regexp">/dev/</span>hdc <span class="hljs-regexp">/mnt/</span>cdrecorder    <span class="hljs-comment">#挂载一个cdrw或dvdrom</span><br>mount <span class="hljs-regexp">/dev/</span>hdb <span class="hljs-regexp">/mnt/</span>cdrecorder    <span class="hljs-comment">#挂载一个cdrw或dvdrom</span><br>mount -o loop file.iso <span class="hljs-regexp">/mnt/</span>cdrom    <span class="hljs-comment">#挂载一个文件或ISO镜像文件</span><br>mount -t vfat <span class="hljs-regexp">/dev/</span>hda5 <span class="hljs-regexp">/mnt/</span>hda5    <span class="hljs-comment">#挂载一个Windows FAT32文件系统</span><br>mount <span class="hljs-regexp">/dev/</span>sda1 <span class="hljs-regexp">/mnt/u</span>sbdisk         <span class="hljs-comment">#挂载一个usb 捷盘或闪存设备</span><br>mount -t smbfs -o username=user,password=pass <span class="hljs-regexp">//</span>WinClient<span class="hljs-regexp">/share /m</span>nt/share      <span class="hljs-comment">#挂载一个windows网络共享</span><br></code></pre></td></tr></table></figure><h3 id="磁盘空间相关"><a href="#磁盘空间相关" class="headerlink" title="磁盘空间相关"></a>磁盘空间相关</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h           <span class="hljs-comment">#显示已经挂载的分区列表</span><br><span class="hljs-built_in">ls</span> -lSr |more    <span class="hljs-comment">#以尺寸大小排列文件和目录</span><br><span class="hljs-built_in">du</span> -sh dir1      <span class="hljs-comment">#估算目录 &#x27;dir1&#x27; 已经使用的磁盘空间&#x27;</span><br><span class="hljs-built_in">du</span> -sk * | <span class="hljs-built_in">sort</span> -rn     <span class="hljs-comment">#以容量大小为依据依次显示文件和目录的大小</span><br>rpm -q -a --qf <span class="hljs-string">&#x27;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&#x27;</span> | <span class="hljs-built_in">sort</span> -k1,1n <br><span class="hljs-comment">#以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</span><br>dpkg-query -W -f=<span class="hljs-string">&#x27;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&#x27;</span> | <span class="hljs-built_in">sort</span> -k1,1n <br><span class="hljs-comment">#以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</span><br></code></pre></td></tr></table></figure><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">groupadd group_name   #创建一个新用户组<br>groupdel group_name   #删除一个用户组<br>groupmod -n new_group_name old_group_name   #重命名一个用户组<br>useradd -c <span class="hljs-string">&quot;Name Surname &quot;</span> -g admin -d /home/user1 -s /bin/bash user1     #创建一个属于 <span class="hljs-string">&quot;admin&quot;</span> 用户组的用户<br>useradd user1      #创建一个新用户<br>userdel -r user1   #删除一个用户 ( <span class="hljs-string">&#x27;-r&#x27;</span> 排除主目录)<br>usermod -c <span class="hljs-string">&quot;User FTP&quot;</span> -g <span class="hljs-keyword">system</span> -d /ftp/user1 -s /bin/nologin user1   #修改用户属性<br><br>passwd         #修改口令<br>passwd user1   #修改一个用户的口令 (只允许root执行)<br>chage -E <span class="hljs-number">2005</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span> user1    #设置用户口令的失效期限<br>pwck     #检查 <span class="hljs-string">&#x27;/etc/passwd&#x27;</span> 的文件格式和语法修正以及存在的用户<br>grpck    #检查 <span class="hljs-string">&#x27;/etc/passwd&#x27;</span> 的文件格式和语法修正以及存在的群组<br>newgrp group_name     #登陆进一个新的群组以改变新创建文件的预设群组<br></code></pre></td></tr></table></figure><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>使用 <span class="hljs-string">&quot;+&quot;</span> 设置权限，使用 <span class="hljs-string">&quot;-&quot;</span> 用于取消<br><br><span class="hljs-built_in">ls</span> -lh    <span class="hljs-comment">#显示权限</span><br><span class="hljs-built_in">ls</span> /tmp | <span class="hljs-built_in">pr</span> -T5 -W<span class="hljs-variable">$COLUMNS</span>   <span class="hljs-comment">#将终端划分成5栏显示</span><br><span class="hljs-built_in">chmod</span> ugo+rwx directory1      <span class="hljs-comment">#设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</span><br><span class="hljs-built_in">chmod</span> go-rwx directory1      <span class="hljs-comment">#删除群组(g)与其他人(o)对目录的读写执行权限</span><br><span class="hljs-built_in">chown</span> user1 file1            <span class="hljs-comment">#改变一个文件的所有人属性</span><br><span class="hljs-built_in">chown</span> -R user1 directory1    <span class="hljs-comment">#改变一个目录的所有人属性并同时改变改目录下所有文件的属性</span><br><span class="hljs-built_in">chgrp</span> group1 file1          <span class="hljs-comment">#改变文件的群组</span><br><span class="hljs-built_in">chown</span> user1:group1 file1     <span class="hljs-comment">#改变一个文件的所有人和群组属性</span><br>find / -perm -u+s           <span class="hljs-comment">#罗列一个系统中所有使用了SUID控制的文件</span><br><span class="hljs-built_in">chmod</span> u+s /bin/file1        <span class="hljs-comment">#设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</span><br><span class="hljs-built_in">chmod</span> u-s /bin/file1        <span class="hljs-comment">#禁用一个二进制文件的 SUID位</span><br><span class="hljs-built_in">chmod</span> g+s /home/public      <span class="hljs-comment">#设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</span><br><span class="hljs-built_in">chmod</span> g-s /home/public      <span class="hljs-comment">#禁用一个目录的 SGID 位</span><br><span class="hljs-built_in">chmod</span> o+t /home/public      <span class="hljs-comment">#设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</span><br><span class="hljs-built_in">chmod</span> o-t /home/public      <span class="hljs-comment">#禁用一个目录的 STIKY 位</span><br></code></pre></td></tr></table></figure><h3 id="文件的特殊属性"><a href="#文件的特殊属性" class="headerlink" title="文件的特殊属性"></a>文件的特殊属性</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">- 使用 <span class="hljs-string">&quot;+&quot;</span> 设置权限，使用 <span class="hljs-string">&quot;-&quot;</span> 用于取消<br><br>chattr +<span class="hljs-keyword">a</span> file1   <span class="hljs-comment">#只允许以追加方式读写文件</span><br>chattr +c file1   <span class="hljs-comment">#允许这个文件能被内核自动压缩/解压</span><br>chattr +d file1   <span class="hljs-comment">#在进行文件系统备份时，dump程序将忽略这个文件</span><br>chattr +i file1   <span class="hljs-comment">#设置成不可变的文件，不能被删除、修改、重命名或者链接</span><br>chattr +s file1   <span class="hljs-comment">#允许一个文件被安全地删除</span><br>chattr +S file1   <span class="hljs-comment">#一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</span><br>chattr +u file1   <span class="hljs-comment">#若文件被删除，系统会允许你在以后恢复这个被删除的文件</span><br>lsattr           <span class="hljs-comment">#显示特殊的属性</span><br></code></pre></td></tr></table></figure><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus">bunzip2 file1<span class="hljs-selector-class">.bz2</span>   #解压一个叫做 <span class="hljs-string">&#x27;file1.bz2&#x27;</span>的文件<br>bzip2 file1         #压缩一个叫做 <span class="hljs-string">&#x27;file1&#x27;</span> 的文件<br>gunzip file1<span class="hljs-selector-class">.gz</span>     #解压一个叫做 <span class="hljs-string">&#x27;file1.gz&#x27;</span>的文件<br>gzip file1          #压缩一个叫做 <span class="hljs-string">&#x27;file1&#x27;</span>的文件<br>gzip -<span class="hljs-number">9</span> file1       #最大程度压缩<br><br>rar <span class="hljs-selector-tag">a</span> file1<span class="hljs-selector-class">.rar</span> test_file          #创建一个叫做 <span class="hljs-string">&#x27;file1.rar&#x27;</span> 的包<br>rar <span class="hljs-selector-tag">a</span> file1<span class="hljs-selector-class">.rar</span> file1 file2 dir1   #同时压缩 <span class="hljs-string">&#x27;file1&#x27;</span>, <span class="hljs-string">&#x27;file2&#x27;</span> 以及目录 <span class="hljs-string">&#x27;dir1&#x27;</span><br>rar x file1<span class="hljs-selector-class">.rar</span>     #解压rar包<br>unrar x file1<span class="hljs-selector-class">.rar</span>   #解压rar包<br><br>tar -cvf archive<span class="hljs-selector-class">.tar</span> file1   #创建一个非压缩的 tarball<br>tar -cvf archive<span class="hljs-selector-class">.tar</span> file1 file2 dir1  #创建一个包含了 <span class="hljs-string">&#x27;file1&#x27;</span>, <span class="hljs-string">&#x27;file2&#x27;</span> 以及 <span class="hljs-string">&#x27;dir1&#x27;</span>的档案文件<br>tar -tf archive<span class="hljs-selector-class">.tar</span>    #显示一个包中的内容<br>tar -xvf archive<span class="hljs-selector-class">.tar</span>   #释放一个包<br>tar -xvf archive<span class="hljs-selector-class">.tar</span> -C /tmp     #将压缩包释放到 /tmp目录下<br>tar -cvfj archive<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.bz2</span> dir1   #创建一个bzip2格式的压缩包<br>tar -jxvf archive<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.bz2</span>        #解压一个bzip2格式的压缩包<br>tar -cvfz archive<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> dir1    #创建一个gzip格式的压缩包<br>tar -zxvf archive<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span>         #解压一个gzip格式的压缩包<br><br>zip file1<span class="hljs-selector-class">.zip</span> file1    #创建一个zip格式的压缩包<br>zip -r file1<span class="hljs-selector-class">.zip</span> file1 file2 dir1    #将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1<span class="hljs-selector-class">.zip</span>    #解压一个zip格式压缩包<br></code></pre></td></tr></table></figure><h3 id="RPM包（Fedora-Redhat-及类似系统）"><a href="#RPM包（Fedora-Redhat-及类似系统）" class="headerlink" title="RPM包（Fedora, Redhat 及类似系统）"></a>RPM包（Fedora, Redhat 及类似系统）</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">rpm -ivh package.rpm    <span class="hljs-comment">#安装一个rpm包</span><br>rpm -ivh <span class="hljs-params">--nodeeps</span> package.rpm   <span class="hljs-comment">#安装一个rpm包而忽略依赖关系警告</span><br>rpm -U package.rpm        <span class="hljs-comment">#更新一个rpm包但不改变其配置文件</span><br>rpm -F package.rpm        <span class="hljs-comment">#更新一个确定已经安装的rpm包</span><br>rpm -e package_name.rpm   <span class="hljs-comment">#删除一个rpm包</span><br>rpm -qa      <span class="hljs-comment">#显示系统中所有已经安装的rpm包</span><br>rpm -qa | grep httpd    <span class="hljs-comment">#显示所有名称中包含 &quot;httpd&quot; 字样的rpm包</span><br>rpm -qi package_name    <span class="hljs-comment">#获取一个已安装包的特殊信息</span><br>rpm -qg <span class="hljs-string">&quot;System Environment/Daemons&quot;</span>     <span class="hljs-comment">#显示一个组件的rpm包</span><br>rpm -ql package_name       <span class="hljs-comment">#显示一个已经安装的rpm包提供的文件列表</span><br>rpm -qc package_name       <span class="hljs-comment">#显示一个已经安装的rpm包提供的配置文件列表</span><br>rpm -q package_name <span class="hljs-params">--whatrequires</span>     <span class="hljs-comment">#显示与一个rpm包存在依赖关系的列表</span><br>rpm -q package_name <span class="hljs-params">--whatprovides</span>    <span class="hljs-comment">#显示一个rpm包所占的体积</span><br>rpm -q package_name <span class="hljs-params">--scripts</span>         <span class="hljs-comment">#显示在安装/删除期间所执行的脚本l</span><br>rpm -q package_name <span class="hljs-params">--changelog</span>       <span class="hljs-comment">#显示一个rpm包的修改历史</span><br>rpm -qf <span class="hljs-string">/etc/httpd/conf/httpd.conf</span>    <span class="hljs-comment">#确认所给的文件由哪个rpm包所提供</span><br>rpm -qp package.rpm -l    <span class="hljs-comment">#显示由一个尚未安装的rpm包提供的文件列表</span><br>rpm <span class="hljs-params">--import</span> <span class="hljs-string">/media/cdrom/RPM-GPG-KEY</span>    <span class="hljs-comment">#导入公钥数字证书</span><br>rpm <span class="hljs-params">--checksig</span> package.rpm      <span class="hljs-comment">#确认一个rpm包的完整性</span><br>rpm -qa gpg-pubkey      <span class="hljs-comment">#确认已安装的所有rpm包的完整性</span><br>rpm -V package_name     <span class="hljs-comment">#检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</span><br>rpm -Va                 <span class="hljs-comment">#检查系统中所有已安装的rpm包- 小心使用</span><br>rpm -Vp package.rpm     <span class="hljs-comment">#确认一个rpm包还未安装</span><br>rpm2cpio package.rpm | cpio <span class="hljs-params">--extract</span> <span class="hljs-params">--make-directories</span> *bin*   <span class="hljs-comment">#从一个rpm包运行可执行文件</span><br>rpm -ivh <span class="hljs-string">/usr/src/redhat/RPMS/</span>`arch`<span class="hljs-string">/package.rpm</span>    <span class="hljs-comment">#从一个rpm源码安装一个构建好的包</span><br>rpmbuild <span class="hljs-params">--rebuild</span> package_name.src.rpm       <span class="hljs-comment">#从一个rpm源码构建一个 rpm 包</span><br></code></pre></td></tr></table></figure><h3 id="YUM（Fedora-RedHat-及类似系统）"><a href="#YUM（Fedora-RedHat-及类似系统）" class="headerlink" title="YUM（Fedora, RedHat 及类似系统）"></a>YUM（Fedora, RedHat 及类似系统）</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> package_name             <span class="hljs-comment">#下载并安装一个rpm包</span><br>yum localinstall package_name.rpm    <span class="hljs-comment">#将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</span><br>yum update package_name.rpm    <span class="hljs-comment">#更新当前系统中所有安装的rpm包</span><br>yum update package_name        <span class="hljs-comment">#更新一个rpm包</span><br>yum <span class="hljs-keyword">remove</span> package_name        <span class="hljs-comment">#删除一个rpm包</span><br>yum <span class="hljs-keyword">list</span>                   <span class="hljs-comment">#列出当前系统中安装的所有包</span><br>yum search package_name     <span class="hljs-comment">#在rpm仓库中搜寻软件包</span><br>yum clean packages          <span class="hljs-comment">#清理rpm缓存删除下载的包</span><br>yum clean headers           <span class="hljs-comment">#删除所有头文件</span><br>yum clean all                <span class="hljs-comment">#删除所有缓存的包和头文件</span><br></code></pre></td></tr></table></figure><h3 id="DEB-包-Debian-Ubuntu-及类似系统"><a href="#DEB-包-Debian-Ubuntu-及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 及类似系统)"></a>DEB 包 (Debian, Ubuntu 及类似系统)</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">dpkg -i package.deb     <span class="hljs-meta">#安装/更新一个 deb 包</span><br>dpkg -r package_name    <span class="hljs-meta">#从系统删除一个 deb 包</span><br>dpkg -l                 <span class="hljs-meta">#显示系统中所有已经安装的 deb 包</span><br>dpkg -l | grep httpd    <span class="hljs-meta">#显示所有名称中包含 <span class="hljs-string">&quot;httpd&quot;</span> 字样的deb包</span><br>dpkg -s package_name    <span class="hljs-meta">#获得已经安装在系统中一个特殊包的信息</span><br>dpkg -L package_name    <span class="hljs-meta">#显示系统中已经安装的一个deb包所提供的文件列表</span><br>dpkg --contents package.deb    <span class="hljs-meta">#显示尚未安装的一个包所提供的文件列表</span><br>dpkg -S /bin/<span class="hljs-built_in">ping</span>              <span class="hljs-meta">#确认所给的文件由哪个deb包提供</span><br></code></pre></td></tr></table></figure><h3 id="APT-软件工具-Debian-Ubuntu-及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 及类似系统)</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">apt-<span class="hljs-keyword">get</span> install package_name      <span class="hljs-meta">#安装/更新一个 deb 包</span><br>apt-cdrom install package_name    <span class="hljs-meta">#从光盘安装/更新一个 deb 包</span><br>apt-<span class="hljs-keyword">get</span> update      <span class="hljs-meta">#升级列表中的软件包</span><br>apt-<span class="hljs-keyword">get</span> upgrade     <span class="hljs-meta">#升级所有已安装的软件</span><br>apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">remove</span> package_name     <span class="hljs-meta">#从系统删除一个deb包</span><br>apt-<span class="hljs-keyword">get</span> check     <span class="hljs-meta">#确认依赖的软件仓库正确</span><br>apt-<span class="hljs-keyword">get</span> clean     <span class="hljs-meta">#从下载的软件包中清理缓存</span><br>apt-cache search searched-package    <span class="hljs-meta">#返回包含所要搜索字符串的软件包名称</span><br></code></pre></td></tr></table></figure><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> file1      <span class="hljs-comment">#从第一个字节开始正向查看文件的内容</span><br><span class="hljs-built_in">tac</span> file1      <span class="hljs-comment">#从最后一行开始反向查看一个文件的内容</span><br>more file1     <span class="hljs-comment">#查看一个长文件的内容</span><br>less file1     <span class="hljs-comment">#类似于 &#x27;more&#x27; 命令，但是它允许在文件中和正向操作一样的反向操作</span><br><span class="hljs-built_in">head</span> -2 file1    <span class="hljs-comment">#查看一个文件的前两行</span><br><span class="hljs-built_in">tail</span> -2 file1    <span class="hljs-comment">#查看一个文件的最后两行</span><br><span class="hljs-built_in">tail</span> -f /var/log/messages     <span class="hljs-comment">#实时查看被添加到一个文件中的内容</span><br></code></pre></td></tr></table></figure><h3 id="网络-（以太网和-WIFI-无线）"><a href="#网络-（以太网和-WIFI-无线）" class="headerlink" title="网络 - （以太网和 WIFI 无线）"></a>网络 - （以太网和 WIFI 无线）</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ip</span> addr <br>ifconfig eth0    <span class="hljs-comment">#显示一个以太网卡的配置</span><br>ifup eth0        <span class="hljs-comment">#启用一个 &#x27;eth0&#x27; 网络设备</span><br>ifdown eth0      <span class="hljs-comment">#禁用一个 &#x27;eth0&#x27; 网络设备</span><br>ifconfig eth0 <span class="hljs-number">192.168.1.1</span> netmask <span class="hljs-number">255.255.255.0</span>     <span class="hljs-comment">#控制IP地址</span><br>ifconfig eth0 promisc     <span class="hljs-comment">#设置 &#x27;eth0&#x27; 成混杂模式以嗅探数据包 (sniffing)</span><br>dhclient eth0            <span class="hljs-comment">#以dhcp模式启用 &#x27;eth0&#x27;</span><br><br>route -n    <span class="hljs-comment">#查看路由表</span><br>route add -net <span class="hljs-number">0</span>/<span class="hljs-number">0</span> gw IP_Gateway    <span class="hljs-comment">#配置默认网关</span><br>route add -net <span class="hljs-number">192.168.0.0</span> netmask <span class="hljs-number">255.255.0.0</span> gw <span class="hljs-number">192.168.1.1</span> <br><span class="hljs-comment">#配置静态路由到达网络&#x27;192.168.0.0/16&#x27;</span><br>route del <span class="hljs-number">0</span>/<span class="hljs-number">0</span> gw IP_gateway        <span class="hljs-comment">#删除静态路由</span><br><br>hostname <span class="hljs-comment">#查看机器名</span><br>host www.example.com       <span class="hljs-comment">#把一个主机名解析到一个网际地址或把一个网际地址解析到一个主机名。</span><br>nslookup www.example.com   <span class="hljs-comment">#用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题。</span><br>ip link show            <span class="hljs-comment">#查看网卡信息</span><br>mii-tool                <span class="hljs-comment">#用于查看、管理介质的网络接口的状态</span><br>ethtool                 <span class="hljs-comment">#用于查询和设置网卡配置</span><br>netstat -tupl           <span class="hljs-comment">#用于显示TCP/UDP的状态信息</span><br>tcpdump tcp port <span class="hljs-number">80</span>     <span class="hljs-comment">#显示所有http协议的流量</span><br></code></pre></td></tr></table></figure><h3 id="查看开放端口命令及开放端口号"><a href="#查看开放端口命令及开放端口号" class="headerlink" title="查看开放端口命令及开放端口号"></a>查看开放端口命令及开放端口号</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 查看已开放的端口</span><br>firewall-cmd --list-ports<br><span class="hljs-comment"># 开放单个端口（开放后需要要重启防火墙才生效）</span><br>firewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--add-port</span>=8080/tcp --permanent<br><span class="hljs-comment"># 开放多个端口（开放后需要要重启防火墙才生效）（--permanent 为永久生效，不加为单次有效（重启失效））</span><br>firewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--add-port</span>=20000-29999/tcp --permanent<br><span class="hljs-comment"># 关闭端口（关闭后需要要重启防火墙才生效）</span><br>firewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--remove-port</span>=8080/tcp --permanent<br><span class="hljs-comment"># 查看端口是否打开</span><br>firewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--query-port</span>=80/tcp<br><span class="hljs-comment"># 查看防火墙状态（两种方式）</span><br>firewall-cmd --state<br>systemctl status firewalld<br><span class="hljs-comment"># 开启防火墙</span><br>systemctl start firewalld<br><span class="hljs-comment"># 重启防火墙（两种方式）</span><br>firewall-cmd --reload<br>systemctl restart firewalld<br><span class="hljs-comment"># 设置开机启动防火墙</span><br>systemctl <span class="hljs-built_in">enable</span> firewalld<br><span class="hljs-comment"># 查看防火墙设置开机自启是否成功</span><br>systemctl is-enabled firewalld;echo $?<br><span class="hljs-comment"># 禁止防火墙开机启动</span><br>systemctl <span class="hljs-built_in">disable</span> firewalld<br><span class="hljs-comment"># 停止防火墙</span><br>systemctl stop firewalld<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>封装和使用ViewBinding</title>
    <link href="/2022/09/27/view_bind_use/"/>
    <url>/2022/09/27/view_bind_use/</url>
    
    <content type="html"><![CDATA[<!-- 封装和使用 ViewBinding，该替代 Kotlin synthetic 和 ButterKnife --><span id="more"></span><p>封装和使用 ViewBinding，该替代 Kotlin synthetic 和 ButterKnife</p><h3 id="ViewBinding-的基础用法"><a href="#ViewBinding-的基础用法" class="headerlink" title="ViewBinding 的基础用法"></a>ViewBinding 的基础用法</h3><p>首先要在 module 的 build.gradle 文件配置开启 ViewBinding：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">android</span> &#123;<br>    <span class="hljs-operator">...</span><br>    <span class="hljs-keyword">viewBinding</span> &#123;<br>        enabled <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">buildFeatures</span> &#123;<br>        viewBinding <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样该模块下每个 XML 文件都生成一个对应的绑定类，每个绑定类会包含根视图以及具有 ID 的所有视图的引用。绑定类的命名是：将 XML 文件的名称转换为驼峰命名，并在末尾添加 “Binding” 。</p><p>比如现在有 activity_app.xml 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.AppActivity&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Heihei&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果不想生成某个布局的绑定类，可以在根视图添加 <strong>tools:viewBindingIgnore&#x3D;”true”</strong> 属性。</p><p>那这个绑定类的对象怎么实例化呢？该类会生成相关的 inflate 静态方法，调用该方法即可获得绑定对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> binding: ActivityAppBinding<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    binding = ActivityAppBinding.inflate(layoutInflater)<br>    setContentView(binding.root)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Fragment 使用有点不同，由于 Fragment 的存在时间比其视图长，需要在 onDestroyView() 方法中清除对绑定类实例的所有引用，所以写起来会有点麻烦。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeFragment</span> : <span class="hljs-type">Fragment</span>() &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _binding: HomeFragmentBinding? = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binding <span class="hljs-keyword">get</span>() = _binding!!<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    inflater: <span class="hljs-type">LayoutInflater</span>, container: <span class="hljs-type">ViewGroup</span>?, savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span>: View &#123;<br>    _binding = ResultProfileBinding.inflate(inflater, container, <span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">return</span> binding.root<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)<br>    binding.tvHelloWorld.text = <span class="hljs-string">&quot;Hello Android!&quot;</span><br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onDestroyView()<br>    _binding = <span class="hljs-literal">null</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有在 Adapter 的使用，因为布局不是只创建一次，而是每有一项数据就会创建，不能像上面那样在 Adapter 里写一个 binding 全局变量，这样 binding 只会得到最后一次创建的视图。所以 binding 对象应该是给 ViewHolder 持有。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextAdapter</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> list: List&lt;String&gt;<br>) : RecyclerView.Adapter&lt;TextAdapter.TextViewHolder&gt;() &#123;<br>  <br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, viewType: <span class="hljs-type">Int</span>)</span></span>: TextViewHolder &#123;<br>    <span class="hljs-keyword">val</span> binding = ItemTextBinding.inflate(LayoutInflater.from(parent.context), parent, <span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">return</span> TextViewHolder(binding)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">TextViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> content = list[position]<br>    holder.binding.tvContent.text = content<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span> = list.size<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextViewHolder</span>(<span class="hljs-keyword">val</span> binding : ItemTextBinding) : RecyclerView.ViewHolder(binding.root)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="封装方法"><a href="#封装方法" class="headerlink" title="封装方法"></a>封装方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> VB : ViewBinding&gt;</span> Activity.<span class="hljs-title">inflate</span><span class="hljs-params">()</span></span> = lazy &#123;<br>  inflateBinding&lt;VB&gt;(layoutInflater).apply &#123; setContentView(root) &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> VB : ViewBinding&gt;</span> Dialog.<span class="hljs-title">inflate</span><span class="hljs-params">()</span></span> = lazy &#123;<br>  inflateBinding&lt;VB&gt;(layoutInflater).apply &#123; setContentView(root) &#125;<br>&#125;<br><br><span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> VB : ViewBinding&gt;</span> <span class="hljs-title">inflateBinding</span><span class="hljs-params">(layoutInflater: <span class="hljs-type">LayoutInflater</span>)</span></span> =<br>  VB::<span class="hljs-keyword">class</span>.java.getMethod(<span class="hljs-string">&quot;inflate&quot;</span>, LayoutInflater::<span class="hljs-keyword">class</span>.java).invoke(<span class="hljs-literal">null</span>, layoutInflater) <span class="hljs-keyword">as</span> VB<br></code></pre></td></tr></table></figure><p>Activity 的用法，在 Dialog 使用是类似的。</p><p>Fragment 的封装不一样，首先生成方法 bind()，只需传个 View。另外还需要释放 binding 对象，不能用延时委托改用属性委托</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> VB : ViewBinding&gt;</span> Fragment.<span class="hljs-title">bindView</span><span class="hljs-params">()</span></span> =<br>  FragmentBindingDelegate(VB::<span class="hljs-keyword">class</span>.java)<br>  <br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Fragment.<span class="hljs-title">doOnDestroyView</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> =<br>  viewLifecycleOwner.lifecycle.addObserver(<span class="hljs-keyword">object</span> : LifecycleObserver &#123;<br>    <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>      block.invoke()<br>    &#125;<br>  &#125;)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentBindingDelegate</span>&lt;<span class="hljs-type">VB : ViewBinding</span>&gt;(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clazz: Class&lt;VB&gt;<br>) : ReadOnlyProperty&lt;Fragment, VB&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> binding: VB? = <span class="hljs-literal">null</span><br><br>  <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Fragment</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: VB &#123;<br>    <span class="hljs-keyword">if</span> (binding == <span class="hljs-literal">null</span>) &#123;<br>      binding = clazz.getMethod(<span class="hljs-string">&quot;bind&quot;</span>, View::<span class="hljs-keyword">class</span>.java)<br>        .invoke(<span class="hljs-literal">null</span>, thisRef.requireView()) <span class="hljs-keyword">as</span> VB<br>      thisRef.doOnDestroyView &#123; binding = <span class="hljs-literal">null</span> &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> binding!!<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果还有其它释放操作要在 binding 销毁前执行，需要写在 doOnDestroyView() 方法里</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeFragment</span> : <span class="hljs-type">Fragment</span>(R.layout.fragment_home) &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binding: FragmentHomeBinding <span class="hljs-keyword">by</span> bindView()<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)<br>    binding.tvHelloWorld.text = <span class="hljs-string">&quot;Hello Android!&quot;</span><br>    doOnDestroyView &#123;<br>      <span class="hljs-comment">// 在 binding 对象销毁前进行释放操作</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>列表的封装，binding 对象是给 ViewHolder 持有，所以 BindingViewHolder 来接收 binding</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">BindingViewHolder</span>&lt;<span class="hljs-type">VB</span> : <span class="hljs-type">ViewBinding</span>&gt;(<span class="hljs-title">val</span> <span class="hljs-title">binding</span>: <span class="hljs-type">VB</span>) : <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">ViewHolder</span>(<span class="hljs-title">binding</span>.<span class="hljs-title">root</span>)</span><br></code></pre></td></tr></table></figure><p>反射进行实例化</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : ViewBinding&gt;</span> <span class="hljs-title">newBindingViewHolder</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>)</span></span>: BindingViewHolder&lt;T&gt; &#123;<br>  <span class="hljs-keyword">val</span> method = T::<span class="hljs-keyword">class</span>.java.getMethod(<span class="hljs-string">&quot;inflate&quot;</span>, LayoutInflater::<span class="hljs-keyword">class</span>.java, ViewGroup::<span class="hljs-keyword">class</span>.java, <span class="hljs-built_in">Boolean</span>::<span class="hljs-keyword">class</span>.java)<br>  <span class="hljs-keyword">val</span> binding = method.invoke(<span class="hljs-literal">null</span>, LayoutInflater.from(parent.context), parent, <span class="hljs-literal">false</span>) <span class="hljs-keyword">as</span> T<br>  <span class="hljs-keyword">return</span> BindingViewHolder(binding)<br>&#125;<br></code></pre></td></tr></table></figure><p>onCreateViewHolder 调用封装的方法创建 BindingViewHolder 对象，然后在 onBindViewHolder 方法通过 holder 持有的 binding 拿到控件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextAdapter</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> list: List&lt;String&gt;<br>) : RecyclerView.Adapter&lt;BindingViewHolder&lt;ItemTextBinding&gt;&gt;() &#123;<br>  <br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, viewType: <span class="hljs-type">Int</span>)</span></span> =<br>    newBindingViewHolder&lt;ItemTextBinding&gt;(parent)<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">BindingViewHolder</span>&lt;<span class="hljs-type">ItemTextBinding</span>&gt;, position: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> content = list[position]<br>    holder.binding.tvContent.text = content<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span> = list.size<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基类封装"><a href="#基类封装" class="headerlink" title="基类封装"></a>基类封装</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseBindingActivity&lt;VB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewBinding&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">VB</span> binding;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    binding = <span class="hljs-type">ViewBindingUtil</span>.inflateWithGeneric(<span class="hljs-keyword">this</span>, getLayoutInflater());<br>    setContentView(binding.getRoot());<br>  &#125;<br><br>  public <span class="hljs-type">VB</span> getBinding() &#123;<br>    <span class="hljs-keyword">return</span> binding;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseBindingActivity&lt;ActivityMainBinding&gt;</span> </span>&#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    getBinding().tvHelloWorld.setText(<span class="hljs-string">&quot;Hello Android!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="混淆配置"><a href="#混淆配置" class="headerlink" title="混淆配置"></a>混淆配置</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">-keepclassmembers <span class="hljs-keyword">class</span> * implements androidx.viewbinding.ViewBinding &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> * <span class="hljs-title">inflate</span><span class="hljs-params">(android.view.LayoutInflater)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> * <span class="hljs-title">inflate</span><span class="hljs-params">(android.view.LayoutInflater, android.view.ViewGroup, <span class="hljs-type">boolean</span>)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> * <span class="hljs-title">bind</span><span class="hljs-params">(android.view.View)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ViewBinding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wsl设置代理</title>
    <link href="/2022/09/23/wsl_set_proxy/"/>
    <url>/2022/09/23/wsl_set_proxy/</url>
    
    <content type="html"><![CDATA[<!-- WSL2不能共享Windows的代理策略,需要WSL2配置代理 --><span id="more"></span><p>WSL2不能共享Windows的代理策略,需要WSL2配置代理</p><h3 id="获取宿主机IP"><a href="#获取宿主机IP" class="headerlink" title="获取宿主机IP"></a>获取宿主机IP</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">## 获取主机 IP</span><br><span class="hljs-comment">## 主机 IP 保存在 /etc/resolv.conf 中</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">hostip</span>=$(cat /etc/resolv.conf |grep -oP <span class="hljs-string">&#x27;(?&lt;=nameserver ).*&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="终端设置代理"><a href="#终端设置代理" class="headerlink" title="终端设置代理"></a>终端设置代理</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span>;<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span>;<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">all_proxy</span>=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br></code></pre></td></tr></table></figure><h3 id="设置别名使用"><a href="#设置别名使用" class="headerlink" title="设置别名使用"></a>设置别名使用</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># proxy</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">hostip</span>=$(ip<span class="hljs-built_in"> route </span>| grep<span class="hljs-built_in"> default </span>| awk <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span>)<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">hostport</span>=7890<br>alias <span class="hljs-attribute">proxy</span>=<span class="hljs-string">&#x27;</span><br><span class="hljs-string">    export HTTPS_PROXY=&quot;http://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span><br><span class="hljs-string">    export HTTP_PROXY=&quot;http://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span><br><span class="hljs-string">    export ALL_PROXY=&quot;http://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span><br><span class="hljs-string">&#x27;</span><br>alias <span class="hljs-attribute">unproxy</span>=<span class="hljs-string">&#x27;</span><br><span class="hljs-string">    unset HTTPS_PROXY;</span><br><span class="hljs-string">    unset HTTP_PROXY;</span><br><span class="hljs-string">    unset ALL_PROXY;</span><br><span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Win</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wsl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos 添加和删除用户</title>
    <link href="/2022/09/23/centos_change_user/"/>
    <url>/2022/09/23/centos_change_user/</url>
    
    <content type="html"><![CDATA[ <!-- Centos 添加和删除用户 --><span id="more"></span><p>如何在 CentOS 上添加和删除用户<br>在配置一台新的Linux 服务器时，第一件事情就是添加或者移除用户。每一个用户都有不同的权限级别，和针对各种命令行，应用程序的指定设置<br>想要创建或者移除用户，你需要以 root 或者其他拥有 sudo 权限的用户身份登录系统</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p><code>sudo adduser chris</code></p><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p><code>sudo passwd chris</code></p><p>提示输入和确认密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">Changing password <span class="hljs-keyword">for</span> <span class="hljs-keyword">user</span> chris.<br><span class="hljs-keyword">New</span> password: <br>Retype <span class="hljs-keyword">new</span> password: <br>passwd: <span class="hljs-keyword">all</span> authentication tokens updated successfully.<br></code></pre></td></tr></table></figure><h3 id="授予-Sudo-权限"><a href="#授予-Sudo-权限" class="headerlink" title="授予 Sudo 权限"></a>授予 Sudo 权限</h3><p>在 CentOS 系统上，用户组 wheel 成员都可以使用sudo访问</p><p><code>sudo usermod -aG wheel chris</code></p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p><code>sudo userdel chris</code></p><h3 id="删除用户及文件"><a href="#删除用户及文件" class="headerlink" title="删除用户及文件"></a>删除用户及文件</h3><p><code>sudo userdel -r chris</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wsl更改位置</title>
    <link href="/2022/09/23/win_wsl_import_export/"/>
    <url>/2022/09/23/win_wsl_import_export/</url>
    
    <content type="html"><![CDATA[<!-- Windows子系统(WSL)修改安装目录 --><span id="more"></span><p>Windows子系统(WSL)修改安装目录</p><h3 id="查看所有分发版本"><a href="#查看所有分发版本" class="headerlink" title="查看所有分发版本"></a>查看所有分发版本</h3><blockquote><p>wsl -l -v</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">  NAME                   STATE           <span class="hljs-keyword">VERSION</span><br>* Ubuntu                 Running         <span class="hljs-number">2</span>      <br>  docker-desktop-data    <span class="hljs-literal">Stopped</span>         <span class="hljs-number">2</span><br>  docker-desktop         <span class="hljs-literal">Stopped</span>         <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="导出分发版为tar文件"><a href="#导出分发版为tar文件" class="headerlink" title="导出分发版为tar文件"></a>导出分发版为tar文件</h3><p><code>wsl --export Ubuntu-20.04 d:\ubuntu20.04.tar</code></p><h3 id="注销当前分发版"><a href="#注销当前分发版" class="headerlink" title="注销当前分发版"></a>注销当前分发版</h3><p><code>wsl --unregister Ubuntu-20.04</code></p><h3 id="重新导入并安装分发版在d-ubuntu"><a href="#重新导入并安装分发版在d-ubuntu" class="headerlink" title="重新导入并安装分发版在d:\ubuntu"></a>重新导入并安装分发版在d:\ubuntu</h3><p><code>wsl --import Ubuntu-20.04 d:\ubuntu d:\ubuntu20.04.tar --version 2</code></p><h3 id="设置默认登陆用户为安装时用户名"><a href="#设置默认登陆用户为安装时用户名" class="headerlink" title="设置默认登陆用户为安装时用户名"></a>设置默认登陆用户为安装时用户名</h3><p><code>ubuntu2004 config --default-user Username</code></p><h3 id="删除tar文件-可选"><a href="#删除tar文件-可选" class="headerlink" title="删除tar文件(可选)"></a>删除tar文件(可选)</h3><p><code>del d:\ubuntu20.04.tar</code></p>]]></content>
    
    
    <categories>
      
      <category>Win</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wsl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oh-my-zsh安装</title>
    <link href="/2022/09/23/oh-my-zsh_install/"/>
    <url>/2022/09/23/oh-my-zsh_install/</url>
    
    <content type="html"><![CDATA[<!-- Oh-my-zsh安装及扩展插件安装 --><span id="more"></span><p>Oh-my-zsh安装及扩展插件安装</p><h3 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span>  /etc/shells<br>chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><h3 id="下载gitee"><a href="#下载gitee" class="headerlink" title="下载gitee"></a>下载gitee</h3><p><code>wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh</code></p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><blockquote><p>install.sh</p></blockquote><p>找到以下部分</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># Default settings</span><br><span class="hljs-variable constant_">ZSH</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">ZSH</span><span class="hljs-symbol">:-~/</span>.oh-my-zsh&#125;<br><span class="hljs-variable constant_">REPO</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">REPO</span><span class="hljs-symbol">:-ohmyzsh/ohmyzsh</span>&#125;<br><span class="hljs-variable constant_">REMOTE</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">REMOTE</span><span class="hljs-symbol">:-https</span><span class="hljs-symbol">://github</span>.com/<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">REPO</span>&#125;.git&#125;<br><span class="hljs-variable constant_">BRANCH</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">BRANCH</span><span class="hljs-symbol">:-master</span>&#125;<br></code></pre></td></tr></table></figure><p>把</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable constant_">REPO</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">REPO</span><span class="hljs-symbol">:-ohmyzsh/ohmyzsh</span>&#125;<br><span class="hljs-variable constant_">REMOTE</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">REMOTE</span><span class="hljs-symbol">:-https</span><span class="hljs-symbol">://github</span>.com/<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">REPO</span>&#125;.git&#125;<br></code></pre></td></tr></table></figure><p>替换为</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable constant_">REPO</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">REPO</span><span class="hljs-symbol">:-mirrors/oh-my-zsh</span>&#125;<br><span class="hljs-variable constant_">REMOTE</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">REMOTE</span><span class="hljs-symbol">:-https</span><span class="hljs-symbol">://gitee</span>.com/<span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">REPO</span>&#125;.git&#125;<br></code></pre></td></tr></table></figure><h3 id="修改仓库地址"><a href="#修改仓库地址" class="headerlink" title="修改仓库地址"></a>修改仓库地址</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">cd</span> ~/.<span class="hljs-string">oh-my-zsh</span><br><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">https</span>://<span class="hljs-string">gitee</span>.<span class="hljs-string">com</span>/<span class="hljs-string">mirrors</span>/<span class="hljs-string">oh-my-zsh</span>.<span class="hljs-string">git</span><br><span class="hljs-string">git</span> <span class="hljs-string">pull</span><br></code></pre></td></tr></table></figure><h3 id="插件-zsh-syntax-highlighting"><a href="#插件-zsh-syntax-highlighting" class="headerlink" title="插件 zsh-syntax-highlighting"></a>插件 zsh-syntax-highlighting</h3><p>高亮语法</p><blockquote><p>git clone <a href="https://github.com/zsh-users/zsh-syntax-highlighting.git">https://github.com/zsh-users/zsh-syntax-highlighting.git</a> ${ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom}&#x2F;plugins&#x2F;zsh-syntax-highlighting</p></blockquote><h3 id="插件-zsh-autosuggestions"><a href="#插件-zsh-autosuggestions" class="headerlink" title="插件 zsh-autosuggestions"></a>插件 zsh-autosuggestions</h3><p>自动补全</p><blockquote><p>git clone <a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions</a> ${ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom}&#x2F;plugins&#x2F;zsh-autosuggestions</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Terminal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows系统设置PowerShell代理及别名</title>
    <link href="/2022/09/23/win_powershell_proxy_alias/"/>
    <url>/2022/09/23/win_powershell_proxy_alias/</url>
    
    <content type="html"><![CDATA[<!-- Win系统PowerShell设置代理及使用别名 --><span id="more"></span><p>Win系统PowerShell设置代理及使用别名</p><h3 id="创建永久的别名"><a href="#创建永久的别名" class="headerlink" title="创建永久的别名"></a>创建永久的别名</h3><p>在PowerShell中直接使用Set-Alias或New-Alias命令创建的别名在关闭此Session后即会失效，防止此现象的方法是将此命令写入Windows PowerShell profile文件。</p><p><code>PS C:\&gt; $profile</code></p><p>一般该文件在没有创建前是不存在的，使用以下命令为当前用户创建profile命令并返回文件地址：</p><p><code>PS C:\&gt; New-Item -Type file -Force $profile</code></p><p>一般创建的位置在~\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1<br>打开文件，键入文件内容为Get-ChildItem -Name创建别名ls：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">function scr &#123;<br>    scrcpy -S<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Remove-Item <span class="hljs-built_in">alias</span>:\<span class="hljs-built_in">ls</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Set-Alias <span class="hljs-built_in">ls</span> scr</span><br></code></pre></td></tr></table></figure><p>这里首先为Get-ChildItem -Name创建了方法getFileName作为中介，然后为该方法赋予别名ls，但是因为ls是Windows PowerShell中的默认别名，因此必须先删除再创建，所以先使用Remove-Item再使用Set-Alias或New-Alias。<br>以后每次在打开PowerShell会话框的时候其会先读取$profile文件中的内容。</p><h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">function<span class="hljs-built_in"> proxy </span>&#123;<br>  <span class="hljs-variable">$env</span>:<span class="hljs-attribute">HTTP_PROXY</span>=<span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span><br>&#125;<br><br>function proxys &#123;<br>  <span class="hljs-variable">$env</span>:<span class="hljs-attribute">HTTPS_PROXY</span>=<span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Win</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux终端走代理</title>
    <link href="/2022/09/15/terminal_proxy/"/>
    <url>/2022/09/15/terminal_proxy/</url>
    
    <content type="html"><![CDATA[<!-- Linux 让终端走代理的几种方法 --><span id="more"></span><p>Linux 让终端走代理的几种方法</p><h3 id="两种代理方式"><a href="#两种代理方式" class="headerlink" title="两种代理方式"></a>两种代理方式</h3><p><code>socks5://127.0.0.1:1080</code></p><p><code>http://127.0.0.1:12333</code></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>在终端中直接运行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=http://proxyAddress:port<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=http://127.0.0.1:12333<br></code></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=<span class="hljs-string">&quot;http://localhost:port&quot;</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=<span class="hljs-string">&quot;http://localhost:port&quot;</span><br></code></pre></td></tr></table></figure><p>走socket5协议（ss,ssr）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=<span class="hljs-string">&quot;socks5://127.0.0.1:1080&quot;</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=<span class="hljs-string">&quot;socks5://127.0.0.1:1080&quot;</span><br></code></pre></td></tr></table></figure><p>直接设置ALL_PROXY</p><p><code>export ALL_PROXY=socks5://127.0.0.1:1080</code></p><p>最后在执行如下命令应用设置</p><p><code>source ~/.bashrc</code></p><p>通过设置alias简写来简化操作，每次要用的时候输入setproxy，不用了就unsetproxy</p><p><code> alias setproxy=&quot;export ALL_PROXY=socks5://127.0.0.1:1080&quot; alias unsetproxy=&quot;unset ALL_PROXY&quot;</code></p><h3 id="使用ss-ssr来加快git的速度"><a href="#使用ss-ssr来加快git的速度" class="headerlink" title="使用ss&#x2F;ssr来加快git的速度"></a>使用ss&#x2F;ssr来加快git的速度</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span> <br>git config <span class="hljs-attr">--global</span> https<span class="hljs-selector-class">.proxy</span> <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle换阿里源</title>
    <link href="/2022/09/15/gradle_change_repo/"/>
    <url>/2022/09/15/gradle_change_repo/</url>
    
    <content type="html"><![CDATA[<!-- Gradle源换成阿里云(解决gradle和插件下载同步问题) --><span id="more"></span><p>Gradle源换成阿里云(解决gradle和插件下载同步问题)</p><h3 id="阿里源地址"><a href="#阿里源地址" class="headerlink" title="阿里源地址"></a>阿里源地址</h3><p><a href="https://developer.aliyun.com/mvn/guide">https://developer.aliyun.com/mvn/guide</a></p><h3 id="在项目中的build-gradle修改内容"><a href="#在项目中的build-gradle修改内容" class="headerlink" title="在项目中的build.gradle修改内容"></a>在项目中的build.gradle修改内容</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">buildscript</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;http</span><span class="hljs-operator">:</span><span class="hljs-comment">//maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;</span><br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;http</span><span class="hljs-operator">:</span><span class="hljs-comment">//maven.aliyun.com/nexus/content/repositories/jcenter&#x27; &#125;</span><br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;http</span><span class="hljs-operator">:</span><span class="hljs-comment">//maven.aliyun.com/nexus/content/repositories/google&#x27; &#125;</span><br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;http</span><span class="hljs-operator">:</span><span class="hljs-comment">//maven.aliyun.com/nexus/content/repositories/gradle-plugin&#x27; &#125;</span><br>    &#125;<br>    <span class="hljs-keyword">dependencies</span> &#123;<br>        classpath <span class="hljs-symbol">&#x27;com</span>.android.tools.build<span class="hljs-operator">:</span>gradle<span class="hljs-operator">:</span>3.2.1&#x27;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">allprojects</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;http</span><span class="hljs-operator">:</span><span class="hljs-comment">//maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;</span><br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;http</span><span class="hljs-operator">:</span><span class="hljs-comment">//maven.aliyun.com/nexus/content/repositories/jcenter&#x27; &#125;</span><br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;http</span><span class="hljs-operator">:</span><span class="hljs-comment">//maven.aliyun.com/nexus/content/repositories/google&#x27; &#125;</span><br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;http</span><span class="hljs-operator">:</span><span class="hljs-comment">//maven.aliyun.com/nexus/content/repositories/gradle-plugin&#x27; &#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对所有项目生效"><a href="#对所有项目生效" class="headerlink" title="对所有项目生效"></a>对所有项目生效</h3><p>在用户&#x2F;.gradle&#x2F;下创建init.gradle文件</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">allprojects&#123;<br>    <span class="hljs-attribute">repositories &#123;</span><br><span class="hljs-attribute">        def ALIYUN_REPOSITORY_URL = &#x27;http</span>://maven<span class="hljs-variable">.aliyun</span><span class="hljs-variable">.com</span>/nexus/content/groups/public&#x27;<br>        def ALIYUN_JCENTER_URL = &#x27;http://maven<span class="hljs-variable">.aliyun</span><span class="hljs-variable">.com</span>/nexus/content/repositories/jcenter&#x27;<br>        all &#123; ArtifactRepository repo -&gt;<br>            if(repo instanceof MavenArtifactRepository)&#123;<br>                def url = repo<span class="hljs-variable">.url</span><span class="hljs-variable">.toString</span>()<br>                if (url<span class="hljs-variable">.startsWith</span>(&#x27;https://repo1<span class="hljs-variable">.maven</span><span class="hljs-variable">.org</span>/maven2&#x27;)) &#123;<br>                    project<span class="hljs-variable">.logger</span><span class="hljs-variable">.lifecycle</span> &quot;Repository $&#123;repo<span class="hljs-variable">.url</span>&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;<br>                    remove repo<br>                &#125;<br>                if (url<span class="hljs-variable">.startsWith</span>(&#x27;https://jcenter<span class="hljs-variable">.bintray</span><span class="hljs-variable">.com</span>/&#x27;)) &#123;<br>                    project<span class="hljs-variable">.logger</span><span class="hljs-variable">.lifecycle</span> &quot;Repository $&#123;repo<span class="hljs-variable">.url</span>&#125; replaced by $ALIYUN_JCENTER_URL.&quot;<br>                    remove repo<br>                &#125;<br>            &#125;<br>        &#125;<br>        maven &#123;<br>            url ALIYUN_REPOSITORY_URL<br>            url ALIYUN_JCENTER_URL<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Homebrew Tap 添加更多仓库</title>
    <link href="/2022/09/15/homebrew_tap_add_repo/"/>
    <url>/2022/09/15/homebrew_tap_add_repo/</url>
    
    <content type="html"><![CDATA[<!-- Homebrew 扩容指令tap与一些优秀的额外仓库。 --><span id="more"></span><p>Homebrew 扩容指令tap与一些优秀的额外仓库。</p><p>Homebrew 默认只有两个仓库「Formulae」与「Casks」，可以使用tap指令为其添加更多仓库，让search找到的东西更多！</p><h3 id="使用brew-tap查看当前所有的仓库"><a href="#使用brew-tap查看当前所有的仓库" class="headerlink" title="使用brew tap查看当前所有的仓库"></a>使用brew tap查看当前所有的仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">~ &gt; brew tap<br>beeftornado/rmtree  <span class="hljs-comment"># 循环移除指令的仓库</span><br>homebrew/cask  <span class="hljs-comment"># 「Casks」</span><br>homebrew/core  <span class="hljs-comment"># 「Formulae」</span><br></code></pre></td></tr></table></figure><h3 id="官方仓库"><a href="#官方仓库" class="headerlink" title="官方仓库"></a>官方仓库</h3><p><a href="https://github.com/Homebrew">https://github.com/Homebrew</a></p><p><strong>homebrew-cask-versions</strong> 提供历史版本的软件包。使用 Homebrew 安装软件包只能安装默认的最新版本，不支持安装任意版本。这个仓库就提供了软件包一些比较重要的历史版本，例如python@2。添加之后，可以在search时看到有哪些历史版本提供。</p><p><strong>homebrew-cask-fonts</strong> 字体库</p><p><strong>homebrew-cask-drivers</strong> 驱动库</p><p><strong>homebrew-aliases</strong> 提供设置 Homebrew 指令别名的指令</p><p><strong>homebrew-livecheck</strong> 提供实时更新软件包的指令</p><p><strong>homebrew&#x2F;services</strong> 服务启动指令</p><h3 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew tap [org]/[repo]  <span class="hljs-comment"># org 是组织名称，repo 是仓库名称</span><br>brew tap homebrew/homebrew-cask-fonts  <span class="hljs-comment"># 添加 homebrew 下的 homebrew-cask-fonts 仓库</span><br></code></pre></td></tr></table></figure><h3 id="移除仓库"><a href="#移除仓库" class="headerlink" title="移除仓库"></a>移除仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew untap [org]/[repo]  <span class="hljs-comment"># org 是组织名称，repo 是仓库名称</span><br>brew untap homebrew/homebrew-cask-fonts  <span class="hljs-comment"># 移除已添加的 homebrew 下的 homebrew-cask-fonts 仓库</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Homebrew</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker离线导入镜像</title>
    <link href="/2022/09/14/docker_offline_import/"/>
    <url>/2022/09/14/docker_offline_import/</url>
    
    <content type="html"><![CDATA[<!-- Docker镜像有时很大，下载慢，docker可以将已有的镜像导出成tar文件，并且可以再次导入到docker --><span id="more"></span><p>Docker镜像有时很大，下载慢，docker可以将已有的镜像导出成tar文件，并且可以再次导入到docker</p><h3 id="镜像导出成tar文件"><a href="#镜像导出成tar文件" class="headerlink" title="镜像导出成tar文件"></a>镜像导出成tar文件</h3><p><code>docker save java:8 -o java.tar</code></p><h3 id="导入镜像文件"><a href="#导入镜像文件" class="headerlink" title="导入镜像文件"></a>导入镜像文件</h3><p><code>docker load -i java.tar</code></p><h3 id="查看导入的镜像文件"><a href="#查看导入的镜像文件" class="headerlink" title="查看导入的镜像文件"></a>查看导入的镜像文件</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">[root@chris ~]<span class="hljs-comment"># docker images</span><br>REPOSITORY                                             <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br>java                                                   <span class="hljs-number">8</span>                   d23bdf5b1b1b        <span class="hljs-number">3</span> years ago         <span class="hljs-number">643M</span>B<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows修改终端Terminal为Cmder</title>
    <link href="/2022/09/14/win_change_idea_cmder/"/>
    <url>/2022/09/14/win_change_idea_cmder/</url>
    
    <content type="html"><![CDATA[<!-- 修改 Terminal 为 Cmder --><span id="more"></span><p>修改 Terminal 为 Cmder</p><h3 id="增加系统变量"><a href="#增加系统变量" class="headerlink" title="增加系统变量"></a>增加系统变量</h3><p>变量名为：CMDER_ROOT</p><p>变量值为：C:Applicationcmder(主机上 Cmder 安装主目录)</p><h3 id="IDEA设置"><a href="#IDEA设置" class="headerlink" title="IDEA设置"></a>IDEA设置</h3><p>进入 Tools，再进入 Terminal，在 Shell path 那一栏中，输入以下内容 “cmd.exe” &#x2F;k “”%CMDER_ROOT%vendorinit.bat””</p><p>重新启动 Idea IDE，然后打开 Terminal查看是否配置正确</p>]]></content>
    
    
    <categories>
      
      <category>Win</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装GitLab</title>
    <link href="/2022/09/14/docker_install_gitlab/"/>
    <url>/2022/09/14/docker_install_gitlab/</url>
    
    <content type="html"><![CDATA[<!-- 使用Docker方式安装Gitlab --><span id="more"></span><p>使用Docker方式安装Gitlab</p><h3 id="查询可用docker镜像"><a href="#查询可用docker镜像" class="headerlink" title="查询可用docker镜像"></a>查询可用docker镜像</h3><blockquote><p>docker search gitlab</p></blockquote><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><blockquote><p>docker pull gitlab&#x2F;gitlab-ce<br>docker pull twang2218&#x2F;gitlab-ce-zh</p></blockquote><p><strong>twang2218&#x2F;gitlab-ce-zh</strong> 中文版gitlab</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><blockquote><p>docker run -d -p 10008:80 -p 10009:443 -p 10010:22 –restart always –name my_gitlab -v &#x2F;docker&#x2F;gitlab&#x2F;etc&#x2F;gitlab:&#x2F;etc&#x2F;gitlab -v &#x2F;docker&#x2F;gitlab&#x2F;var&#x2F;log&#x2F;gitlab:&#x2F;var&#x2F;log&#x2F;gitlab -v &#x2F;docker&#x2F;gitlab&#x2F;var&#x2F;opt&#x2F;gitlab:&#x2F;var&#x2F;opt&#x2F;gitlab –privileged&#x3D;true twang2218&#x2F;gitlab-ce-zh</p></blockquote><h3 id="修改gitlab-rb文件"><a href="#修改gitlab-rb文件" class="headerlink" title="修改gitlab.rb文件"></a>修改gitlab.rb文件</h3><blockquote><p>vi &#x2F;docker&#x2F;gitlab&#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</p></blockquote><p>修改位置：</p><blockquote><p># 设置为域名，如下<br>external_url ‘<a href="http://gitlab.xxxx.com/">http://gitlab.xxxx.com</a>‘<br># ip，如下<br>external_url ‘<a href="http://192.168.0.101/">http://192.168.0.101</a>‘  </p></blockquote><blockquote><p># 直接使用域名<br>gitlab_rails[‘gitlab_ssh_host’] &#x3D;  ‘gitlab.xxx.com’<br># ip地址<br>gitlab_rails[‘gitlab_ssh_host’] &#x3D; ‘192.168.0.101’</p></blockquote><blockquote><p># 端口为启动docker时映射的ssh端口<br>gitlab_rails[‘gitlab_shell_ssh_port’] &#x3D;10010 </p></blockquote><blockquote><p># 设置时区为东八区，即北京时间<br>gitlab_rails[‘time_zone’] &#x3D; ‘Asia&#x2F;Shanghai’  </p></blockquote><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><blockquote><p>docker restart my_gitlab</p></blockquote><h3 id="进入docker容器里"><a href="#进入docker容器里" class="headerlink" title="进入docker容器里"></a>进入docker容器里</h3><blockquote><p>docker exec -it my_gitlab &#x2F;bin&#x2F;bash</p></blockquote><h3 id="修改端口号"><a href="#修改端口号" class="headerlink" title="修改端口号"></a>修改端口号</h3><blockquote><p>vi &#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-rails&#x2F;config&#x2F;gitlab.yml</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gitlab:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">10008</span><br>    <span class="hljs-attr">https:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-string">----------</span><br>    <span class="hljs-attr">ssh_host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.101</span><br></code></pre></td></tr></table></figure><h3 id="重启gitlab"><a href="#重启gitlab" class="headerlink" title="重启gitlab"></a>重启gitlab</h3><p>执行 <strong>gitlab-ctl restart</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@chris</span><span class="hljs-symbol">:/etc/gitlab</span><span class="hljs-comment"># gitlab-ctl restart</span><br><span class="hljs-symbol">ok:</span> <span class="hljs-symbol">run:</span> <span class="hljs-symbol">alertmanager:</span> (pid <span class="hljs-number">4567</span>) <span class="hljs-number">1</span>s<br>----------<br><span class="hljs-symbol">ok:</span> <span class="hljs-symbol">run:</span> <span class="hljs-symbol">sshd:</span> (pid <span class="hljs-number">4703</span>) <span class="hljs-number">1</span>s<br>root<span class="hljs-variable">@chris</span><span class="hljs-symbol">:/etc/gitlab</span><br></code></pre></td></tr></table></figure><p>在浏览器打开 ip：端口号即可访问</p><h3 id="查看root默认密码"><a href="#查看root默认密码" class="headerlink" title="查看root默认密码"></a>查看root默认密码</h3><p>第一次登录设置密码</p><blockquote><p>cat &#x2F;docker&#x2F;gitlab&#x2F;etc&#x2F;gitlab&#x2F;initial_root_password</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gitlab</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/09/14/git_common/"/>
    <url>/2022/09/14/git_common/</url>
    
    <content type="html"><![CDATA[<!-- 整理常用的 Git 命令清单 --><span id="more"></span><p>整理常用的 Git 命令清单</p><h3 id="几个专用名词"><a href="#几个专用名词" class="headerlink" title="几个专用名词"></a>几个专用名词</h3><ul><li>Workspace：工作区</li><li>Index &#x2F; Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录新建一个Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个目录，将其初始化为Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init [project-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载一个项目和它的整个代码历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> [url]</span><br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 显示当前的Git配置</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--list</span><br><br><span class="hljs-comment"># 编辑Git配置文件</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> -<span class="hljs-string">e</span> [<span class="hljs-built_in">--global]</span><br><br><span class="hljs-comment"># 设置提交代码时的用户信息</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> [<span class="hljs-built_in">--global]</span> <span class="hljs-string">user</span>.<span class="hljs-string">name</span> <span class="hljs-string">&quot;[name]&quot;</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> [<span class="hljs-built_in">--global]</span> <span class="hljs-string">user</span>.<span class="hljs-string">email</span> <span class="hljs-string">&quot;[email address]&quot;</span><br></code></pre></td></tr></table></figure><h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加&#x2F;删除文件"></a>增加&#x2F;删除文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定目录到暂存区，包括子目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [<span class="hljs-built_in">dir</span>]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加当前目录的所有文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加每个变化前，都会要求确认</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于同一个文件的多处变化，可以实现分次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add -p</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除工作区文件，并且将这次删除放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止追踪指定文件，但该文件会保留在工作区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> --cached [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改名文件，并且将这个改名放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]</span><br></code></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 提交暂存区到仓库区</span><br><span class="hljs-variable">$ </span>git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br><span class="hljs-variable">$ </span>git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="hljs-variable">$ </span>git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br><span class="hljs-variable">$ </span>git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="hljs-variable">$ </span>git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="hljs-variable">$ </span>git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -r</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -a</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，指向指定commit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch] [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --track [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定分支，并更新工作区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到上一个分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --set-upstream [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择一个commit，合并进当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cherry-pick [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span><br></code></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 列出所有tag</span><br>$ git <span class="hljs-keyword">tag</span><br><br><span class="hljs-title"># 新建一个tag</span>在当前commit<br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">[tag</span>]<br><br><span class="hljs-comment"># 新建一个tag在指定commit</span><br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">[tag</span>] [commit]<br><br><span class="hljs-comment"># 删除本地tag</span><br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> [<span class="hljs-keyword">tag</span>]<br><br><span class="hljs-comment"># 删除远程tag</span><br>$ git push origin :refs/tags/[tagName]<br><br><span class="hljs-comment"># 查看tag信息</span><br>$ git show [<span class="hljs-keyword">tag</span>]<br><br><span class="hljs-comment"># 提交指定tag</span><br>$ git push [remote] [<span class="hljs-keyword">tag</span>]<br><br><span class="hljs-comment"># 提交所有tag</span><br>$ git push [remote] --tags<br><br><span class="hljs-comment"># 新建一个分支，指向某个tag</span><br>$ git checkout -b [branch] [<span class="hljs-keyword">tag</span>]<br></code></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示有变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前分支的版本历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示commit历史，以及每次commit发生变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索提交历史，根据关键词</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> -S [keyword]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某个commit之后的所有变动，其<span class="hljs-string">&quot;提交说明&quot;</span>必须符合搜索条件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> [tag] HEAD --grep feature</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某个文件的版本历史，包括文件改名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --follow [file]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git whatchanged [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示指定文件相关的每一次diff</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> -p [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示过去5次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> -5 --pretty --oneline</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示所有提交过的用户，按提交次数排序</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git shortlog -sn</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示指定文件是什么人在什么时间修改过</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git blame [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示暂存区和工作区的差异</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示暂存区和上一个commit的差异</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff --cached [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示工作区与当前分支最新commit之间的差异</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff HEAD</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示两次提交之间的差异</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff [first-branch]...[second-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示今天你写了多少行代码</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff --shortstat <span class="hljs-string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某次提交的元数据和内容变化</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git show [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某次提交发生变化的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git show --name-only [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某次提交时，某个文件的内容</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git show [commit]:[filename]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前分支的最近几次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git reflog</span><br></code></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 下载远程仓库的所有变动</span><br><span class="hljs-variable">$ </span>git fetch [remote]<br><br><span class="hljs-comment"># 显示所有远程仓库</span><br><span class="hljs-variable">$ </span>git remote -v<br><br><span class="hljs-comment"># 显示某个远程仓库的信息</span><br><span class="hljs-variable">$ </span>git remote show [remote]<br><br><span class="hljs-comment"># 增加一个新的远程仓库，并命名</span><br><span class="hljs-variable">$ </span>git remote add [shortname] [url]<br><br><span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="hljs-variable">$ </span>git pull [remote] [branch]<br><br><span class="hljs-comment"># 上传本地指定分支到远程仓库</span><br><span class="hljs-variable">$ </span>git push [remote] [branch]<br><br><span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="hljs-variable">$ </span>git push [remote] --force<br><br><span class="hljs-comment"># 推送所有分支到远程仓库</span><br><span class="hljs-variable">$ </span>git push [remote] --all<br></code></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="hljs-variable">$ </span>git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="hljs-variable">$ </span>git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="hljs-variable">$ </span>git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="hljs-variable">$ </span>git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="hljs-variable">$ </span>git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="hljs-variable">$ </span>git stash<br><span class="hljs-variable">$ </span>git stash pop<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown常用语法</title>
    <link href="/2022/09/13/lesson_markdown/"/>
    <url>/2022/09/13/lesson_markdown/</url>
    
    <content type="html"><![CDATA[<!-- MarkDown基础语法介绍 --><span id="more"></span><p>MarkDown基础语法介绍</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*这里是文字*</span>  倾斜<br><span class="hljs-emphasis">_这里是文字_</span>  倾斜<br><span class="hljs-strong">**这里是文字**</span>  加粗<br><span class="hljs-strong">***这里是文字**</span>*  倾斜加粗<br>~~这里是文字~~  下划线<br></code></pre></td></tr></table></figure><p><em>这里是文字</em><br><em>这里是文字</em><br><strong>这里是文字</strong><br><em><strong>这里是文字</strong></em><br><del>这里是文字</del>   </p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 标题<br>## 标题<br>### 标题<br>#### 标题<br>##### 标题<br>###### 标题<br><br>标题<br>============================<br><br>标题<br>----------------------------<br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[图片描述]</span>(本地图片路径或网络图片路径)<br>!<span class="hljs-selector-attr">[]</span>(/imgs/<span class="hljs-number">123</span>.jpg)<br></code></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&lt;https:<span class="hljs-comment">//www.baidu.com/&gt;</span><br>https:<span class="hljs-comment">//www.baidu.com/</span><br></code></pre></td></tr></table></figure><p><a href="https://www.baidu.com/">https://www.baidu.com/</a><br><a href="https://www.baidu.com/">https://www.baidu.com/</a></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线,也可以在星号或是减号中间插入空格。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">***</span><br><span class="hljs-bullet"></span><span class="hljs-section">___</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>一种是利用缩进(tab), 另一种是利用英文&#96;符号（一般在ESC键下方，和~同一个键）包裹代码</p><p>代码块：缩进 4 个空格或是 1 个制表符</p><pre><code class="hljs">if () &#123;    &#125; else &#123;    &#125;</code></pre><p>行内式：如果在一个行内需要引用代码，只要用反引号&#96;引起来就好（一般在ESC键下方，和~同一个键）, 或者使用三个&#96;&#96;&#96;包裹</p><p><code>if () &#123;&#125; else &#123;&#125;</code></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>被引用的文本前加上&gt;符号，以及一个空格就可以了, 可以多层.引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">引用1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt; 引用2</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; **这里是加粗文字**</span> <br></code></pre></td></tr></table></figure><blockquote><p>引用1</p><blockquote><p>引用2</p><blockquote><p><strong>这里是加粗文字</strong> </p></blockquote></blockquote></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表 使用 *，+，- 表示无序列表。 符号后面一定要有一个空格，起到缩进的作用</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 列表1<br><span class="hljs-bullet">-</span> 列表2<br><span class="hljs-bullet">+</span> 列表3<br><span class="hljs-bullet">+</span> 列表4<br><span class="hljs-bullet">-</span> 列表5<br><span class="hljs-bullet">-</span> 列表6<br></code></pre></td></tr></table></figure><ul><li>列表1</li><li>列表2</li></ul><ul><li>列表3</li><li>列表4</li></ul><ul><li>列表5</li><li>列表6</li></ul><p>使用数字和一个英文句点表示有序列表。英文句点后面一定要有一个空格，起到缩进的作用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. 列表<span class="hljs-number">1</span><br><span class="hljs-attribute">2</span>. 列表<span class="hljs-number">2</span><br><span class="hljs-attribute">3</span>. 列表<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><ol><li>列表1</li><li>列表2</li><li>列表3</li></ol><p>列表不光可以单独使用，也可以使用其他的 Markdown 语法，包括标题、引用、代码区块等</p><p>在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>\.<span class="hljs-number">09</span>\.<span class="hljs-number">13</span> <br></code></pre></td></tr></table></figure><p>2022.09.13 </p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">1 |<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 3</span><br><span class="hljs-string">- </span>|<span class="hljs-string"> - </span>|<span class="hljs-string"> -</span><br><span class="hljs-string">4 </span>|<span class="hljs-string"> 5 </span>|<span class="hljs-string"> 6</span><br><span class="hljs-string">7 </span>|<span class="hljs-string"> 8 </span>|<span class="hljs-string"> 9</span><br><span class="hljs-string"></span><br><span class="hljs-string">11 </span>|<span class="hljs-string"> 222 </span>|<span class="hljs-string"> 3333</span><br><span class="hljs-string">:- </span>|<span class="hljs-string"> :- </span>|<span class="hljs-string"> :-</span><br><span class="hljs-string">444 </span>|<span class="hljs-string"> 5555 </span>|<span class="hljs-string"> 66666</span><br><span class="hljs-string">77777 </span>|<span class="hljs-string"> 88888 </span>|<span class="hljs-string"> 999999</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>4</td><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td><td>9</td></tr></tbody></table><table><thead><tr><th align="left">11</th><th align="left">222</th><th align="left">3333</th></tr></thead><tbody><tr><td align="left">444</td><td align="left">5555</td><td align="left">66666</td></tr><tr><td align="left">77777</td><td align="left">88888</td><td align="left">999999</td></tr></tbody></table><table><thead><tr><th align="right">11</th><th align="right">222</th><th align="right">3333</th></tr></thead><tbody><tr><td align="right">444</td><td align="right">5555</td><td align="right">66666</td></tr><tr><td align="right">77777</td><td align="right">88888</td><td align="right">999999</td></tr></tbody></table><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>连续两个以上空格+回车<br>使用html语言换行标签  </p>]]></content>
    
    
    <categories>
      
      <category>Md</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Md</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看图片</title>
    <link href="/2021/02/04/img/"/>
    <url>/2021/02/04/img/</url>
    
    <content type="html"><![CDATA[<!-- look_img --><span id="more"></span><p><img src="/imgs/123.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
